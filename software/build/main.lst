ARM GAS  /tmp/ccelT0ZE.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.MX_GPIO_Init,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	MX_GPIO_Init:
  23              	.LFB47:
  24              		.file 1 "Src/main.c"
   1:Src/main.c    **** 
   2:Src/main.c    **** /**
   3:Src/main.c    ****   ******************************************************************************
   4:Src/main.c    ****   * @file           : main.c
   5:Src/main.c    ****   * @brief          : Main program body
   6:Src/main.c    ****   ******************************************************************************
   7:Src/main.c    ****   * This notice applies to any and all portions of this file
   8:Src/main.c    ****   * that are not between comment pairs USER CODE BEGIN and
   9:Src/main.c    ****   * USER CODE END. Other portions of this file, whether
  10:Src/main.c    ****   * inserted by the user or by software development tools
  11:Src/main.c    ****   * are owned by their respective copyright owners.
  12:Src/main.c    ****   *
  13:Src/main.c    ****   * Copyright (c) 2018 STMicroelectronics International N.V.
  14:Src/main.c    ****   * All rights reserved.
  15:Src/main.c    ****   *
  16:Src/main.c    ****   * Redistribution and use in source and binary forms, with or without
  17:Src/main.c    ****   * modification, are permitted, provided that the following conditions are met:
  18:Src/main.c    ****   *
  19:Src/main.c    ****   * 1. Redistribution of source code must retain the above copyright notice,
  20:Src/main.c    ****   *    this list of conditions and the following disclaimer.
  21:Src/main.c    ****   * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:Src/main.c    ****   *    this list of conditions and the following disclaimer in the documentation
  23:Src/main.c    ****   *    and/or other materials provided with the distribution.
  24:Src/main.c    ****   * 3. Neither the name of STMicroelectronics nor the names of other
  25:Src/main.c    ****   *    contributors to this software may be used to endorse or promote products
  26:Src/main.c    ****   *    derived from this software without specific written permission.
  27:Src/main.c    ****   * 4. This software, including modifications and/or derivative works of this
  28:Src/main.c    ****   *    software, must execute solely and exclusively on microcontroller or
  29:Src/main.c    ****   *    microprocessor devices manufactured by or for STMicroelectronics.
  30:Src/main.c    ****   * 5. Redistribution and use of this software other than as permitted under
  31:Src/main.c    ****   *    this license is void and will automatically terminate your rights under
  32:Src/main.c    ****   *    this license.
  33:Src/main.c    ****   *
  34:Src/main.c    ****   * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
ARM GAS  /tmp/ccelT0ZE.s 			page 2


  35:Src/main.c    ****   * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
  36:Src/main.c    ****   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  37:Src/main.c    ****   * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
  38:Src/main.c    ****   * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
  39:Src/main.c    ****   * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  40:Src/main.c    ****   * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  41:Src/main.c    ****   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  42:Src/main.c    ****   * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  43:Src/main.c    ****   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  44:Src/main.c    ****   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  45:Src/main.c    ****   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  46:Src/main.c    ****   *
  47:Src/main.c    ****   ******************************************************************************
  48:Src/main.c    ****   */
  49:Src/main.c    **** /* Includes ------------------------------------------------------------------*/
  50:Src/main.c    **** #include "main.h"
  51:Src/main.c    **** #include "stm32f0xx_hal.h"
  52:Src/main.c    **** #include "usb_device.h"
  53:Src/main.c    **** 
  54:Src/main.c    **** /* USER CODE BEGIN Includes */
  55:Src/main.c    **** #include "device_conf.h"
  56:Src/main.c    **** #include "curemisc.h"
  57:Src/main.c    **** #include "curebuffer.h"
  58:Src/main.c    **** #include "usbd_midi_if.h"
  59:Src/main.c    **** #include "math.h"
  60:Src/main.c    **** 
  61:Src/main.c    **** /* USER CODE END Includes */
  62:Src/main.c    **** 
  63:Src/main.c    **** /* Private variables ---------------------------------------------------------*/
  64:Src/main.c    **** TIM_HandleTypeDef htim14;
  65:Src/main.c    **** TIM_HandleTypeDef htim15;
  66:Src/main.c    **** 
  67:Src/main.c    **** TIM_HandleTypeDef htim17;
  68:Src/main.c    **** 
  69:Src/main.c    **** TIM_HandleTypeDef htim2;
  70:Src/main.c    **** 
  71:Src/main.c    **** TIM_HandleTypeDef htim1;
  72:Src/main.c    **** 
  73:Src/main.c    **** DAC_HandleTypeDef hdac;
  74:Src/main.c    **** 
  75:Src/main.c    **** ADC_HandleTypeDef hadc;
  76:Src/main.c    **** DMA_HandleTypeDef hdma_adc;
  77:Src/main.c    **** 
  78:Src/main.c    **** uint16_t adcBuffer[3];
  79:Src/main.c    **** 
  80:Src/main.c    **** 
  81:Src/main.c    **** uint8_t uart_tx_dat;
  82:Src/main.c    **** /* USER CODE END PV */
  83:Src/main.c    **** 
  84:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
  85:Src/main.c    **** void SystemClock_Config(void);
  86:Src/main.c    **** static void MX_GPIO_Init(void);
  87:Src/main.c    **** 
  88:Src/main.c    **** static void MX_TIM14_Init(void);
  89:Src/main.c    **** static void MX_TIM15_Init(void);
  90:Src/main.c    **** static void MX_TIM17_Init(void);
  91:Src/main.c    **** static void USER_TIM2_Init(void);
ARM GAS  /tmp/ccelT0ZE.s 			page 3


  92:Src/main.c    **** static void USER_TIM1_Init(void);
  93:Src/main.c    **** 
  94:Src/main.c    **** static void MX_DAC_Init(void);
  95:Src/main.c    **** 
  96:Src/main.c    **** static void MX_DMA_Init(void);
  97:Src/main.c    **** static void MX_ADC_Init(void);
  98:Src/main.c    **** 
  99:Src/main.c    **** void htim17_update(void);
 100:Src/main.c    **** 
 101:Src/main.c    **** uint32_t Vout = 0;
 102:Src/main.c    **** uint16_t Iout = 0;
 103:Src/main.c    **** uint32_t Vset = 0;
 104:Src/main.c    **** uint32_t Vmax = 52000;
 105:Src/main.c    **** 
 106:Src/main.c    **** void htim17_update() {
 107:Src/main.c    ****   Iout = adcBuffer[0] * 1.33f;
 108:Src/main.c    ****   Vout = adcBuffer[1] * 16.6f;
 109:Src/main.c    ****   int32_t error = Vset - Vout;
 110:Src/main.c    **** 
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 112:Src/main.c    **** 
 113:Src/main.c    ****   if (Vout > 55000) {
 114:Src/main.c    ****     TIM1->CCR1 = 0;
 115:Src/main.c    ****   }
 116:Src/main.c    **** }
 117:Src/main.c    **** 
 118:Src/main.c    **** /* USER CODE BEGIN PFP */
 119:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
 120:Src/main.c    **** void dfu_otter_bootloader(void)
 121:Src/main.c    **** {
 122:Src/main.c    ****   *((unsigned long *)0x20003FF0) = 0xDEADBEEF;
 123:Src/main.c    ****   NVIC_SystemReset();
 124:Src/main.c    **** }
 125:Src/main.c    **** /* USER CODE END PFP */
 126:Src/main.c    **** 
 127:Src/main.c    **** /* USER CODE BEGIN 0 */
 128:Src/main.c    **** 
 129:Src/main.c    **** uint32_t curPeriode0 = 0;
 130:Src/main.c    **** uint32_t curPeriode1 = 0;
 131:Src/main.c    **** 
 132:Src/main.c    **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
 133:Src/main.c    **** {
 134:Src/main.c    **** 	if(htim->Instance == TIM14)
 135:Src/main.c    **** 	{
 136:Src/main.c    **** 		//HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 137:Src/main.c    ****     if (TIM2->CNT == 0) {
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 139:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 140:Src/main.c    ****     }
 141:Src/main.c    **** 	}
 142:Src/main.c    **** 	if(htim->Instance == TIM15)
 143:Src/main.c    **** 	{
 144:Src/main.c    **** 		//HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 145:Src/main.c    ****     if (TIM2->CNT == 0) {
 146:Src/main.c    ****     	TIM2->ARR = (uint32_t)(curPeriode1 / 8); // Play second channel with less power
 147:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 148:Src/main.c    ****     }
ARM GAS  /tmp/ccelT0ZE.s 			page 4


 149:Src/main.c    **** 	}
 150:Src/main.c    **** }
 151:Src/main.c    **** 
 152:Src/main.c    **** /**
 153:Src/main.c    ****   * @brief  The application entry point.
 154:Src/main.c    ****   *
 155:Src/main.c    ****   * @retval None
 156:Src/main.c    ****   */
 157:Src/main.c    **** 
 158:Src/main.c    **** 
 159:Src/main.c    **** uint8_t midiBuffer[4];
 160:Src/main.c    **** uint8_t midiState = 0;
 161:Src/main.c    **** 
 162:Src/main.c    **** uint16_t curTone0 = 0;
 163:Src/main.c    **** uint16_t curTone1 = 0;
 164:Src/main.c    **** uint16_t curChannel = 0;
 165:Src/main.c    **** uint16_t lastTone0 = 0;
 166:Src/main.c    **** uint16_t lastTone1 = 0;
 167:Src/main.c    **** uint32_t noteTimeout = 0;
 168:Src/main.c    **** 
 169:Src/main.c    **** uint16_t freqs[16] = {0};
 170:Src/main.c    **** 
 171:Src/main.c    **** 
 172:Src/main.c    **** int main(void)
 173:Src/main.c    **** {
 174:Src/main.c    ****   /* USER CODE BEGIN 1 */
 175:Src/main.c    **** 
 176:Src/main.c    ****   /* USER CODE END 1 */
 177:Src/main.c    **** 
 178:Src/main.c    ****   /* MCU Configuration----------------------------------------------------------*/
 179:Src/main.c    **** 
 180:Src/main.c    ****   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 181:Src/main.c    ****   HAL_Init();
 182:Src/main.c    **** 
 183:Src/main.c    ****   /* USER CODE BEGIN Init */
 184:Src/main.c    **** 
 185:Src/main.c    ****   /* USER CODE END Init */
 186:Src/main.c    **** 
 187:Src/main.c    ****   /* Configure the system clock */
 188:Src/main.c    ****   SystemClock_Config();
 189:Src/main.c    **** 
 190:Src/main.c    ****   /* USER CODE BEGIN SysInit */
 191:Src/main.c    **** 
 192:Src/main.c    ****   /* USER CODE END SysInit */
 193:Src/main.c    **** 
 194:Src/main.c    ****   /* Initialize all configured peripherals */
 195:Src/main.c    ****   MX_GPIO_Init();
 196:Src/main.c    **** 	MX_DAC_Init();
 197:Src/main.c    **** 
 198:Src/main.c    **** 	HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
 199:Src/main.c    **** 	HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048);
 200:Src/main.c    **** 
 201:Src/main.c    **** 	MX_TIM14_Init();
 202:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim14);
 203:Src/main.c    **** 	TIM14->CR1 &= ~(1UL);
 204:Src/main.c    **** 
 205:Src/main.c    **** 	MX_TIM15_Init();
ARM GAS  /tmp/ccelT0ZE.s 			page 5


 206:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim15);
 207:Src/main.c    **** 	TIM15->CR1 &= ~(1UL);
 208:Src/main.c    **** 
 209:Src/main.c    ****   MX_DMA_Init();
 210:Src/main.c    ****   MX_ADC_Init();
 211:Src/main.c    **** 
 212:Src/main.c    ****   HAL_ADC_Start_DMA(&hadc, (uint32_t*)adcBuffer, 3);
 213:Src/main.c    **** 
 214:Src/main.c    **** 
 215:Src/main.c    **** 	USER_TIM1_Init();
 216:Src/main.c    **** 
 217:Src/main.c    ****   //HAL_TIM_PWM_Start(&htim1);
 218:Src/main.c    ****   HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_1);
 219:Src/main.c    **** 
 220:Src/main.c    ****   //__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 1000);
 221:Src/main.c    **** 
 222:Src/main.c    ****   USER_TIM2_Init();
 223:Src/main.c    **** 
 224:Src/main.c    **** 	HAL_TIM_Base_Start(&htim2);
 225:Src/main.c    **** 	HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 226:Src/main.c    **** 
 227:Src/main.c    ****   /* USER CODE BEGIN 2 */
 228:Src/main.c    **** 
 229:Src/main.c    ****   //USB-MIDI Init
 230:Src/main.c    ****   MX_USB_MIDI_INIT();
 231:Src/main.c    **** 
 232:Src/main.c    **** 
 233:Src/main.c    ****   if(FUNC_ERROR == midiInit() ){
 234:Src/main.c    **** 	  while(1){
 235:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 236:Src/main.c    **** 		  HAL_Delay(500);
 237:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 238:Src/main.c    **** 		  HAL_Delay(500);
 239:Src/main.c    **** 	  }
 240:Src/main.c    ****   }
 241:Src/main.c    **** 
 242:Src/main.c    ****   //Wait usb configuration.
 243:Src/main.c    ****   while(1){
 244:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 245:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 246:Src/main.c    **** 		  break;
 247:Src/main.c    **** 	  }else{
 248:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 249:Src/main.c    **** 	  }
 250:Src/main.c    ****   }
 251:Src/main.c    **** 
 252:Src/main.c    ****   MX_TIM17_Init();
 253:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim17);
 254:Src/main.c    **** 
 255:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 256:Src/main.c    ****     Vset = i;
 257:Src/main.c    ****     HAL_Delay(1);
 258:Src/main.c    ****   }
 259:Src/main.c    **** 
 260:Src/main.c    ****   Vset = Vmax;
 261:Src/main.c    **** 
 262:Src/main.c    ****   while (1)
ARM GAS  /tmp/ccelT0ZE.s 			page 6


 263:Src/main.c    ****   {
 264:Src/main.c    ****   //Wait USB configuration when USB connection error has occurred.
 265:Src/main.c    **** 	   while(1){
 266:Src/main.c    **** 				//HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 267:Src/main.c    **** 			if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 268:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 269:Src/main.c    **** 			  break;
 270:Src/main.c    **** 		  }else{
 271:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 272:Src/main.c    **** 			  HAL_Delay(200);
 273:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 274:Src/main.c    **** 			  HAL_Delay(200);
 275:Src/main.c    **** 		  }
 276:Src/main.c    **** 	  }
 277:Src/main.c    ****     if (HAL_GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN)) {
 278:Src/main.c    ****       dfu_otter_bootloader();
 279:Src/main.c    ****     }
 280:Src/main.c    **** 
 281:Src/main.c    **** 
 282:Src/main.c    **** 		curTone0 = 0;
 283:Src/main.c    **** 		curTone1 = 0;
 284:Src/main.c    **** 
 285:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 286:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 287:Src/main.c    **** 	          curTone1 = curTone0;
 288:Src/main.c    **** 	          curTone0 = freqs[i];
 289:Src/main.c    **** 	      }
 290:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 291:Src/main.c    **** 	          curTone1 = freqs[i];
 292:Src/main.c    **** 	      }
 293:Src/main.c    **** 	  }
 294:Src/main.c    **** 
 295:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 296:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 297:Src/main.c    **** 			TIM14->CNT = 0;
 298:Src/main.c    **** 			TIM14->ARR = curPeriode0;
 299:Src/main.c    **** 			TIM14->CR1 = TIM14->CR1 | 1;
 300:Src/main.c    **** 			lastTone0 = curTone0;
 301:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 302:Src/main.c    **** 
 303:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 304:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 305:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 306:Src/main.c    ****       curPeriode0 = 0;
 307:Src/main.c    **** 
 308:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 309:Src/main.c    **** 		}
 310:Src/main.c    **** 
 311:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 312:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 313:Src/main.c    **** 			TIM15->CNT = 0;
 314:Src/main.c    **** 			TIM15->ARR = curPeriode1;
 315:Src/main.c    **** 			TIM15->CR1 = TIM15->CR1 | 1;
 316:Src/main.c    **** 			lastTone1 = curTone1;
 317:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 318:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 319:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
ARM GAS  /tmp/ccelT0ZE.s 			page 7


 320:Src/main.c    ****       curPeriode1 = 0;
 321:Src/main.c    **** 		}
 322:Src/main.c    **** 
 323:Src/main.c    **** 		if ((HAL_GetTick() - noteTimeout) > 1000) {
 324:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 325:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 326:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 327:Src/main.c    **** 				freqs[i] = 0;
 328:Src/main.c    **** 			}
 329:Src/main.c    **** 
 330:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 331:Src/main.c    **** 		}
 332:Src/main.c    **** 
 333:Src/main.c    **** 
 334:Src/main.c    **** 		//[USB-MIDI IN] to [MIDI JACK OUT]
 335:Src/main.c    **** 
 336:Src/main.c    **** 		if( FUNC_SUCCESS == midiGetFromUsbRx(0, &uart_tx_dat)){
 337:Src/main.c    **** 			if (uart_tx_dat >> 7 == 1) {
 338:Src/main.c    **** 				midiBuffer[0] = uart_tx_dat;
 339:Src/main.c    **** 				midiBuffer[1] = 0;
 340:Src/main.c    **** 				midiBuffer[2] = 0;
 341:Src/main.c    **** 				midiState = 1;
 342:Src/main.c    **** 			} else if (midiState == 1) {
 343:Src/main.c    **** 				midiBuffer[1] = uart_tx_dat;
 344:Src/main.c    **** 				midiState = 2;
 345:Src/main.c    **** 			} else if (midiState == 2) {
 346:Src/main.c    **** 				midiBuffer[2] = uart_tx_dat;
 347:Src/main.c    **** 				midiState = 3;
 348:Src/main.c    **** 
 349:Src/main.c    **** 				if ((midiBuffer[0] & 0xF0) == 0x90) { // Note on, 2 data bytes
 350:Src/main.c    **** 					char key = midiBuffer[1];
 351:Src/main.c    **** 					char vel = midiBuffer[2];
 352:Src/main.c    **** 
 353:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 354:Src/main.c    **** 					curChannel = midiBuffer[0] & 0xF;
 355:Src/main.c    **** 					freqs[curChannel] = freq;
 356:Src/main.c    **** 
 357:Src/main.c    **** 
 358:Src/main.c    **** 				} if ((midiBuffer[0] &0xF0) == 0x80) { // Note off, 2 data bytes
 359:Src/main.c    **** 					char key = midiBuffer[1];
 360:Src/main.c    **** 					char vel = midiBuffer[2];
 361:Src/main.c    **** 
 362:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 363:Src/main.c    **** 
 364:Src/main.c    **** 					//if (freqs[midiBuffer[0] & 0xF] == freq) {
 365:Src/main.c    **** 					freqs[midiBuffer[0] & 0xF] = 0;
 366:Src/main.c    **** 					//}
 367:Src/main.c    **** 				}
 368:Src/main.c    **** 			}
 369:Src/main.c    **** 		}
 370:Src/main.c    **** 
 371:Src/main.c    **** 	//[MIDI JACK IN] to [USB-MIDI OUT]
 372:Src/main.c    **** 	//midiProcess();
 373:Src/main.c    **** 
 374:Src/main.c    **** 
 375:Src/main.c    ****   }
 376:Src/main.c    ****   /* USER CODE END 3 */
ARM GAS  /tmp/ccelT0ZE.s 			page 8


 377:Src/main.c    **** 
 378:Src/main.c    **** }
 379:Src/main.c    **** 
 380:Src/main.c    **** /** System Clock Configuration
 381:Src/main.c    **** */
 382:Src/main.c    **** void SystemClock_Config(void)
 383:Src/main.c    **** {
 384:Src/main.c    **** 
 385:Src/main.c    ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 386:Src/main.c    ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 387:Src/main.c    ****   RCC_PeriphCLKInitTypeDef PeriphClkInit;
 388:Src/main.c    **** 
 389:Src/main.c    ****     /**Initializes the CPU, AHB and APB busses clocks
 390:Src/main.c    ****     */
 391:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48;
 392:Src/main.c    ****   RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 393:Src/main.c    ****   RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 394:Src/main.c    ****   RCC_OscInitStruct.HSI14CalibrationValue = 16;
 395:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 396:Src/main.c    ****   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 397:Src/main.c    ****   {
 398:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 399:Src/main.c    ****   }
 400:Src/main.c    **** 
 401:Src/main.c    ****     /**Initializes the CPU, AHB and APB busses clocks
 402:Src/main.c    ****     */
 403:Src/main.c    ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 404:Src/main.c    ****                               |RCC_CLOCKTYPE_PCLK1;
 405:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 406:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 407:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 408:Src/main.c    **** 
 409:Src/main.c    ****   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 410:Src/main.c    ****   {
 411:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 412:Src/main.c    ****   }
 413:Src/main.c    **** 
 414:Src/main.c    ****   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 415:Src/main.c    ****   PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 416:Src/main.c    **** 
 417:Src/main.c    ****   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 418:Src/main.c    ****   {
 419:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 420:Src/main.c    ****   }
 421:Src/main.c    **** 
 422:Src/main.c    ****     /**Configure the Systick interrupt time
 423:Src/main.c    ****     */
 424:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 425:Src/main.c    **** 
 426:Src/main.c    ****     /**Configure the Systick
 427:Src/main.c    ****     */
 428:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 429:Src/main.c    **** 
 430:Src/main.c    ****   /* SysTick_IRQn interrupt configuration */
 431:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 432:Src/main.c    **** }
 433:Src/main.c    **** 
ARM GAS  /tmp/ccelT0ZE.s 			page 9


 434:Src/main.c    **** /* ADC init function */
 435:Src/main.c    **** static void MX_ADC_Init(void)
 436:Src/main.c    **** {
 437:Src/main.c    ****   __HAL_RCC_ADC1_CLK_ENABLE();
 438:Src/main.c    ****   ADC_ChannelConfTypeDef sConfig;
 439:Src/main.c    **** 
 440:Src/main.c    ****     /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of co
 441:Src/main.c    ****     */
 442:Src/main.c    ****   hadc.Instance = ADC1;
 443:Src/main.c    ****   hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 444:Src/main.c    ****   hadc.Init.Resolution = ADC_RESOLUTION_12B;
 445:Src/main.c    ****   hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 446:Src/main.c    ****   hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 447:Src/main.c    ****   hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 448:Src/main.c    ****   hadc.Init.LowPowerAutoWait = DISABLE;
 449:Src/main.c    ****   hadc.Init.LowPowerAutoPowerOff = DISABLE;
 450:Src/main.c    ****   hadc.Init.ContinuousConvMode = DISABLE;
 451:Src/main.c    ****   hadc.Init.DiscontinuousConvMode = DISABLE;
 452:Src/main.c    ****   hadc.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_TRGO;
 453:Src/main.c    ****   hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 454:Src/main.c    ****   hadc.Init.DMAContinuousRequests = ENABLE;
 455:Src/main.c    ****   hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 456:Src/main.c    ****   if (HAL_ADC_Init(&hadc) != HAL_OK)
 457:Src/main.c    ****   {
 458:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 459:Src/main.c    ****   }
 460:Src/main.c    **** 
 461:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 462:Src/main.c    ****     */
 463:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_0;
 464:Src/main.c    ****   sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 465:Src/main.c    ****   sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES_5;
 466:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 467:Src/main.c    ****   {
 468:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 469:Src/main.c    ****   }
 470:Src/main.c    **** 
 471:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 472:Src/main.c    ****     */
 473:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_1;
 474:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 475:Src/main.c    ****   {
 476:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 477:Src/main.c    ****   }
 478:Src/main.c    **** 
 479:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 480:Src/main.c    ****     */
 481:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_2;
 482:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 483:Src/main.c    ****   {
 484:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 485:Src/main.c    ****   }
 486:Src/main.c    **** 
 487:Src/main.c    **** 
 488:Src/main.c    **** }
 489:Src/main.c    **** 
 490:Src/main.c    **** /**
ARM GAS  /tmp/ccelT0ZE.s 			page 10


 491:Src/main.c    ****   * Enable DMA controller clock
 492:Src/main.c    ****   */
 493:Src/main.c    **** static void MX_DMA_Init(void)
 494:Src/main.c    **** {
 495:Src/main.c    ****   /* DMA controller clock enable */
 496:Src/main.c    ****   __HAL_RCC_DMA1_CLK_ENABLE();
 497:Src/main.c    **** 
 498:Src/main.c    ****   /* DMA interrupt init */
 499:Src/main.c    ****   /* DMA1_Channel1_IRQn interrupt configuration */
 500:Src/main.c    ****   HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 501:Src/main.c    ****   HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 502:Src/main.c    **** 
 503:Src/main.c    **** }
 504:Src/main.c    **** 
 505:Src/main.c    **** 
 506:Src/main.c    **** /* TIM14 init function */
 507:Src/main.c    **** static void MX_TIM14_Init(void)
 508:Src/main.c    **** {
 509:Src/main.c    ****   htim14.Instance = TIM14;
 510:Src/main.c    ****   htim14.Init.Prescaler = 11;
 511:Src/main.c    ****   htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 512:Src/main.c    ****   htim14.Init.Period = 1000;
 513:Src/main.c    ****   htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 514:Src/main.c    ****   htim14.Init.RepetitionCounter = 0;
 515:Src/main.c    ****   htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 516:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 517:Src/main.c    ****   {
 518:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 519:Src/main.c    ****   }
 520:Src/main.c    **** }
 521:Src/main.c    **** 
 522:Src/main.c    **** /* TIM15 init function */
 523:Src/main.c    **** static void MX_TIM15_Init(void)
 524:Src/main.c    **** {
 525:Src/main.c    ****   htim15.Instance = TIM15;
 526:Src/main.c    ****   htim15.Init.Prescaler = 11;
 527:Src/main.c    ****   htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 528:Src/main.c    ****   htim15.Init.Period = 1000;
 529:Src/main.c    ****   htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 530:Src/main.c    ****   htim15.Init.RepetitionCounter = 0;
 531:Src/main.c    ****   htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 532:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 533:Src/main.c    ****   {
 534:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 535:Src/main.c    ****   }
 536:Src/main.c    **** }
 537:Src/main.c    **** 
 538:Src/main.c    **** /* TIM17 init function */
 539:Src/main.c    **** static void MX_TIM17_Init(void)
 540:Src/main.c    **** {
 541:Src/main.c    ****   htim17.Instance = TIM17;
 542:Src/main.c    ****   htim17.Init.Prescaler = 11;
 543:Src/main.c    ****   htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 544:Src/main.c    ****   htim17.Init.Period = 1000;
 545:Src/main.c    ****   htim17.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 546:Src/main.c    ****   htim17.Init.RepetitionCounter = 0;
 547:Src/main.c    ****   htim17.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
ARM GAS  /tmp/ccelT0ZE.s 			page 11


 548:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim17) != HAL_OK)
 549:Src/main.c    ****   {
 550:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 551:Src/main.c    ****   }
 552:Src/main.c    **** }
 553:Src/main.c    **** 
 554:Src/main.c    **** static void USER_TIM2_Init(void) {
 555:Src/main.c    **** 	__HAL_RCC_TIM2_CLK_ENABLE();
 556:Src/main.c    **** 
 557:Src/main.c    **** 	TIM_ClockConfigTypeDef sClockSourceConfig;
 558:Src/main.c    **** 	TIM_MasterConfigTypeDef sMasterConfig;
 559:Src/main.c    **** 	TIM_OC_InitTypeDef sConfigOC;
 560:Src/main.c    **** 
 561:Src/main.c    **** 	htim2.Instance = TIM2;
 562:Src/main.c    **** 	htim2.Init.Prescaler = 0;
 563:Src/main.c    **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 564:Src/main.c    **** 	htim2.Init.Period = 3200;
 565:Src/main.c    **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 566:Src/main.c    **** 	HAL_TIM_Base_Init(&htim2);
 567:Src/main.c    **** 
 568:Src/main.c    **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 569:Src/main.c    **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 570:Src/main.c    **** 	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 571:Src/main.c    **** 
 572:Src/main.c    **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 573:Src/main.c    **** 	sConfigOC.Pulse = 1;
 574:Src/main.c    **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
 575:Src/main.c    **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 576:Src/main.c    **** 	HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
 577:Src/main.c    **** 
 578:Src/main.c    **** 	HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
 579:Src/main.c    **** 	HAL_TIM_MspPostInit(&htim2);
 580:Src/main.c    **** }
 581:Src/main.c    **** 
 582:Src/main.c    **** static void USER_TIM1_Init(void)
 583:Src/main.c    **** {
 584:Src/main.c    ****   __HAL_RCC_TIM1_CLK_ENABLE();
 585:Src/main.c    **** 
 586:Src/main.c    ****   TIM_MasterConfigTypeDef sMasterConfig;
 587:Src/main.c    ****   TIM_OC_InitTypeDef sConfigOC;
 588:Src/main.c    ****   TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
 589:Src/main.c    **** 
 590:Src/main.c    ****   htim1.Instance = TIM1;
 591:Src/main.c    ****   htim1.Init.Prescaler = 0;
 592:Src/main.c    ****   htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 593:Src/main.c    ****   htim1.Init.Period = 1024;
 594:Src/main.c    ****   htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 595:Src/main.c    ****   htim1.Init.RepetitionCounter = 0;
 596:Src/main.c    ****   htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 597:Src/main.c    ****   if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 598:Src/main.c    ****   {
 599:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 600:Src/main.c    ****   }
 601:Src/main.c    **** 
 602:Src/main.c    ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 603:Src/main.c    ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 604:Src/main.c    ****   if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
ARM GAS  /tmp/ccelT0ZE.s 			page 12


 605:Src/main.c    ****   {
 606:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 607:Src/main.c    ****   }
 608:Src/main.c    **** 
 609:Src/main.c    ****   sConfigOC.OCMode = TIM_OCMODE_PWM1;
 610:Src/main.c    ****   sConfigOC.Pulse = 0;
 611:Src/main.c    ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 612:Src/main.c    ****   sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 613:Src/main.c    ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 614:Src/main.c    ****   sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 615:Src/main.c    ****   sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 616:Src/main.c    ****   if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 617:Src/main.c    ****   {
 618:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 619:Src/main.c    ****   }
 620:Src/main.c    **** 
 621:Src/main.c    ****   sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 622:Src/main.c    ****   sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 623:Src/main.c    ****   sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 624:Src/main.c    ****   sBreakDeadTimeConfig.DeadTime = 0;
 625:Src/main.c    ****   sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 626:Src/main.c    ****   sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 627:Src/main.c    ****   sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 628:Src/main.c    ****   if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 629:Src/main.c    ****   {
 630:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 631:Src/main.c    ****   }
 632:Src/main.c    **** 
 633:Src/main.c    ****   HAL_TIM_MspPostInit(&htim1);
 634:Src/main.c    **** }
 635:Src/main.c    **** 
 636:Src/main.c    **** 
 637:Src/main.c    **** /* DAC init function */
 638:Src/main.c    **** static void MX_DAC_Init(void)
 639:Src/main.c    **** {
 640:Src/main.c    **** 
 641:Src/main.c    ****   DAC_ChannelConfTypeDef sConfig;
 642:Src/main.c    **** 
 643:Src/main.c    ****     /**DAC Initialization
 644:Src/main.c    ****     */
 645:Src/main.c    ****   hdac.Instance = DAC;
 646:Src/main.c    ****   if (HAL_DAC_Init(&hdac) != HAL_OK)
 647:Src/main.c    ****   {
 648:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 649:Src/main.c    ****   }
 650:Src/main.c    **** 
 651:Src/main.c    ****     /**DAC channel OUT1 config
 652:Src/main.c    ****     */
 653:Src/main.c    ****   sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 654:Src/main.c    ****   sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 655:Src/main.c    ****   if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 656:Src/main.c    ****   {
 657:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 658:Src/main.c    ****   }
 659:Src/main.c    **** 
 660:Src/main.c    **** }
 661:Src/main.c    **** 
ARM GAS  /tmp/ccelT0ZE.s 			page 13


 662:Src/main.c    **** 
 663:Src/main.c    **** 
 664:Src/main.c    **** /**
 665:Src/main.c    ****   * Enable DMA controller clock
 666:Src/main.c    ****   */
 667:Src/main.c    **** 
 668:Src/main.c    **** 
 669:Src/main.c    **** /** Configure pins as
 670:Src/main.c    ****         * Analog
 671:Src/main.c    ****         * Input
 672:Src/main.c    ****         * Output
 673:Src/main.c    ****         * EVENT_OUT
 674:Src/main.c    ****         * EXTI
 675:Src/main.c    **** */
 676:Src/main.c    **** static void MX_GPIO_Init(void)
 677:Src/main.c    **** {
  25              		.loc 1 677 0
  26              		.cfi_startproc
  27 0000 30B5     		push	{r4, r5, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 12
  30              		.cfi_offset 4, -12
  31              		.cfi_offset 5, -8
  32              		.cfi_offset 14, -4
  33 0002 89B0     		sub	sp, sp, #36
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 48
  36              	.LBB8:
 678:Src/main.c    **** 
 679:Src/main.c    ****   GPIO_InitTypeDef GPIO_InitStruct;
 680:Src/main.c    **** 
 681:Src/main.c    ****   /* GPIO Ports Clock Enable */
 682:Src/main.c    ****   __HAL_RCC_GPIOF_CLK_ENABLE();
  37              		.loc 1 682 0
  38 0004 184B     		ldr	r3, .L2
  39 0006 5969     		ldr	r1, [r3, #20]
  40 0008 8022     		mov	r2, #128
  41 000a D203     		lsl	r2, r2, #15
  42 000c 1143     		orr	r1, r2
  43 000e 5961     		str	r1, [r3, #20]
  44 0010 5969     		ldr	r1, [r3, #20]
  45 0012 0A40     		and	r2, r1
  46 0014 0092     		str	r2, [sp]
  47 0016 009A     		ldr	r2, [sp]
  48              	.LBE8:
  49              	.LBB9:
 683:Src/main.c    ****   __HAL_RCC_GPIOA_CLK_ENABLE();
  50              		.loc 1 683 0
  51 0018 5969     		ldr	r1, [r3, #20]
  52 001a 8022     		mov	r2, #128
  53 001c 9202     		lsl	r2, r2, #10
  54 001e 1143     		orr	r1, r2
  55 0020 5961     		str	r1, [r3, #20]
  56 0022 5969     		ldr	r1, [r3, #20]
  57 0024 0A40     		and	r2, r1
  58 0026 0192     		str	r2, [sp, #4]
  59 0028 019A     		ldr	r2, [sp, #4]
ARM GAS  /tmp/ccelT0ZE.s 			page 14


  60              	.LBE9:
  61              	.LBB10:
 684:Src/main.c    ****   __HAL_RCC_GPIOB_CLK_ENABLE();
  62              		.loc 1 684 0
  63 002a 5969     		ldr	r1, [r3, #20]
  64 002c 8022     		mov	r2, #128
  65 002e D202     		lsl	r2, r2, #11
  66 0030 1143     		orr	r1, r2
  67 0032 5961     		str	r1, [r3, #20]
  68 0034 5B69     		ldr	r3, [r3, #20]
  69 0036 1A40     		and	r2, r3
  70 0038 0292     		str	r2, [sp, #8]
  71 003a 029B     		ldr	r3, [sp, #8]
  72              	.LBE10:
 685:Src/main.c    **** 
 686:Src/main.c    ****   /*Configure GPIO pin Output Level */
 687:Src/main.c    ****   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10|GPIO_PIN_15, GPIO_PIN_RESET);
  73              		.loc 1 687 0
  74 003c 9024     		mov	r4, #144
  75 003e E405     		lsl	r4, r4, #23
  76 0040 8425     		mov	r5, #132
  77 0042 2D02     		lsl	r5, r5, #8
  78 0044 201C     		mov	r0, r4
  79 0046 291C     		mov	r1, r5
  80 0048 0022     		mov	r2, #0
  81 004a FFF7FEFF 		bl	HAL_GPIO_WritePin
  82              	.LVL0:
 688:Src/main.c    **** 
 689:Src/main.c    ****   /*Configure GPIO pins : PA4 PA5 PA6 PA7 */
 690:Src/main.c    ****   GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_15;
  83              		.loc 1 690 0
  84 004e 0395     		str	r5, [sp, #12]
 691:Src/main.c    ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  85              		.loc 1 691 0
  86 0050 0123     		mov	r3, #1
  87 0052 0493     		str	r3, [sp, #16]
 692:Src/main.c    ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  88              		.loc 1 692 0
  89 0054 0023     		mov	r3, #0
  90 0056 0593     		str	r3, [sp, #20]
 693:Src/main.c    ****   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  91              		.loc 1 693 0
  92 0058 0693     		str	r3, [sp, #24]
 694:Src/main.c    ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  93              		.loc 1 694 0
  94 005a 201C     		mov	r0, r4
  95 005c 03A9     		add	r1, sp, #12
  96 005e FFF7FEFF 		bl	HAL_GPIO_Init
  97              	.LVL1:
 695:Src/main.c    **** }
  98              		.loc 1 695 0
  99 0062 09B0     		add	sp, sp, #36
 100              		@ sp needed
 101 0064 30BD     		pop	{r4, r5, pc}
 102              	.L3:
 103 0066 C046     		.align	2
 104              	.L2:
ARM GAS  /tmp/ccelT0ZE.s 			page 15


 105 0068 00100240 		.word	1073876992
 106              		.cfi_endproc
 107              	.LFE47:
 109              		.section	.text.MX_DMA_Init,"ax",%progbits
 110              		.align	2
 111              		.code	16
 112              		.thumb_func
 114              	MX_DMA_Init:
 115              	.LFB40:
 494:Src/main.c    **** {
 116              		.loc 1 494 0
 117              		.cfi_startproc
 118 0000 00B5     		push	{lr}
 119              	.LCFI2:
 120              		.cfi_def_cfa_offset 4
 121              		.cfi_offset 14, -4
 122 0002 83B0     		sub	sp, sp, #12
 123              	.LCFI3:
 124              		.cfi_def_cfa_offset 16
 125              	.LBB11:
 496:Src/main.c    ****   __HAL_RCC_DMA1_CLK_ENABLE();
 126              		.loc 1 496 0
 127 0004 094B     		ldr	r3, .L5
 128 0006 5969     		ldr	r1, [r3, #20]
 129 0008 0122     		mov	r2, #1
 130 000a 1143     		orr	r1, r2
 131 000c 5961     		str	r1, [r3, #20]
 132 000e 5B69     		ldr	r3, [r3, #20]
 133 0010 1A40     		and	r2, r3
 134 0012 0192     		str	r2, [sp, #4]
 135 0014 019B     		ldr	r3, [sp, #4]
 136              	.LBE11:
 500:Src/main.c    ****   HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 137              		.loc 1 500 0
 138 0016 0920     		mov	r0, #9
 139 0018 0021     		mov	r1, #0
 140 001a 0022     		mov	r2, #0
 141 001c FFF7FEFF 		bl	HAL_NVIC_SetPriority
 142              	.LVL2:
 501:Src/main.c    ****   HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 143              		.loc 1 501 0
 144 0020 0920     		mov	r0, #9
 145 0022 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 146              	.LVL3:
 503:Src/main.c    **** }
 147              		.loc 1 503 0
 148 0026 03B0     		add	sp, sp, #12
 149              		@ sp needed
 150 0028 00BD     		pop	{pc}
 151              	.L6:
 152 002a C046     		.align	2
 153              	.L5:
 154 002c 00100240 		.word	1073876992
 155              		.cfi_endproc
 156              	.LFE40:
 158              		.section	.text.USER_TIM2_Init,"ax",%progbits
 159              		.align	2
ARM GAS  /tmp/ccelT0ZE.s 			page 16


 160              		.code	16
 161              		.thumb_func
 163              	USER_TIM2_Init:
 164              	.LFB44:
 554:Src/main.c    **** static void USER_TIM2_Init(void) {
 165              		.loc 1 554 0
 166              		.cfi_startproc
 167 0000 70B5     		push	{r4, r5, r6, lr}
 168              	.LCFI4:
 169              		.cfi_def_cfa_offset 16
 170              		.cfi_offset 4, -16
 171              		.cfi_offset 5, -12
 172              		.cfi_offset 6, -8
 173              		.cfi_offset 14, -4
 174 0002 8AB0     		sub	sp, sp, #40
 175              	.LCFI5:
 176              		.cfi_def_cfa_offset 56
 177              	.LBB12:
 555:Src/main.c    **** 	__HAL_RCC_TIM2_CLK_ENABLE();
 178              		.loc 1 555 0
 179 0004 194B     		ldr	r3, .L8
 180 0006 DA69     		ldr	r2, [r3, #28]
 181 0008 0126     		mov	r6, #1
 182 000a 3243     		orr	r2, r6
 183 000c DA61     		str	r2, [r3, #28]
 184 000e DB69     		ldr	r3, [r3, #28]
 185 0010 3340     		and	r3, r6
 186 0012 0093     		str	r3, [sp]
 187 0014 009B     		ldr	r3, [sp]
 188              	.LBE12:
 561:Src/main.c    **** 	htim2.Instance = TIM2;
 189              		.loc 1 561 0
 190 0016 164C     		ldr	r4, .L8+4
 191 0018 8023     		mov	r3, #128
 192 001a DB05     		lsl	r3, r3, #23
 193 001c 2360     		str	r3, [r4]
 562:Src/main.c    **** 	htim2.Init.Prescaler = 0;
 194              		.loc 1 562 0
 195 001e 0025     		mov	r5, #0
 196 0020 6560     		str	r5, [r4, #4]
 563:Src/main.c    **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 197              		.loc 1 563 0
 198 0022 A560     		str	r5, [r4, #8]
 564:Src/main.c    **** 	htim2.Init.Period = 3200;
 199              		.loc 1 564 0
 200 0024 C823     		mov	r3, #200
 201 0026 1B01     		lsl	r3, r3, #4
 202 0028 E360     		str	r3, [r4, #12]
 565:Src/main.c    **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 203              		.loc 1 565 0
 204 002a 8023     		mov	r3, #128
 205 002c 9B00     		lsl	r3, r3, #2
 206 002e 2361     		str	r3, [r4, #16]
 566:Src/main.c    **** 	HAL_TIM_Base_Init(&htim2);
 207              		.loc 1 566 0
 208 0030 201C     		mov	r0, r4
 209 0032 FFF7FEFF 		bl	HAL_TIM_Base_Init
ARM GAS  /tmp/ccelT0ZE.s 			page 17


 210              	.LVL4:
 568:Src/main.c    **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 211              		.loc 1 568 0
 212 0036 0895     		str	r5, [sp, #32]
 569:Src/main.c    **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 213              		.loc 1 569 0
 214 0038 0995     		str	r5, [sp, #36]
 570:Src/main.c    **** 	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 215              		.loc 1 570 0
 216 003a 201C     		mov	r0, r4
 217 003c 08A9     		add	r1, sp, #32
 218 003e FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 219              	.LVL5:
 572:Src/main.c    **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 220              		.loc 1 572 0
 221 0042 6023     		mov	r3, #96
 222 0044 0193     		str	r3, [sp, #4]
 573:Src/main.c    **** 	sConfigOC.Pulse = 1;
 223              		.loc 1 573 0
 224 0046 0296     		str	r6, [sp, #8]
 574:Src/main.c    **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
 225              		.loc 1 574 0
 226 0048 0223     		mov	r3, #2
 227 004a 0393     		str	r3, [sp, #12]
 575:Src/main.c    **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 228              		.loc 1 575 0
 229 004c 0595     		str	r5, [sp, #20]
 576:Src/main.c    **** 	HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
 230              		.loc 1 576 0
 231 004e 201C     		mov	r0, r4
 232 0050 01A9     		add	r1, sp, #4
 233 0052 0422     		mov	r2, #4
 234 0054 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 235              	.LVL6:
 578:Src/main.c    **** 	HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
 236              		.loc 1 578 0
 237 0058 201C     		mov	r0, r4
 238 005a 0821     		mov	r1, #8
 239 005c FFF7FEFF 		bl	HAL_TIM_OnePulse_Init
 240              	.LVL7:
 579:Src/main.c    **** 	HAL_TIM_MspPostInit(&htim2);
 241              		.loc 1 579 0
 242 0060 201C     		mov	r0, r4
 243 0062 FFF7FEFF 		bl	HAL_TIM_MspPostInit
 244              	.LVL8:
 580:Src/main.c    **** }
 245              		.loc 1 580 0
 246 0066 0AB0     		add	sp, sp, #40
 247              		@ sp needed
 248 0068 70BD     		pop	{r4, r5, r6, pc}
 249              	.L9:
 250 006a C046     		.align	2
 251              	.L8:
 252 006c 00100240 		.word	1073876992
 253 0070 00000000 		.word	htim2
 254              		.cfi_endproc
 255              	.LFE44:
ARM GAS  /tmp/ccelT0ZE.s 			page 18


 257              		.global	__aeabi_i2f
 258              		.global	__aeabi_fmul
 259              		.global	__aeabi_f2uiz
 260              		.global	__aeabi_idiv
 261              		.section	.text.htim17_update,"ax",%progbits
 262              		.align	2
 263              		.global	htim17_update
 264              		.code	16
 265              		.thumb_func
 267              	htim17_update:
 268              	.LFB34:
 106:Src/main.c    **** void htim17_update() {
 269              		.loc 1 106 0
 270              		.cfi_startproc
 271 0000 10B5     		push	{r4, lr}
 272              	.LCFI6:
 273              		.cfi_def_cfa_offset 8
 274              		.cfi_offset 4, -8
 275              		.cfi_offset 14, -4
 107:Src/main.c    ****   Iout = adcBuffer[0] * 1.33f;
 276              		.loc 1 107 0
 277 0002 174C     		ldr	r4, .L16
 278 0004 2088     		ldrh	r0, [r4]
 279 0006 FFF7FEFF 		bl	__aeabi_i2f
 280              	.LVL9:
 281 000a 1649     		ldr	r1, .L16+4
 282 000c FFF7FEFF 		bl	__aeabi_fmul
 283              	.LVL10:
 284 0010 FFF7FEFF 		bl	__aeabi_f2uiz
 285              	.LVL11:
 286 0014 144B     		ldr	r3, .L16+8
 287 0016 1880     		strh	r0, [r3]
 108:Src/main.c    ****   Vout = adcBuffer[1] * 16.6f;
 288              		.loc 1 108 0
 289 0018 6088     		ldrh	r0, [r4, #2]
 290 001a FFF7FEFF 		bl	__aeabi_i2f
 291              	.LVL12:
 292 001e 1349     		ldr	r1, .L16+12
 293 0020 FFF7FEFF 		bl	__aeabi_fmul
 294              	.LVL13:
 295 0024 FFF7FEFF 		bl	__aeabi_f2uiz
 296              	.LVL14:
 297 0028 041C     		mov	r4, r0
 298 002a 114B     		ldr	r3, .L16+16
 299 002c 1860     		str	r0, [r3]
 109:Src/main.c    ****   int32_t error = Vset - Vout;
 300              		.loc 1 109 0
 301 002e 114B     		ldr	r3, .L16+20
 302 0030 1868     		ldr	r0, [r3]
 303 0032 001B     		sub	r0, r0, r4
 304              	.LVL15:
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 305              		.loc 1 111 0
 306 0034 104B     		ldr	r3, .L16+24
 307 0036 9842     		cmp	r0, r3
 308 0038 07DC     		bgt	.L14
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
ARM GAS  /tmp/ccelT0ZE.s 			page 19


 309              		.loc 1 111 0 is_stmt 0 discriminator 1
 310 003a 831C     		add	r3, r0, #2
 311 003c 03DB     		blt	.L15
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 312              		.loc 1 111 0 discriminator 3
 313 003e 0321     		mov	r1, #3
 314 0040 FFF7FEFF 		bl	__aeabi_idiv
 315              	.LVL16:
 316 0044 03E0     		b	.L11
 317              	.LVL17:
 318              	.L15:
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 319              		.loc 1 111 0
 320 0046 0020     		mov	r0, #0
 321              	.LVL18:
 322 0048 01E0     		b	.L11
 323              	.LVL19:
 324              	.L14:
 325 004a FA20     		mov	r0, #250
 326              	.LVL20:
 327 004c 4000     		lsl	r0, r0, #1
 328              	.LVL21:
 329              	.L11:
 111:Src/main.c    ****   TIM1->CCR1 = CLAMP(error / 3, 0, 500);
 330              		.loc 1 111 0 discriminator 5
 331 004e 0B4B     		ldr	r3, .L16+28
 332 0050 5863     		str	r0, [r3, #52]
 113:Src/main.c    ****   if (Vout > 55000) {
 333              		.loc 1 113 0 is_stmt 1 discriminator 5
 334 0052 0B4B     		ldr	r3, .L16+32
 335 0054 9C42     		cmp	r4, r3
 336 0056 02D9     		bls	.L10
 114:Src/main.c    ****     TIM1->CCR1 = 0;
 337              		.loc 1 114 0
 338 0058 0022     		mov	r2, #0
 339 005a 084B     		ldr	r3, .L16+28
 340 005c 5A63     		str	r2, [r3, #52]
 341              	.L10:
 116:Src/main.c    **** }
 342              		.loc 1 116 0
 343              		@ sp needed
 344 005e 10BD     		pop	{r4, pc}
 345              	.L17:
 346              		.align	2
 347              	.L16:
 348 0060 00000000 		.word	adcBuffer
 349 0064 713DAA3F 		.word	1068121457
 350 0068 00000000 		.word	.LANCHOR0
 351 006c CDCC8441 		.word	1099222221
 352 0070 00000000 		.word	.LANCHOR1
 353 0074 00000000 		.word	.LANCHOR2
 354 0078 DE050000 		.word	1502
 355 007c 002C0140 		.word	1073818624
 356 0080 D8D60000 		.word	55000
 357              		.cfi_endproc
 358              	.LFE34:
 360              		.section	.text.dfu_otter_bootloader,"ax",%progbits
ARM GAS  /tmp/ccelT0ZE.s 			page 20


 361              		.align	2
 362              		.global	dfu_otter_bootloader
 363              		.code	16
 364              		.thumb_func
 366              	dfu_otter_bootloader:
 367              	.LFB35:
 121:Src/main.c    **** {
 368              		.loc 1 121 0
 369              		.cfi_startproc
 122:Src/main.c    ****   *((unsigned long *)0x20003FF0) = 0xDEADBEEF;
 370              		.loc 1 122 0
 371 0000 054A     		ldr	r2, .L20
 372 0002 064B     		ldr	r3, .L20+4
 373 0004 1A60     		str	r2, [r3]
 374              	.LBB21:
 375              	.LBB22:
 376              	.LBB23:
 377              	.LBB24:
 378              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/cmsis_gcc.h **** 
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****      specific prior written permission.
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****    *
  21:Drivers/CMSIS/Include/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:Drivers/CMSIS/Include/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
ARM GAS  /tmp/ccelT0ZE.s 			page 21


  39:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  47:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
  51:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  53:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  54:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  60:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  62:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:Drivers/CMSIS/Include/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  73:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  74:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  75:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
  77:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
  78:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  80:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
  83:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  87:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  88:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  89:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:Drivers/CMSIS/Include/cmsis_gcc.h **** {
ARM GAS  /tmp/ccelT0ZE.s 			page 22


  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  98:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  99:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 100:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 101:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 105:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 109:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 114:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 115:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 116:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 118:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 123:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 125:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 126:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 127:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 128:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 132:Drivers/CMSIS/Include/cmsis_gcc.h ****     \return               xPSR Register value
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
 135:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 137:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 142:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 148:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
ARM GAS  /tmp/ccelT0ZE.s 			page 23


 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 155:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 156:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 162:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 169:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 172:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 175:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 192:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
ARM GAS  /tmp/ccelT0ZE.s 			page 24


 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 217:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 218:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 221:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 222:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 228:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 230:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 231:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 232:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 233:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 234:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 237:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 239:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 243:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 247:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
 249:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 250:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 251:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 266:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccelT0ZE.s 			page 25


 267:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 269:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 274:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 279:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 281:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 284:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 285:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 288:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 289:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 291:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 295:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 299:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 301:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 303:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 306:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 310:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 311:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 314:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 318:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 319:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 323:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
ARM GAS  /tmp/ccelT0ZE.s 			page 26


 324:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 325:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(0);
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 327:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 328:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 329:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 330:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 331:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 332:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 342:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 345:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 352:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 358:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 363:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 368:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 369:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 370:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 371:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 378:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 379:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
ARM GAS  /tmp/ccelT0ZE.s 			page 27


 381:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 385:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfi");
 386:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 387:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 390:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 391:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:Drivers/CMSIS/Include/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 394:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 399:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 406:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("sev");
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 408:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 409:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 410:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 412:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 413:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 415:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 418:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 420:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 421:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 422:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 424:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 425:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 429:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 379              		.loc 2 429 0
 380              	@ 429 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 381 0006 BFF34F8F 		dsb 0xF
 382              	@ 0 "" 2
 383              		.code	16
 384              	.LBE24:
 385              	.LBE23:
 386              		.file 3 "Drivers/CMSIS/Include/core_cm0.h"
ARM GAS  /tmp/ccelT0ZE.s 			page 28


   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/core_cm0.h **** 
   9:Drivers/CMSIS/Include/core_cm0.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/core_cm0.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/core_cm0.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/core_cm0.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/core_cm0.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/core_cm0.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/core_cm0.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/core_cm0.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/core_cm0.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/core_cm0.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/core_cm0.h ****      specific prior written permission.
  20:Drivers/CMSIS/Include/core_cm0.h ****    *
  21:Drivers/CMSIS/Include/core_cm0.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/core_cm0.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/core_cm0.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/core_cm0.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/core_cm0.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/core_cm0.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/core_cm0.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/core_cm0.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/core_cm0.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/core_cm0.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/core_cm0.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:Drivers/CMSIS/Include/core_cm0.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** 
  35:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  36:Drivers/CMSIS/Include/core_cm0.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  37:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  38:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  39:Drivers/CMSIS/Include/core_cm0.h **** #endif
  40:Drivers/CMSIS/Include/core_cm0.h **** 
  41:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  42:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  45:Drivers/CMSIS/Include/core_cm0.h **** 
  46:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  47:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  48:Drivers/CMSIS/Include/core_cm0.h **** #endif
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h **** /**
  51:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  52:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  55:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  56:Drivers/CMSIS/Include/core_cm0.h **** 
  57:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
ARM GAS  /tmp/ccelT0ZE.s 			page 29


  58:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  59:Drivers/CMSIS/Include/core_cm0.h **** 
  60:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  61:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  62:Drivers/CMSIS/Include/core_cm0.h ****  */
  63:Drivers/CMSIS/Include/core_cm0.h **** 
  64:Drivers/CMSIS/Include/core_cm0.h **** 
  65:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  66:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  67:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  68:Drivers/CMSIS/Include/core_cm0.h **** /**
  69:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  70:Drivers/CMSIS/Include/core_cm0.h ****   @{
  71:Drivers/CMSIS/Include/core_cm0.h ****  */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  74:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS H
  75:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS H
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  77:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL versi
  78:Drivers/CMSIS/Include/core_cm0.h **** 
  79:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core *
  80:Drivers/CMSIS/Include/core_cm0.h **** 
  81:Drivers/CMSIS/Include/core_cm0.h **** 
  82:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __CC_ARM )
  83:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  84:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  85:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static __inline
  86:Drivers/CMSIS/Include/core_cm0.h **** 
  87:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  88:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  89:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  90:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static __inline
  91:Drivers/CMSIS/Include/core_cm0.h **** 
  92:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  93:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  94:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  95:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
  96:Drivers/CMSIS/Include/core_cm0.h **** 
  97:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  98:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  99:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
 100:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 101:Drivers/CMSIS/Include/core_cm0.h **** 
 102:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TMS470__ )
 103:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
 104:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 105:Drivers/CMSIS/Include/core_cm0.h **** 
 106:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 107:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 108:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 109:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 110:Drivers/CMSIS/Include/core_cm0.h **** 
 111:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 112:Drivers/CMSIS/Include/core_cm0.h ****   #define __packed
 113:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 114:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                    /*!< inline keyword for COSMIC
ARM GAS  /tmp/ccelT0ZE.s 			page 30


 115:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** #else
 118:Drivers/CMSIS/Include/core_cm0.h ****   #error Unknown compiler
 119:Drivers/CMSIS/Include/core_cm0.h **** #endif
 120:Drivers/CMSIS/Include/core_cm0.h **** 
 121:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
 122:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
 123:Drivers/CMSIS/Include/core_cm0.h **** */
 124:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
 127:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
 128:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 129:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 130:Drivers/CMSIS/Include/core_cm0.h **** 
 131:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
 132:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
 133:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 134:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 135:Drivers/CMSIS/Include/core_cm0.h **** 
 136:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
 137:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 138:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 139:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 140:Drivers/CMSIS/Include/core_cm0.h **** 
 141:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
 142:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
 143:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 144:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 145:Drivers/CMSIS/Include/core_cm0.h **** 
 146:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TMS470__ )
 147:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 148:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 149:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 152:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 153:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 154:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 155:Drivers/CMSIS/Include/core_cm0.h **** 
 156:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 157:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 158:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 159:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 160:Drivers/CMSIS/Include/core_cm0.h **** 
 161:Drivers/CMSIS/Include/core_cm0.h **** #endif
 162:Drivers/CMSIS/Include/core_cm0.h **** 
 163:Drivers/CMSIS/Include/core_cm0.h **** #include "core_cmInstr.h"                /* Core Instruction Access */
 164:Drivers/CMSIS/Include/core_cm0.h **** #include "core_cmFunc.h"                 /* Core Function Access */
 165:Drivers/CMSIS/Include/core_cm0.h **** 
 166:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 167:Drivers/CMSIS/Include/core_cm0.h **** }
 168:Drivers/CMSIS/Include/core_cm0.h **** #endif
 169:Drivers/CMSIS/Include/core_cm0.h **** 
 170:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/ccelT0ZE.s 			page 31


 172:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 175:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 176:Drivers/CMSIS/Include/core_cm0.h **** 
 177:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 178:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 179:Drivers/CMSIS/Include/core_cm0.h **** #endif
 180:Drivers/CMSIS/Include/core_cm0.h **** 
 181:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 182:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 183:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 184:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 185:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 186:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 187:Drivers/CMSIS/Include/core_cm0.h **** 
 188:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 189:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 190:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 191:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 192:Drivers/CMSIS/Include/core_cm0.h **** 
 193:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 194:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 195:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 196:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 197:Drivers/CMSIS/Include/core_cm0.h **** #endif
 198:Drivers/CMSIS/Include/core_cm0.h **** 
 199:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 200:Drivers/CMSIS/Include/core_cm0.h **** /**
 201:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 202:Drivers/CMSIS/Include/core_cm0.h **** 
 203:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 204:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 205:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 206:Drivers/CMSIS/Include/core_cm0.h **** */
 207:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 208:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 209:Drivers/CMSIS/Include/core_cm0.h **** #else
 210:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 211:Drivers/CMSIS/Include/core_cm0.h **** #endif
 212:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 214:Drivers/CMSIS/Include/core_cm0.h **** 
 215:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 216:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 217:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 218:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 219:Drivers/CMSIS/Include/core_cm0.h **** 
 220:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** 
 223:Drivers/CMSIS/Include/core_cm0.h **** 
 224:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 225:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 226:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 227:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 228:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
ARM GAS  /tmp/ccelT0ZE.s 			page 32


 229:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 230:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 231:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 232:Drivers/CMSIS/Include/core_cm0.h **** /**
 233:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 234:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 235:Drivers/CMSIS/Include/core_cm0.h **** */
 236:Drivers/CMSIS/Include/core_cm0.h **** 
 237:Drivers/CMSIS/Include/core_cm0.h **** /**
 238:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 239:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 240:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 241:Drivers/CMSIS/Include/core_cm0.h ****   @{
 242:Drivers/CMSIS/Include/core_cm0.h ****  */
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 257:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 258:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 259:Drivers/CMSIS/Include/core_cm0.h **** 
 260:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 261:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 262:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 263:Drivers/CMSIS/Include/core_cm0.h **** 
 264:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 268:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** 
 274:Drivers/CMSIS/Include/core_cm0.h **** /**
 275:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 276:Drivers/CMSIS/Include/core_cm0.h ****  */
 277:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 278:Drivers/CMSIS/Include/core_cm0.h **** {
 279:Drivers/CMSIS/Include/core_cm0.h ****   struct
 280:Drivers/CMSIS/Include/core_cm0.h ****   {
 281:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 282:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 283:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 284:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 285:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
ARM GAS  /tmp/ccelT0ZE.s 			page 33


 286:Drivers/CMSIS/Include/core_cm0.h **** 
 287:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 288:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 289:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 290:Drivers/CMSIS/Include/core_cm0.h **** 
 291:Drivers/CMSIS/Include/core_cm0.h **** 
 292:Drivers/CMSIS/Include/core_cm0.h **** /**
 293:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 294:Drivers/CMSIS/Include/core_cm0.h ****  */
 295:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 296:Drivers/CMSIS/Include/core_cm0.h **** {
 297:Drivers/CMSIS/Include/core_cm0.h ****   struct
 298:Drivers/CMSIS/Include/core_cm0.h ****   {
 299:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 300:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 301:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 302:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 303:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 304:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 305:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 306:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 307:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 308:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 309:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 312:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 313:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 314:Drivers/CMSIS/Include/core_cm0.h **** 
 315:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 316:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 317:Drivers/CMSIS/Include/core_cm0.h **** 
 318:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 319:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 320:Drivers/CMSIS/Include/core_cm0.h **** 
 321:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 322:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 323:Drivers/CMSIS/Include/core_cm0.h **** 
 324:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 325:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 326:Drivers/CMSIS/Include/core_cm0.h **** 
 327:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 328:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 333:Drivers/CMSIS/Include/core_cm0.h ****  */
 334:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 335:Drivers/CMSIS/Include/core_cm0.h **** {
 336:Drivers/CMSIS/Include/core_cm0.h ****   struct
 337:Drivers/CMSIS/Include/core_cm0.h ****   {
 338:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 339:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 340:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 341:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 342:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
ARM GAS  /tmp/ccelT0ZE.s 			page 34


 343:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 344:Drivers/CMSIS/Include/core_cm0.h **** 
 345:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 346:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 347:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 348:Drivers/CMSIS/Include/core_cm0.h **** 
 349:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 350:Drivers/CMSIS/Include/core_cm0.h **** 
 351:Drivers/CMSIS/Include/core_cm0.h **** 
 352:Drivers/CMSIS/Include/core_cm0.h **** /**
 353:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 354:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 355:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 356:Drivers/CMSIS/Include/core_cm0.h ****   @{
 357:Drivers/CMSIS/Include/core_cm0.h ****  */
 358:Drivers/CMSIS/Include/core_cm0.h **** 
 359:Drivers/CMSIS/Include/core_cm0.h **** /**
 360:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 361:Drivers/CMSIS/Include/core_cm0.h ****  */
 362:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 363:Drivers/CMSIS/Include/core_cm0.h **** {
 364:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 365:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 366:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 367:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 368:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 369:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 370:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 371:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 372:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 373:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 374:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 375:Drivers/CMSIS/Include/core_cm0.h **** 
 376:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 377:Drivers/CMSIS/Include/core_cm0.h **** 
 378:Drivers/CMSIS/Include/core_cm0.h **** 
 379:Drivers/CMSIS/Include/core_cm0.h **** /**
 380:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 381:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 382:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 383:Drivers/CMSIS/Include/core_cm0.h ****   @{
 384:Drivers/CMSIS/Include/core_cm0.h ****  */
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** /**
 387:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 388:Drivers/CMSIS/Include/core_cm0.h ****  */
 389:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 390:Drivers/CMSIS/Include/core_cm0.h **** {
 391:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 392:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 393:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 394:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 395:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 396:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 397:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 398:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 399:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
ARM GAS  /tmp/ccelT0ZE.s 			page 35


 400:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 405:Drivers/CMSIS/Include/core_cm0.h **** 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 408:Drivers/CMSIS/Include/core_cm0.h **** 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 411:Drivers/CMSIS/Include/core_cm0.h **** 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 414:Drivers/CMSIS/Include/core_cm0.h **** 
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 421:Drivers/CMSIS/Include/core_cm0.h **** 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 424:Drivers/CMSIS/Include/core_cm0.h **** 
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** 
 434:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 435:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 438:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 439:Drivers/CMSIS/Include/core_cm0.h **** 
 440:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 441:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 442:Drivers/CMSIS/Include/core_cm0.h **** 
 443:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 444:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 445:Drivers/CMSIS/Include/core_cm0.h **** 
 446:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 447:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 448:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 449:Drivers/CMSIS/Include/core_cm0.h **** 
 450:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 451:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 452:Drivers/CMSIS/Include/core_cm0.h **** 
 453:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 454:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
ARM GAS  /tmp/ccelT0ZE.s 			page 36


 457:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 458:Drivers/CMSIS/Include/core_cm0.h **** 
 459:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 461:Drivers/CMSIS/Include/core_cm0.h **** 
 462:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 471:Drivers/CMSIS/Include/core_cm0.h **** 
 472:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 473:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 475:Drivers/CMSIS/Include/core_cm0.h **** 
 476:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 477:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 478:Drivers/CMSIS/Include/core_cm0.h **** 
 479:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 480:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 482:Drivers/CMSIS/Include/core_cm0.h **** 
 483:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 484:Drivers/CMSIS/Include/core_cm0.h **** 
 485:Drivers/CMSIS/Include/core_cm0.h **** 
 486:Drivers/CMSIS/Include/core_cm0.h **** /**
 487:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 488:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 489:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 490:Drivers/CMSIS/Include/core_cm0.h ****   @{
 491:Drivers/CMSIS/Include/core_cm0.h ****  */
 492:Drivers/CMSIS/Include/core_cm0.h **** 
 493:Drivers/CMSIS/Include/core_cm0.h **** /**
 494:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 495:Drivers/CMSIS/Include/core_cm0.h ****  */
 496:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 497:Drivers/CMSIS/Include/core_cm0.h **** {
 498:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 499:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 500:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 501:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 502:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 503:Drivers/CMSIS/Include/core_cm0.h **** 
 504:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 505:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 506:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 507:Drivers/CMSIS/Include/core_cm0.h **** 
 508:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 509:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 510:Drivers/CMSIS/Include/core_cm0.h **** 
 511:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 512:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 513:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/ccelT0ZE.s 			page 37


 514:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 515:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 516:Drivers/CMSIS/Include/core_cm0.h **** 
 517:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 518:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 519:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 520:Drivers/CMSIS/Include/core_cm0.h **** 
 521:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 522:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 523:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 526:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 527:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 528:Drivers/CMSIS/Include/core_cm0.h **** 
 529:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 530:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 531:Drivers/CMSIS/Include/core_cm0.h **** 
 532:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 533:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 534:Drivers/CMSIS/Include/core_cm0.h **** 
 535:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 536:Drivers/CMSIS/Include/core_cm0.h **** 
 537:Drivers/CMSIS/Include/core_cm0.h **** 
 538:Drivers/CMSIS/Include/core_cm0.h **** /**
 539:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 540:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 541:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 542:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 543:Drivers/CMSIS/Include/core_cm0.h ****   @{
 544:Drivers/CMSIS/Include/core_cm0.h ****  */
 545:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /**
 549:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 550:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 551:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 552:Drivers/CMSIS/Include/core_cm0.h ****   @{
 553:Drivers/CMSIS/Include/core_cm0.h ****  */
 554:Drivers/CMSIS/Include/core_cm0.h **** 
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 557:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 558:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field.
 559:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 560:Drivers/CMSIS/Include/core_cm0.h **** */
 561:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
 562:Drivers/CMSIS/Include/core_cm0.h **** 
 563:Drivers/CMSIS/Include/core_cm0.h **** /**
 564:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 565:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 566:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register.
 567:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 568:Drivers/CMSIS/Include/core_cm0.h **** */
 569:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
 570:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/ccelT0ZE.s 			page 38


 571:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 572:Drivers/CMSIS/Include/core_cm0.h **** 
 573:Drivers/CMSIS/Include/core_cm0.h **** 
 574:Drivers/CMSIS/Include/core_cm0.h **** /**
 575:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 576:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 577:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 578:Drivers/CMSIS/Include/core_cm0.h ****   @{
 579:Drivers/CMSIS/Include/core_cm0.h ****  */
 580:Drivers/CMSIS/Include/core_cm0.h **** 
 581:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Cortex-M0 Hardware */
 582:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 583:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 584:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 585:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 586:Drivers/CMSIS/Include/core_cm0.h **** 
 587:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 588:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 589:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 590:Drivers/CMSIS/Include/core_cm0.h **** 
 591:Drivers/CMSIS/Include/core_cm0.h **** 
 592:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 593:Drivers/CMSIS/Include/core_cm0.h **** 
 594:Drivers/CMSIS/Include/core_cm0.h **** 
 595:Drivers/CMSIS/Include/core_cm0.h **** 
 596:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 597:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 598:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 599:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 600:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 601:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 602:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 603:Drivers/CMSIS/Include/core_cm0.h **** /**
 604:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 605:Drivers/CMSIS/Include/core_cm0.h **** */
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** 
 609:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 610:Drivers/CMSIS/Include/core_cm0.h **** /**
 611:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 612:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 613:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 614:Drivers/CMSIS/Include/core_cm0.h ****   @{
 615:Drivers/CMSIS/Include/core_cm0.h ****  */
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 618:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 619:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 620:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 621:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 622:Drivers/CMSIS/Include/core_cm0.h **** 
 623:Drivers/CMSIS/Include/core_cm0.h **** 
 624:Drivers/CMSIS/Include/core_cm0.h **** /**
 625:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable External Interrupt
 626:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device-specific interrupt in the NVIC interrupt controller.
 627:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
ARM GAS  /tmp/ccelT0ZE.s 			page 39


 628:Drivers/CMSIS/Include/core_cm0.h ****  */
 629:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 630:Drivers/CMSIS/Include/core_cm0.h **** {
 631:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 632:Drivers/CMSIS/Include/core_cm0.h **** }
 633:Drivers/CMSIS/Include/core_cm0.h **** 
 634:Drivers/CMSIS/Include/core_cm0.h **** 
 635:Drivers/CMSIS/Include/core_cm0.h **** /**
 636:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable External Interrupt
 637:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device-specific interrupt in the NVIC interrupt controller.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 643:Drivers/CMSIS/Include/core_cm0.h **** }
 644:Drivers/CMSIS/Include/core_cm0.h **** 
 645:Drivers/CMSIS/Include/core_cm0.h **** 
 646:Drivers/CMSIS/Include/core_cm0.h **** /**
 647:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 648:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the pending register in the NVIC and returns the pending bit for the specified int
 649:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 650:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 651:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 652:Drivers/CMSIS/Include/core_cm0.h ****  */
 653:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
 654:Drivers/CMSIS/Include/core_cm0.h **** {
 655:Drivers/CMSIS/Include/core_cm0.h ****   return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL
 656:Drivers/CMSIS/Include/core_cm0.h **** }
 657:Drivers/CMSIS/Include/core_cm0.h **** 
 658:Drivers/CMSIS/Include/core_cm0.h **** 
 659:Drivers/CMSIS/Include/core_cm0.h **** /**
 660:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 661:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of an external interrupt.
 662:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number. Value cannot be negative.
 663:Drivers/CMSIS/Include/core_cm0.h ****  */
 664:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
 665:Drivers/CMSIS/Include/core_cm0.h **** {
 666:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of an external interrupt.
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 674:Drivers/CMSIS/Include/core_cm0.h ****  */
 675:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 676:Drivers/CMSIS/Include/core_cm0.h **** {
 677:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 678:Drivers/CMSIS/Include/core_cm0.h **** }
 679:Drivers/CMSIS/Include/core_cm0.h **** 
 680:Drivers/CMSIS/Include/core_cm0.h **** 
 681:Drivers/CMSIS/Include/core_cm0.h **** /**
 682:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 683:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of an interrupt.
 684:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every core interrupt.
ARM GAS  /tmp/ccelT0ZE.s 			page 40


 685:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 686:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 687:Drivers/CMSIS/Include/core_cm0.h ****  */
 688:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 689:Drivers/CMSIS/Include/core_cm0.h **** {
 690:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 691:Drivers/CMSIS/Include/core_cm0.h ****   {
 692:Drivers/CMSIS/Include/core_cm0.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 693:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 694:Drivers/CMSIS/Include/core_cm0.h ****   }
 695:Drivers/CMSIS/Include/core_cm0.h ****   else
 696:Drivers/CMSIS/Include/core_cm0.h ****   {
 697:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 698:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 699:Drivers/CMSIS/Include/core_cm0.h ****   }
 700:Drivers/CMSIS/Include/core_cm0.h **** }
 701:Drivers/CMSIS/Include/core_cm0.h **** 
 702:Drivers/CMSIS/Include/core_cm0.h **** 
 703:Drivers/CMSIS/Include/core_cm0.h **** /**
 704:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Priority
 705:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the priority of an interrupt.
 706:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify an external (device specific) interrupt,
 707:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify an internal (core) interrupt.
 708:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   IRQn  Interrupt number.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \return             Interrupt Priority.
 710:Drivers/CMSIS/Include/core_cm0.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h **** 
 715:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 716:Drivers/CMSIS/Include/core_cm0.h ****   {
 717:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 718:Drivers/CMSIS/Include/core_cm0.h ****   }
 719:Drivers/CMSIS/Include/core_cm0.h ****   else
 720:Drivers/CMSIS/Include/core_cm0.h ****   {
 721:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 722:Drivers/CMSIS/Include/core_cm0.h ****   }
 723:Drivers/CMSIS/Include/core_cm0.h **** }
 724:Drivers/CMSIS/Include/core_cm0.h **** 
 725:Drivers/CMSIS/Include/core_cm0.h **** 
 726:Drivers/CMSIS/Include/core_cm0.h **** /**
 727:Drivers/CMSIS/Include/core_cm0.h ****   \brief   System Reset
 728:Drivers/CMSIS/Include/core_cm0.h ****   \details Initiates a system reset request to reset the MCU.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SystemReset(void)
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   __DSB();                                                          /* Ensure all outstanding memor
 733:Drivers/CMSIS/Include/core_cm0.h ****                                                                        buffered write are completed
 734:Drivers/CMSIS/Include/core_cm0.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 387              		.loc 3 734 0
 388 000a 054A     		ldr	r2, .L20+8
 389 000c 054B     		ldr	r3, .L20+12
 390 000e DA60     		str	r2, [r3, #12]
 391              	.LBB25:
 392              	.LBB26:
 393              		.loc 2 429 0
ARM GAS  /tmp/ccelT0ZE.s 			page 41


 394              	@ 429 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 395 0010 BFF34F8F 		dsb 0xF
 396              	@ 0 "" 2
 397              		.code	16
 398              	.L19:
 399              	.LBE26:
 400              	.LBE25:
 401              	.LBB27:
 402              	.LBB28:
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 403              		.loc 2 375 0
 404              	@ 375 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 405 0014 C046     		nop
 406              	@ 0 "" 2
 407              		.code	16
 408 0016 FDE7     		b	.L19
 409              	.L21:
 410              		.align	2
 411              	.L20:
 412 0018 EFBEADDE 		.word	-559038737
 413 001c F03F0020 		.word	536887280
 414 0020 0400FA05 		.word	100270084
 415 0024 00ED00E0 		.word	-536810240
 416              	.LBE28:
 417              	.LBE27:
 418              	.LBE22:
 419              	.LBE21:
 420              		.cfi_endproc
 421              	.LFE35:
 423              		.global	__aeabi_uidiv
 424              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 425              		.align	2
 426              		.global	HAL_TIM_PeriodElapsedCallback
 427              		.code	16
 428              		.thumb_func
 430              	HAL_TIM_PeriodElapsedCallback:
 431              	.LFB36:
 133:Src/main.c    **** {
 432              		.loc 1 133 0
 433              		.cfi_startproc
 434              	.LVL22:
 435 0000 38B5     		push	{r3, r4, r5, lr}
 436              	.LCFI7:
 437              		.cfi_def_cfa_offset 16
 438              		.cfi_offset 3, -16
 439              		.cfi_offset 4, -12
 440              		.cfi_offset 5, -8
 441              		.cfi_offset 14, -4
 442 0002 041C     		mov	r4, r0
 134:Src/main.c    **** 	if(htim->Instance == TIM14)
 443              		.loc 1 134 0
 444 0004 1B4B     		ldr	r3, .L28
 445 0006 0268     		ldr	r2, [r0]
 446 0008 9A42     		cmp	r2, r3
 447 000a 1ED1     		bne	.L23
 137:Src/main.c    ****     if (TIM2->CNT == 0) {
 448              		.loc 1 137 0
ARM GAS  /tmp/ccelT0ZE.s 			page 42


 449 000c 8023     		mov	r3, #128
 450 000e DB05     		lsl	r3, r3, #23
 451 0010 5B6A     		ldr	r3, [r3, #36]
 452 0012 002B     		cmp	r3, #0
 453 0014 19D1     		bne	.L23
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 454              		.loc 1 138 0
 455 0016 184B     		ldr	r3, .L28+4
 456 0018 1D68     		ldr	r5, [r3]
 457 001a 184B     		ldr	r3, .L28+8
 458 001c 1888     		ldrh	r0, [r3]
 459              	.LVL23:
 460 001e C821     		mov	r1, #200
 461 0020 FFF7FEFF 		bl	__aeabi_uidiv
 462              	.LVL24:
 463 0024 81B2     		uxth	r1, r0
 464 0026 0A39     		sub	r1, r1, #10
 465 0028 1029     		cmp	r1, #16
 466 002a 03DC     		bgt	.L27
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 467              		.loc 1 138 0 is_stmt 0 discriminator 1
 468 002c 0329     		cmp	r1, #3
 469 002e 02DA     		bge	.L24
 470 0030 0321     		mov	r1, #3
 471 0032 00E0     		b	.L24
 472              	.L27:
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 473              		.loc 1 138 0
 474 0034 1021     		mov	r1, #16
 475              	.L24:
 138:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / CLAMP(((Iout/200)-10), 3, 16)); // Play first channel
 476              		.loc 1 138 0 discriminator 3
 477 0036 281C     		mov	r0, r5
 478 0038 FFF7FEFF 		bl	__aeabi_uidiv
 479              	.LVL25:
 480 003c 8023     		mov	r3, #128
 481 003e DB05     		lsl	r3, r3, #23
 482 0040 D862     		str	r0, [r3, #44]
 139:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 483              		.loc 1 139 0 is_stmt 1 discriminator 3
 484 0042 1968     		ldr	r1, [r3]
 485 0044 0122     		mov	r2, #1
 486 0046 0A43     		orr	r2, r1
 487 0048 1A60     		str	r2, [r3]
 488              	.L23:
 142:Src/main.c    **** 	if(htim->Instance == TIM15)
 489              		.loc 1 142 0
 490 004a 2268     		ldr	r2, [r4]
 491 004c 0C4B     		ldr	r3, .L28+12
 492 004e 9A42     		cmp	r2, r3
 493 0050 0ED1     		bne	.L22
 145:Src/main.c    ****     if (TIM2->CNT == 0) {
 494              		.loc 1 145 0
 495 0052 8023     		mov	r3, #128
 496 0054 DB05     		lsl	r3, r3, #23
 497 0056 5B6A     		ldr	r3, [r3, #36]
 498 0058 002B     		cmp	r3, #0
ARM GAS  /tmp/ccelT0ZE.s 			page 43


 499 005a 09D1     		bne	.L22
 146:Src/main.c    ****     	TIM2->ARR = (uint32_t)(curPeriode1 / 8); // Play second channel with less power
 500              		.loc 1 146 0
 501 005c 094B     		ldr	r3, .L28+16
 502 005e 1A68     		ldr	r2, [r3]
 503 0060 D208     		lsr	r2, r2, #3
 504 0062 8023     		mov	r3, #128
 505 0064 DB05     		lsl	r3, r3, #23
 506 0066 DA62     		str	r2, [r3, #44]
 147:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 507              		.loc 1 147 0
 508 0068 1968     		ldr	r1, [r3]
 509 006a 0122     		mov	r2, #1
 510 006c 0A43     		orr	r2, r1
 511 006e 1A60     		str	r2, [r3]
 512              	.L22:
 150:Src/main.c    **** }
 513              		.loc 1 150 0
 514              		@ sp needed
 515              	.LVL26:
 516 0070 38BD     		pop	{r3, r4, r5, pc}
 517              	.L29:
 518 0072 C046     		.align	2
 519              	.L28:
 520 0074 00200040 		.word	1073750016
 521 0078 00000000 		.word	.LANCHOR3
 522 007c 00000000 		.word	.LANCHOR0
 523 0080 00400140 		.word	1073823744
 524 0084 00000000 		.word	.LANCHOR4
 525              		.cfi_endproc
 526              	.LFE36:
 528              		.section	.text._Error_Handler,"ax",%progbits
 529              		.align	2
 530              		.global	_Error_Handler
 531              		.code	16
 532              		.thumb_func
 534              	_Error_Handler:
 535              	.LFB48:
 696:Src/main.c    **** 
 697:Src/main.c    **** /* USER CODE BEGIN 4 */
 698:Src/main.c    **** 
 699:Src/main.c    **** /* USER CODE END 4 */
 700:Src/main.c    **** 
 701:Src/main.c    **** /**
 702:Src/main.c    ****   * @brief  This function is executed in case of error occurrence.
 703:Src/main.c    ****   * @param  file: The file name as string.
 704:Src/main.c    ****   * @param  line: The line in file as a number.
 705:Src/main.c    ****   * @retval None
 706:Src/main.c    ****   */
 707:Src/main.c    **** void _Error_Handler(char *file, int line)
 708:Src/main.c    **** {
 536              		.loc 1 708 0
 537              		.cfi_startproc
 538              	.LVL27:
 539              	.L31:
 540 0000 FEE7     		b	.L31
 541              		.cfi_endproc
ARM GAS  /tmp/ccelT0ZE.s 			page 44


 542              	.LFE48:
 544 0002 C046     		.section	.text.MX_DAC_Init,"ax",%progbits
 545              		.align	2
 546              		.code	16
 547              		.thumb_func
 549              	MX_DAC_Init:
 550              	.LFB46:
 639:Src/main.c    **** {
 551              		.loc 1 639 0
 552              		.cfi_startproc
 639:Src/main.c    **** {
 553              		.loc 1 639 0
 554 0000 00B5     		push	{lr}
 555              	.LCFI8:
 556              		.cfi_def_cfa_offset 4
 557              		.cfi_offset 14, -4
 558 0002 83B0     		sub	sp, sp, #12
 559              	.LCFI9:
 560              		.cfi_def_cfa_offset 16
 645:Src/main.c    ****   hdac.Instance = DAC;
 561              		.loc 1 645 0
 562 0004 0D48     		ldr	r0, .L35
 563 0006 0E4B     		ldr	r3, .L35+4
 564 0008 0360     		str	r3, [r0]
 646:Src/main.c    ****   if (HAL_DAC_Init(&hdac) != HAL_OK)
 565              		.loc 1 646 0
 566 000a FFF7FEFF 		bl	HAL_DAC_Init
 567              	.LVL28:
 568 000e 0028     		cmp	r0, #0
 569 0010 04D0     		beq	.L33
 648:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 570              		.loc 1 648 0
 571 0012 0C48     		ldr	r0, .L35+8
 572 0014 A221     		mov	r1, #162
 573 0016 8900     		lsl	r1, r1, #2
 574 0018 FFF7FEFF 		bl	_Error_Handler
 575              	.LVL29:
 576              	.L33:
 653:Src/main.c    ****   sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 577              		.loc 1 653 0
 578 001c 0023     		mov	r3, #0
 579 001e 0093     		str	r3, [sp]
 654:Src/main.c    ****   sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 580              		.loc 1 654 0
 581 0020 0193     		str	r3, [sp, #4]
 655:Src/main.c    ****   if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 582              		.loc 1 655 0
 583 0022 0648     		ldr	r0, .L35
 584 0024 6946     		mov	r1, sp
 585 0026 0022     		mov	r2, #0
 586 0028 FFF7FEFF 		bl	HAL_DAC_ConfigChannel
 587              	.LVL30:
 588 002c 0028     		cmp	r0, #0
 589 002e 03D0     		beq	.L32
 657:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 590              		.loc 1 657 0
 591 0030 0448     		ldr	r0, .L35+8
ARM GAS  /tmp/ccelT0ZE.s 			page 45


 592 0032 0549     		ldr	r1, .L35+12
 593 0034 FFF7FEFF 		bl	_Error_Handler
 594              	.LVL31:
 595              	.L32:
 660:Src/main.c    **** }
 596              		.loc 1 660 0
 597 0038 03B0     		add	sp, sp, #12
 598              		@ sp needed
 599 003a 00BD     		pop	{pc}
 600              	.L36:
 601              		.align	2
 602              	.L35:
 603 003c 00000000 		.word	hdac
 604 0040 00740040 		.word	1073771520
 605 0044 00000000 		.word	.LC9
 606 0048 91020000 		.word	657
 607              		.cfi_endproc
 608              	.LFE46:
 610              		.section	.text.MX_TIM14_Init,"ax",%progbits
 611              		.align	2
 612              		.code	16
 613              		.thumb_func
 615              	MX_TIM14_Init:
 616              	.LFB41:
 508:Src/main.c    **** {
 617              		.loc 1 508 0
 618              		.cfi_startproc
 619 0000 08B5     		push	{r3, lr}
 620              	.LCFI10:
 621              		.cfi_def_cfa_offset 8
 622              		.cfi_offset 3, -8
 623              		.cfi_offset 14, -4
 509:Src/main.c    ****   htim14.Instance = TIM14;
 624              		.loc 1 509 0
 625 0002 0C48     		ldr	r0, .L39
 626 0004 0C4B     		ldr	r3, .L39+4
 627 0006 0360     		str	r3, [r0]
 510:Src/main.c    ****   htim14.Init.Prescaler = 11;
 628              		.loc 1 510 0
 629 0008 0B23     		mov	r3, #11
 630 000a 4360     		str	r3, [r0, #4]
 511:Src/main.c    ****   htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 631              		.loc 1 511 0
 632 000c 0023     		mov	r3, #0
 633 000e 8360     		str	r3, [r0, #8]
 512:Src/main.c    ****   htim14.Init.Period = 1000;
 634              		.loc 1 512 0
 635 0010 FA22     		mov	r2, #250
 636 0012 9200     		lsl	r2, r2, #2
 637 0014 C260     		str	r2, [r0, #12]
 513:Src/main.c    ****   htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 638              		.loc 1 513 0
 639 0016 8022     		mov	r2, #128
 640 0018 9200     		lsl	r2, r2, #2
 641 001a 0261     		str	r2, [r0, #16]
 514:Src/main.c    ****   htim14.Init.RepetitionCounter = 0;
 642              		.loc 1 514 0
ARM GAS  /tmp/ccelT0ZE.s 			page 46


 643 001c 4361     		str	r3, [r0, #20]
 515:Src/main.c    ****   htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 644              		.loc 1 515 0
 645 001e 8361     		str	r3, [r0, #24]
 516:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 646              		.loc 1 516 0
 647 0020 FFF7FEFF 		bl	HAL_TIM_Base_Init
 648              	.LVL32:
 649 0024 0028     		cmp	r0, #0
 650 0026 03D0     		beq	.L37
 518:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 651              		.loc 1 518 0
 652 0028 0448     		ldr	r0, .L39+8
 653 002a 0549     		ldr	r1, .L39+12
 654 002c FFF7FEFF 		bl	_Error_Handler
 655              	.LVL33:
 656              	.L37:
 520:Src/main.c    **** }
 657              		.loc 1 520 0
 658              		@ sp needed
 659 0030 08BD     		pop	{r3, pc}
 660              	.L40:
 661 0032 C046     		.align	2
 662              	.L39:
 663 0034 00000000 		.word	htim14
 664 0038 00200040 		.word	1073750016
 665 003c 00000000 		.word	.LC9
 666 0040 06020000 		.word	518
 667              		.cfi_endproc
 668              	.LFE41:
 670              		.section	.text.MX_TIM15_Init,"ax",%progbits
 671              		.align	2
 672              		.code	16
 673              		.thumb_func
 675              	MX_TIM15_Init:
 676              	.LFB42:
 524:Src/main.c    **** {
 677              		.loc 1 524 0
 678              		.cfi_startproc
 679 0000 08B5     		push	{r3, lr}
 680              	.LCFI11:
 681              		.cfi_def_cfa_offset 8
 682              		.cfi_offset 3, -8
 683              		.cfi_offset 14, -4
 525:Src/main.c    ****   htim15.Instance = TIM15;
 684              		.loc 1 525 0
 685 0002 0C48     		ldr	r0, .L43
 686 0004 0C4B     		ldr	r3, .L43+4
 687 0006 0360     		str	r3, [r0]
 526:Src/main.c    ****   htim15.Init.Prescaler = 11;
 688              		.loc 1 526 0
 689 0008 0B23     		mov	r3, #11
 690 000a 4360     		str	r3, [r0, #4]
 527:Src/main.c    ****   htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 691              		.loc 1 527 0
 692 000c 0023     		mov	r3, #0
 693 000e 8360     		str	r3, [r0, #8]
ARM GAS  /tmp/ccelT0ZE.s 			page 47


 528:Src/main.c    ****   htim15.Init.Period = 1000;
 694              		.loc 1 528 0
 695 0010 FA22     		mov	r2, #250
 696 0012 9200     		lsl	r2, r2, #2
 697 0014 C260     		str	r2, [r0, #12]
 529:Src/main.c    ****   htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 698              		.loc 1 529 0
 699 0016 8022     		mov	r2, #128
 700 0018 9200     		lsl	r2, r2, #2
 701 001a 0261     		str	r2, [r0, #16]
 530:Src/main.c    ****   htim15.Init.RepetitionCounter = 0;
 702              		.loc 1 530 0
 703 001c 4361     		str	r3, [r0, #20]
 531:Src/main.c    ****   htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 704              		.loc 1 531 0
 705 001e 8361     		str	r3, [r0, #24]
 532:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 706              		.loc 1 532 0
 707 0020 FFF7FEFF 		bl	HAL_TIM_Base_Init
 708              	.LVL34:
 709 0024 0028     		cmp	r0, #0
 710 0026 03D0     		beq	.L41
 534:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 711              		.loc 1 534 0
 712 0028 0448     		ldr	r0, .L43+8
 713 002a 0549     		ldr	r1, .L43+12
 714 002c FFF7FEFF 		bl	_Error_Handler
 715              	.LVL35:
 716              	.L41:
 536:Src/main.c    **** }
 717              		.loc 1 536 0
 718              		@ sp needed
 719 0030 08BD     		pop	{r3, pc}
 720              	.L44:
 721 0032 C046     		.align	2
 722              	.L43:
 723 0034 00000000 		.word	htim15
 724 0038 00400140 		.word	1073823744
 725 003c 00000000 		.word	.LC9
 726 0040 16020000 		.word	534
 727              		.cfi_endproc
 728              	.LFE42:
 730              		.section	.text.MX_ADC_Init,"ax",%progbits
 731              		.align	2
 732              		.code	16
 733              		.thumb_func
 735              	MX_ADC_Init:
 736              	.LFB39:
 436:Src/main.c    **** {
 737              		.loc 1 436 0
 738              		.cfi_startproc
 739 0000 00B5     		push	{lr}
 740              	.LCFI12:
 741              		.cfi_def_cfa_offset 4
 742              		.cfi_offset 14, -4
 743 0002 85B0     		sub	sp, sp, #20
 744              	.LCFI13:
ARM GAS  /tmp/ccelT0ZE.s 			page 48


 745              		.cfi_def_cfa_offset 24
 746              	.LBB29:
 437:Src/main.c    ****   __HAL_RCC_ADC1_CLK_ENABLE();
 747              		.loc 1 437 0
 748 0004 2A4B     		ldr	r3, .L50
 749 0006 9969     		ldr	r1, [r3, #24]
 750 0008 8022     		mov	r2, #128
 751 000a 9200     		lsl	r2, r2, #2
 752 000c 1143     		orr	r1, r2
 753 000e 9961     		str	r1, [r3, #24]
 754 0010 9B69     		ldr	r3, [r3, #24]
 755 0012 1A40     		and	r2, r3
 756 0014 0092     		str	r2, [sp]
 757 0016 009B     		ldr	r3, [sp]
 758              	.LBE29:
 442:Src/main.c    ****   hadc.Instance = ADC1;
 759              		.loc 1 442 0
 760 0018 2648     		ldr	r0, .L50+4
 761 001a 274B     		ldr	r3, .L50+8
 762 001c 0360     		str	r3, [r0]
 443:Src/main.c    ****   hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 763              		.loc 1 443 0
 764 001e 0023     		mov	r3, #0
 765 0020 4360     		str	r3, [r0, #4]
 444:Src/main.c    ****   hadc.Init.Resolution = ADC_RESOLUTION_12B;
 766              		.loc 1 444 0
 767 0022 8360     		str	r3, [r0, #8]
 445:Src/main.c    ****   hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 768              		.loc 1 445 0
 769 0024 C360     		str	r3, [r0, #12]
 446:Src/main.c    ****   hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 770              		.loc 1 446 0
 771 0026 0122     		mov	r2, #1
 772 0028 0261     		str	r2, [r0, #16]
 447:Src/main.c    ****   hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 773              		.loc 1 447 0
 774 002a 0821     		mov	r1, #8
 775 002c 4161     		str	r1, [r0, #20]
 448:Src/main.c    ****   hadc.Init.LowPowerAutoWait = DISABLE;
 776              		.loc 1 448 0
 777 002e 8361     		str	r3, [r0, #24]
 449:Src/main.c    ****   hadc.Init.LowPowerAutoPowerOff = DISABLE;
 778              		.loc 1 449 0
 779 0030 C361     		str	r3, [r0, #28]
 450:Src/main.c    ****   hadc.Init.ContinuousConvMode = DISABLE;
 780              		.loc 1 450 0
 781 0032 0362     		str	r3, [r0, #32]
 451:Src/main.c    ****   hadc.Init.DiscontinuousConvMode = DISABLE;
 782              		.loc 1 451 0
 783 0034 4362     		str	r3, [r0, #36]
 452:Src/main.c    ****   hadc.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_TRGO;
 784              		.loc 1 452 0
 785 0036 8362     		str	r3, [r0, #40]
 453:Src/main.c    ****   hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 786              		.loc 1 453 0
 787 0038 8023     		mov	r3, #128
 788 003a DB00     		lsl	r3, r3, #3
ARM GAS  /tmp/ccelT0ZE.s 			page 49


 789 003c C362     		str	r3, [r0, #44]
 454:Src/main.c    ****   hadc.Init.DMAContinuousRequests = ENABLE;
 790              		.loc 1 454 0
 791 003e 0263     		str	r2, [r0, #48]
 455:Src/main.c    ****   hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 792              		.loc 1 455 0
 793 0040 4263     		str	r2, [r0, #52]
 456:Src/main.c    ****   if (HAL_ADC_Init(&hadc) != HAL_OK)
 794              		.loc 1 456 0
 795 0042 FFF7FEFF 		bl	HAL_ADC_Init
 796              	.LVL36:
 797 0046 0028     		cmp	r0, #0
 798 0048 04D0     		beq	.L46
 458:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 799              		.loc 1 458 0
 800 004a 1C48     		ldr	r0, .L50+12
 801 004c E521     		mov	r1, #229
 802 004e 4900     		lsl	r1, r1, #1
 803 0050 FFF7FEFF 		bl	_Error_Handler
 804              	.LVL37:
 805              	.L46:
 463:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_0;
 806              		.loc 1 463 0
 807 0054 0023     		mov	r3, #0
 808 0056 0193     		str	r3, [sp, #4]
 464:Src/main.c    ****   sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 809              		.loc 1 464 0
 810 0058 8023     		mov	r3, #128
 811 005a 5B01     		lsl	r3, r3, #5
 812 005c 0293     		str	r3, [sp, #8]
 465:Src/main.c    ****   sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES_5;
 813              		.loc 1 465 0
 814 005e 0323     		mov	r3, #3
 815 0060 0393     		str	r3, [sp, #12]
 466:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 816              		.loc 1 466 0
 817 0062 1448     		ldr	r0, .L50+4
 818 0064 01A9     		add	r1, sp, #4
 819 0066 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 820              	.LVL38:
 821 006a 0028     		cmp	r0, #0
 822 006c 04D0     		beq	.L47
 468:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 823              		.loc 1 468 0
 824 006e 1348     		ldr	r0, .L50+12
 825 0070 EA21     		mov	r1, #234
 826 0072 4900     		lsl	r1, r1, #1
 827 0074 FFF7FEFF 		bl	_Error_Handler
 828              	.LVL39:
 829              	.L47:
 473:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_1;
 830              		.loc 1 473 0
 831 0078 0123     		mov	r3, #1
 832 007a 0193     		str	r3, [sp, #4]
 474:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 833              		.loc 1 474 0
 834 007c 0D48     		ldr	r0, .L50+4
ARM GAS  /tmp/ccelT0ZE.s 			page 50


 835 007e 01A9     		add	r1, sp, #4
 836 0080 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 837              	.LVL40:
 838 0084 0028     		cmp	r0, #0
 839 0086 04D0     		beq	.L48
 476:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 840              		.loc 1 476 0
 841 0088 0C48     		ldr	r0, .L50+12
 842 008a EE21     		mov	r1, #238
 843 008c 4900     		lsl	r1, r1, #1
 844 008e FFF7FEFF 		bl	_Error_Handler
 845              	.LVL41:
 846              	.L48:
 481:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_2;
 847              		.loc 1 481 0
 848 0092 0223     		mov	r3, #2
 849 0094 0193     		str	r3, [sp, #4]
 482:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 850              		.loc 1 482 0
 851 0096 0748     		ldr	r0, .L50+4
 852 0098 01A9     		add	r1, sp, #4
 853 009a FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 854              	.LVL42:
 855 009e 0028     		cmp	r0, #0
 856 00a0 04D0     		beq	.L45
 484:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 857              		.loc 1 484 0
 858 00a2 0648     		ldr	r0, .L50+12
 859 00a4 F221     		mov	r1, #242
 860 00a6 4900     		lsl	r1, r1, #1
 861 00a8 FFF7FEFF 		bl	_Error_Handler
 862              	.LVL43:
 863              	.L45:
 488:Src/main.c    **** }
 864              		.loc 1 488 0
 865 00ac 05B0     		add	sp, sp, #20
 866              		@ sp needed
 867 00ae 00BD     		pop	{pc}
 868              	.L51:
 869              		.align	2
 870              	.L50:
 871 00b0 00100240 		.word	1073876992
 872 00b4 00000000 		.word	hadc
 873 00b8 00240140 		.word	1073816576
 874 00bc 00000000 		.word	.LC9
 875              		.cfi_endproc
 876              	.LFE39:
 878              		.section	.text.USER_TIM1_Init,"ax",%progbits
 879              		.align	2
 880              		.code	16
 881              		.thumb_func
 883              	USER_TIM1_Init:
 884              	.LFB45:
 583:Src/main.c    **** {
 885              		.loc 1 583 0
 886              		.cfi_startproc
 887 0000 00B5     		push	{lr}
ARM GAS  /tmp/ccelT0ZE.s 			page 51


 888              	.LCFI14:
 889              		.cfi_def_cfa_offset 4
 890              		.cfi_offset 14, -4
 891 0002 93B0     		sub	sp, sp, #76
 892              	.LCFI15:
 893              		.cfi_def_cfa_offset 80
 894              	.LBB30:
 584:Src/main.c    ****   __HAL_RCC_TIM1_CLK_ENABLE();
 895              		.loc 1 584 0
 896 0004 2D4B     		ldr	r3, .L57
 897 0006 9969     		ldr	r1, [r3, #24]
 898 0008 8022     		mov	r2, #128
 899 000a 1201     		lsl	r2, r2, #4
 900 000c 1143     		orr	r1, r2
 901 000e 9961     		str	r1, [r3, #24]
 902 0010 9B69     		ldr	r3, [r3, #24]
 903 0012 1A40     		and	r2, r3
 904 0014 0192     		str	r2, [sp, #4]
 905 0016 019B     		ldr	r3, [sp, #4]
 906              	.LBE30:
 590:Src/main.c    ****   htim1.Instance = TIM1;
 907              		.loc 1 590 0
 908 0018 2948     		ldr	r0, .L57+4
 909 001a 2A4B     		ldr	r3, .L57+8
 910 001c 0360     		str	r3, [r0]
 591:Src/main.c    ****   htim1.Init.Prescaler = 0;
 911              		.loc 1 591 0
 912 001e 0023     		mov	r3, #0
 913 0020 4360     		str	r3, [r0, #4]
 592:Src/main.c    ****   htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 914              		.loc 1 592 0
 915 0022 8360     		str	r3, [r0, #8]
 593:Src/main.c    ****   htim1.Init.Period = 1024;
 916              		.loc 1 593 0
 917 0024 8022     		mov	r2, #128
 918 0026 D200     		lsl	r2, r2, #3
 919 0028 C260     		str	r2, [r0, #12]
 594:Src/main.c    ****   htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV2;
 920              		.loc 1 594 0
 921 002a 8022     		mov	r2, #128
 922 002c 5200     		lsl	r2, r2, #1
 923 002e 0261     		str	r2, [r0, #16]
 595:Src/main.c    ****   htim1.Init.RepetitionCounter = 0;
 924              		.loc 1 595 0
 925 0030 4361     		str	r3, [r0, #20]
 596:Src/main.c    ****   htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 926              		.loc 1 596 0
 927 0032 8023     		mov	r3, #128
 928 0034 8361     		str	r3, [r0, #24]
 597:Src/main.c    ****   if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 929              		.loc 1 597 0
 930 0036 FFF7FEFF 		bl	HAL_TIM_PWM_Init
 931              	.LVL44:
 932 003a 0028     		cmp	r0, #0
 933 003c 03D0     		beq	.L53
 599:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 934              		.loc 1 599 0
ARM GAS  /tmp/ccelT0ZE.s 			page 52


 935 003e 2248     		ldr	r0, .L57+12
 936 0040 2249     		ldr	r1, .L57+16
 937 0042 FFF7FEFF 		bl	_Error_Handler
 938              	.LVL45:
 939              	.L53:
 602:Src/main.c    ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
 940              		.loc 1 602 0
 941 0046 2023     		mov	r3, #32
 942 0048 1093     		str	r3, [sp, #64]
 603:Src/main.c    ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 943              		.loc 1 603 0
 944 004a 0023     		mov	r3, #0
 945 004c 1193     		str	r3, [sp, #68]
 604:Src/main.c    ****   if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 946              		.loc 1 604 0
 947 004e 1C48     		ldr	r0, .L57+4
 948 0050 10A9     		add	r1, sp, #64
 949 0052 FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 950              	.LVL46:
 951 0056 0028     		cmp	r0, #0
 952 0058 03D0     		beq	.L54
 606:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 953              		.loc 1 606 0
 954 005a 1B48     		ldr	r0, .L57+12
 955 005c 1C49     		ldr	r1, .L57+20
 956 005e FFF7FEFF 		bl	_Error_Handler
 957              	.LVL47:
 958              	.L54:
 609:Src/main.c    ****   sConfigOC.OCMode = TIM_OCMODE_PWM1;
 959              		.loc 1 609 0
 960 0062 6023     		mov	r3, #96
 961 0064 0993     		str	r3, [sp, #36]
 610:Src/main.c    ****   sConfigOC.Pulse = 0;
 962              		.loc 1 610 0
 963 0066 0023     		mov	r3, #0
 964 0068 0A93     		str	r3, [sp, #40]
 611:Src/main.c    ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 965              		.loc 1 611 0
 966 006a 0B93     		str	r3, [sp, #44]
 612:Src/main.c    ****   sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 967              		.loc 1 612 0
 968 006c 0C93     		str	r3, [sp, #48]
 613:Src/main.c    ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 969              		.loc 1 613 0
 970 006e 0D93     		str	r3, [sp, #52]
 614:Src/main.c    ****   sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 971              		.loc 1 614 0
 972 0070 0E93     		str	r3, [sp, #56]
 615:Src/main.c    ****   sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 973              		.loc 1 615 0
 974 0072 0F93     		str	r3, [sp, #60]
 616:Src/main.c    ****   if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 975              		.loc 1 616 0
 976 0074 1248     		ldr	r0, .L57+4
 977 0076 09A9     		add	r1, sp, #36
 978 0078 0022     		mov	r2, #0
 979 007a FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
ARM GAS  /tmp/ccelT0ZE.s 			page 53


 980              	.LVL48:
 981 007e 0028     		cmp	r0, #0
 982 0080 03D0     		beq	.L55
 618:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 983              		.loc 1 618 0
 984 0082 1148     		ldr	r0, .L57+12
 985 0084 1349     		ldr	r1, .L57+24
 986 0086 FFF7FEFF 		bl	_Error_Handler
 987              	.LVL49:
 988              	.L55:
 621:Src/main.c    ****   sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 989              		.loc 1 621 0
 990 008a 0023     		mov	r3, #0
 991 008c 0293     		str	r3, [sp, #8]
 622:Src/main.c    ****   sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 992              		.loc 1 622 0
 993 008e 0393     		str	r3, [sp, #12]
 623:Src/main.c    ****   sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 994              		.loc 1 623 0
 995 0090 0493     		str	r3, [sp, #16]
 624:Src/main.c    ****   sBreakDeadTimeConfig.DeadTime = 0;
 996              		.loc 1 624 0
 997 0092 0593     		str	r3, [sp, #20]
 625:Src/main.c    ****   sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 998              		.loc 1 625 0
 999 0094 0693     		str	r3, [sp, #24]
 626:Src/main.c    ****   sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 1000              		.loc 1 626 0
 1001 0096 8022     		mov	r2, #128
 1002 0098 9201     		lsl	r2, r2, #6
 1003 009a 0792     		str	r2, [sp, #28]
 627:Src/main.c    ****   sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 1004              		.loc 1 627 0
 1005 009c 0893     		str	r3, [sp, #32]
 628:Src/main.c    ****   if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 1006              		.loc 1 628 0
 1007 009e 0848     		ldr	r0, .L57+4
 1008 00a0 02A9     		add	r1, sp, #8
 1009 00a2 FFF7FEFF 		bl	HAL_TIMEx_ConfigBreakDeadTime
 1010              	.LVL50:
 1011 00a6 0028     		cmp	r0, #0
 1012 00a8 03D0     		beq	.L56
 630:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1013              		.loc 1 630 0
 1014 00aa 0748     		ldr	r0, .L57+12
 1015 00ac 0A49     		ldr	r1, .L57+28
 1016 00ae FFF7FEFF 		bl	_Error_Handler
 1017              	.LVL51:
 1018              	.L56:
 633:Src/main.c    ****   HAL_TIM_MspPostInit(&htim1);
 1019              		.loc 1 633 0
 1020 00b2 0348     		ldr	r0, .L57+4
 1021 00b4 FFF7FEFF 		bl	HAL_TIM_MspPostInit
 1022              	.LVL52:
 634:Src/main.c    **** }
 1023              		.loc 1 634 0
 1024 00b8 13B0     		add	sp, sp, #76
ARM GAS  /tmp/ccelT0ZE.s 			page 54


 1025              		@ sp needed
 1026 00ba 00BD     		pop	{pc}
 1027              	.L58:
 1028              		.align	2
 1029              	.L57:
 1030 00bc 00100240 		.word	1073876992
 1031 00c0 00000000 		.word	htim1
 1032 00c4 002C0140 		.word	1073818624
 1033 00c8 00000000 		.word	.LC9
 1034 00cc 57020000 		.word	599
 1035 00d0 5E020000 		.word	606
 1036 00d4 6A020000 		.word	618
 1037 00d8 76020000 		.word	630
 1038              		.cfi_endproc
 1039              	.LFE45:
 1041              		.section	.text.MX_TIM17_Init,"ax",%progbits
 1042              		.align	2
 1043              		.code	16
 1044              		.thumb_func
 1046              	MX_TIM17_Init:
 1047              	.LFB43:
 540:Src/main.c    **** {
 1048              		.loc 1 540 0
 1049              		.cfi_startproc
 1050 0000 08B5     		push	{r3, lr}
 1051              	.LCFI16:
 1052              		.cfi_def_cfa_offset 8
 1053              		.cfi_offset 3, -8
 1054              		.cfi_offset 14, -4
 541:Src/main.c    ****   htim17.Instance = TIM17;
 1055              		.loc 1 541 0
 1056 0002 0C48     		ldr	r0, .L61
 1057 0004 0C4B     		ldr	r3, .L61+4
 1058 0006 0360     		str	r3, [r0]
 542:Src/main.c    ****   htim17.Init.Prescaler = 11;
 1059              		.loc 1 542 0
 1060 0008 0B23     		mov	r3, #11
 1061 000a 4360     		str	r3, [r0, #4]
 543:Src/main.c    ****   htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
 1062              		.loc 1 543 0
 1063 000c 0023     		mov	r3, #0
 1064 000e 8360     		str	r3, [r0, #8]
 544:Src/main.c    ****   htim17.Init.Period = 1000;
 1065              		.loc 1 544 0
 1066 0010 FA22     		mov	r2, #250
 1067 0012 9200     		lsl	r2, r2, #2
 1068 0014 C260     		str	r2, [r0, #12]
 545:Src/main.c    ****   htim17.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 1069              		.loc 1 545 0
 1070 0016 8022     		mov	r2, #128
 1071 0018 9200     		lsl	r2, r2, #2
 1072 001a 0261     		str	r2, [r0, #16]
 546:Src/main.c    ****   htim17.Init.RepetitionCounter = 0;
 1073              		.loc 1 546 0
 1074 001c 4361     		str	r3, [r0, #20]
 547:Src/main.c    ****   htim17.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 1075              		.loc 1 547 0
ARM GAS  /tmp/ccelT0ZE.s 			page 55


 1076 001e 8023     		mov	r3, #128
 1077 0020 8361     		str	r3, [r0, #24]
 548:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim17) != HAL_OK)
 1078              		.loc 1 548 0
 1079 0022 FFF7FEFF 		bl	HAL_TIM_Base_Init
 1080              	.LVL53:
 1081 0026 0028     		cmp	r0, #0
 1082 0028 03D0     		beq	.L59
 550:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1083              		.loc 1 550 0
 1084 002a 0448     		ldr	r0, .L61+8
 1085 002c 0449     		ldr	r1, .L61+12
 1086 002e FFF7FEFF 		bl	_Error_Handler
 1087              	.LVL54:
 1088              	.L59:
 552:Src/main.c    **** }
 1089              		.loc 1 552 0
 1090              		@ sp needed
 1091 0032 08BD     		pop	{r3, pc}
 1092              	.L62:
 1093              		.align	2
 1094              	.L61:
 1095 0034 00000000 		.word	htim17
 1096 0038 00480140 		.word	1073825792
 1097 003c 00000000 		.word	.LC9
 1098 0040 26020000 		.word	550
 1099              		.cfi_endproc
 1100              	.LFE43:
 1102              		.section	.text.SystemClock_Config,"ax",%progbits
 1103              		.align	2
 1104              		.global	SystemClock_Config
 1105              		.code	16
 1106              		.thumb_func
 1108              	SystemClock_Config:
 1109              	.LFB38:
 383:Src/main.c    **** {
 1110              		.loc 1 383 0
 1111              		.cfi_startproc
 1112 0000 00B5     		push	{lr}
 1113              	.LCFI17:
 1114              		.cfi_def_cfa_offset 4
 1115              		.cfi_offset 14, -4
 1116 0002 99B0     		sub	sp, sp, #100
 1117              	.LCFI18:
 1118              		.cfi_def_cfa_offset 104
 391:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48;
 1119              		.loc 1 391 0
 1120 0004 3023     		mov	r3, #48
 1121 0006 0B93     		str	r3, [sp, #44]
 392:Src/main.c    ****   RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 1122              		.loc 1 392 0
 1123 0008 0123     		mov	r3, #1
 1124 000a 1393     		str	r3, [sp, #76]
 393:Src/main.c    ****   RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 1125              		.loc 1 393 0
 1126 000c 1093     		str	r3, [sp, #64]
 394:Src/main.c    ****   RCC_OscInitStruct.HSI14CalibrationValue = 16;
ARM GAS  /tmp/ccelT0ZE.s 			page 56


 1127              		.loc 1 394 0
 1128 000e 1023     		mov	r3, #16
 1129 0010 1193     		str	r3, [sp, #68]
 395:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 1130              		.loc 1 395 0
 1131 0012 0023     		mov	r3, #0
 1132 0014 1493     		str	r3, [sp, #80]
 396:Src/main.c    ****   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 1133              		.loc 1 396 0
 1134 0016 0BA8     		add	r0, sp, #44
 1135 0018 FFF7FEFF 		bl	HAL_RCC_OscConfig
 1136              	.LVL55:
 1137 001c 0028     		cmp	r0, #0
 1138 001e 04D0     		beq	.L64
 398:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1139              		.loc 1 398 0
 1140 0020 1C48     		ldr	r0, .L67
 1141 0022 C721     		mov	r1, #199
 1142 0024 4900     		lsl	r1, r1, #1
 1143 0026 FFF7FEFF 		bl	_Error_Handler
 1144              	.LVL56:
 1145              	.L64:
 403:Src/main.c    ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 1146              		.loc 1 403 0
 1147 002a 0723     		mov	r3, #7
 1148 002c 0793     		str	r3, [sp, #28]
 405:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 1149              		.loc 1 405 0
 1150 002e 0323     		mov	r3, #3
 1151 0030 0893     		str	r3, [sp, #32]
 406:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 1152              		.loc 1 406 0
 1153 0032 0023     		mov	r3, #0
 1154 0034 0993     		str	r3, [sp, #36]
 407:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 1155              		.loc 1 407 0
 1156 0036 0A93     		str	r3, [sp, #40]
 409:Src/main.c    ****   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 1157              		.loc 1 409 0
 1158 0038 07A8     		add	r0, sp, #28
 1159 003a 0121     		mov	r1, #1
 1160 003c FFF7FEFF 		bl	HAL_RCC_ClockConfig
 1161              	.LVL57:
 1162 0040 0028     		cmp	r0, #0
 1163 0042 04D0     		beq	.L65
 411:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1164              		.loc 1 411 0
 1165 0044 1348     		ldr	r0, .L67
 1166 0046 9C21     		mov	r1, #156
 1167 0048 FF31     		add	r1, r1, #255
 1168 004a FFF7FEFF 		bl	_Error_Handler
 1169              	.LVL58:
 1170              	.L65:
 414:Src/main.c    ****   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 1171              		.loc 1 414 0
 1172 004e 8023     		mov	r3, #128
 1173 0050 9B02     		lsl	r3, r3, #10
ARM GAS  /tmp/ccelT0ZE.s 			page 57


 1174 0052 0093     		str	r3, [sp]
 415:Src/main.c    ****   PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 1175              		.loc 1 415 0
 1176 0054 0023     		mov	r3, #0
 1177 0056 0693     		str	r3, [sp, #24]
 417:Src/main.c    ****   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 1178              		.loc 1 417 0
 1179 0058 6846     		mov	r0, sp
 1180 005a FFF7FEFF 		bl	HAL_RCCEx_PeriphCLKConfig
 1181              	.LVL59:
 1182 005e 0028     		cmp	r0, #0
 1183 0060 04D0     		beq	.L66
 419:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 1184              		.loc 1 419 0
 1185 0062 0C48     		ldr	r0, .L67
 1186 0064 A421     		mov	r1, #164
 1187 0066 FF31     		add	r1, r1, #255
 1188 0068 FFF7FEFF 		bl	_Error_Handler
 1189              	.LVL60:
 1190              	.L66:
 424:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 1191              		.loc 1 424 0
 1192 006c FFF7FEFF 		bl	HAL_RCC_GetHCLKFreq
 1193              	.LVL61:
 1194 0070 FA21     		mov	r1, #250
 1195 0072 8900     		lsl	r1, r1, #2
 1196 0074 FFF7FEFF 		bl	__aeabi_uidiv
 1197              	.LVL62:
 1198 0078 FFF7FEFF 		bl	HAL_SYSTICK_Config
 1199              	.LVL63:
 428:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 1200              		.loc 1 428 0
 1201 007c 0420     		mov	r0, #4
 1202 007e FFF7FEFF 		bl	HAL_SYSTICK_CLKSourceConfig
 1203              	.LVL64:
 431:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 1204              		.loc 1 431 0
 1205 0082 0120     		mov	r0, #1
 1206 0084 4042     		neg	r0, r0
 1207 0086 0021     		mov	r1, #0
 1208 0088 0022     		mov	r2, #0
 1209 008a FFF7FEFF 		bl	HAL_NVIC_SetPriority
 1210              	.LVL65:
 432:Src/main.c    **** }
 1211              		.loc 1 432 0
 1212 008e 19B0     		add	sp, sp, #100
 1213              		@ sp needed
 1214 0090 00BD     		pop	{pc}
 1215              	.L68:
 1216 0092 C046     		.align	2
 1217              	.L67:
 1218 0094 00000000 		.word	.LC9
 1219              		.cfi_endproc
 1220              	.LFE38:
 1222              		.global	__aeabi_i2d
 1223              		.global	__aeabi_ddiv
 1224              		.global	__aeabi_dmul
ARM GAS  /tmp/ccelT0ZE.s 			page 58


 1225              		.global	__aeabi_d2uiz
 1226              		.section	.text.main,"ax",%progbits
 1227              		.align	2
 1228              		.global	main
 1229              		.code	16
 1230              		.thumb_func
 1232              	main:
 1233              	.LFB37:
 173:Src/main.c    **** {
 1234              		.loc 1 173 0
 1235              		.cfi_startproc
 1236 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1237              	.LCFI19:
 1238              		.cfi_def_cfa_offset 20
 1239              		.cfi_offset 4, -20
 1240              		.cfi_offset 5, -16
 1241              		.cfi_offset 6, -12
 1242              		.cfi_offset 7, -8
 1243              		.cfi_offset 14, -4
 1244 0002 5746     		mov	r7, r10
 1245 0004 4646     		mov	r6, r8
 1246 0006 C0B4     		push	{r6, r7}
 1247              	.LCFI20:
 1248              		.cfi_def_cfa_offset 28
 1249              		.cfi_offset 8, -28
 1250              		.cfi_offset 10, -24
 1251 0008 83B0     		sub	sp, sp, #12
 1252              	.LCFI21:
 1253              		.cfi_def_cfa_offset 40
 181:Src/main.c    ****   HAL_Init();
 1254              		.loc 1 181 0
 1255 000a FFF7FEFF 		bl	HAL_Init
 1256              	.LVL66:
 188:Src/main.c    ****   SystemClock_Config();
 1257              		.loc 1 188 0
 1258 000e FFF7FEFF 		bl	SystemClock_Config
 1259              	.LVL67:
 195:Src/main.c    ****   MX_GPIO_Init();
 1260              		.loc 1 195 0
 1261 0012 FFF7FEFF 		bl	MX_GPIO_Init
 1262              	.LVL68:
 196:Src/main.c    **** 	MX_DAC_Init();
 1263              		.loc 1 196 0
 1264 0016 FFF7FEFF 		bl	MX_DAC_Init
 1265              	.LVL69:
 198:Src/main.c    **** 	HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
 1266              		.loc 1 198 0
 1267 001a BB4C     		ldr	r4, .L98+8
 1268 001c 201C     		mov	r0, r4
 1269 001e 0021     		mov	r1, #0
 1270 0020 FFF7FEFF 		bl	HAL_DAC_Start
 1271              	.LVL70:
 199:Src/main.c    **** 	HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048);
 1272              		.loc 1 199 0
 1273 0024 201C     		mov	r0, r4
 1274 0026 0021     		mov	r1, #0
 1275 0028 0022     		mov	r2, #0
ARM GAS  /tmp/ccelT0ZE.s 			page 59


 1276 002a 8023     		mov	r3, #128
 1277 002c 1B01     		lsl	r3, r3, #4
 1278 002e FFF7FEFF 		bl	HAL_DAC_SetValue
 1279              	.LVL71:
 201:Src/main.c    **** 	MX_TIM14_Init();
 1280              		.loc 1 201 0
 1281 0032 FFF7FEFF 		bl	MX_TIM14_Init
 1282              	.LVL72:
 202:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim14);
 1283              		.loc 1 202 0
 1284 0036 B548     		ldr	r0, .L98+12
 1285 0038 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1286              	.LVL73:
 203:Src/main.c    **** 	TIM14->CR1 &= ~(1UL);
 1287              		.loc 1 203 0
 1288 003c B44B     		ldr	r3, .L98+16
 1289 003e 1A68     		ldr	r2, [r3]
 1290 0040 0124     		mov	r4, #1
 1291 0042 A243     		bic	r2, r4
 1292 0044 1A60     		str	r2, [r3]
 205:Src/main.c    **** 	MX_TIM15_Init();
 1293              		.loc 1 205 0
 1294 0046 FFF7FEFF 		bl	MX_TIM15_Init
 1295              	.LVL74:
 206:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim15);
 1296              		.loc 1 206 0
 1297 004a B248     		ldr	r0, .L98+20
 1298 004c FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1299              	.LVL75:
 207:Src/main.c    **** 	TIM15->CR1 &= ~(1UL);
 1300              		.loc 1 207 0
 1301 0050 B14B     		ldr	r3, .L98+24
 1302 0052 1A68     		ldr	r2, [r3]
 1303 0054 A243     		bic	r2, r4
 1304 0056 1A60     		str	r2, [r3]
 209:Src/main.c    ****   MX_DMA_Init();
 1305              		.loc 1 209 0
 1306 0058 FFF7FEFF 		bl	MX_DMA_Init
 1307              	.LVL76:
 210:Src/main.c    ****   MX_ADC_Init();
 1308              		.loc 1 210 0
 1309 005c FFF7FEFF 		bl	MX_ADC_Init
 1310              	.LVL77:
 212:Src/main.c    ****   HAL_ADC_Start_DMA(&hadc, (uint32_t*)adcBuffer, 3);
 1311              		.loc 1 212 0
 1312 0060 AE48     		ldr	r0, .L98+28
 1313 0062 AF49     		ldr	r1, .L98+32
 1314 0064 0322     		mov	r2, #3
 1315 0066 FFF7FEFF 		bl	HAL_ADC_Start_DMA
 1316              	.LVL78:
 215:Src/main.c    **** 	USER_TIM1_Init();
 1317              		.loc 1 215 0
 1318 006a FFF7FEFF 		bl	USER_TIM1_Init
 1319              	.LVL79:
 218:Src/main.c    ****   HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_1);
 1320              		.loc 1 218 0
 1321 006e AD48     		ldr	r0, .L98+36
ARM GAS  /tmp/ccelT0ZE.s 			page 60


 1322 0070 0021     		mov	r1, #0
 1323 0072 FFF7FEFF 		bl	HAL_TIM_PWM_Start_IT
 1324              	.LVL80:
 222:Src/main.c    ****   USER_TIM2_Init();
 1325              		.loc 1 222 0
 1326 0076 FFF7FEFF 		bl	USER_TIM2_Init
 1327              	.LVL81:
 224:Src/main.c    **** 	HAL_TIM_Base_Start(&htim2);
 1328              		.loc 1 224 0
 1329 007a AB4C     		ldr	r4, .L98+40
 1330 007c 201C     		mov	r0, r4
 1331 007e FFF7FEFF 		bl	HAL_TIM_Base_Start
 1332              	.LVL82:
 225:Src/main.c    **** 	HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 1333              		.loc 1 225 0
 1334 0082 201C     		mov	r0, r4
 1335 0084 0421     		mov	r1, #4
 1336 0086 FFF7FEFF 		bl	HAL_TIM_OnePulse_Start
 1337              	.LVL83:
 230:Src/main.c    ****   MX_USB_MIDI_INIT();
 1338              		.loc 1 230 0
 1339 008a FFF7FEFF 		bl	MX_USB_MIDI_INIT
 1340              	.LVL84:
 233:Src/main.c    ****   if(FUNC_ERROR == midiInit() ){
 1341              		.loc 1 233 0
 1342 008e FFF7FEFF 		bl	midiInit
 1343              	.LVL85:
 1344 0092 0028     		cmp	r0, #0
 1345 0094 16D1     		bne	.L70
 235:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1346              		.loc 1 235 0 discriminator 1
 1347 0096 9026     		mov	r6, #144
 1348 0098 F605     		lsl	r6, r6, #23
 1349 009a 8025     		mov	r5, #128
 1350 009c 2D02     		lsl	r5, r5, #8
 236:Src/main.c    **** 		  HAL_Delay(500);
 1351              		.loc 1 236 0 discriminator 1
 1352 009e FA24     		mov	r4, #250
 1353 00a0 6400     		lsl	r4, r4, #1
 1354              	.L95:
 235:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1355              		.loc 1 235 0 discriminator 1
 1356 00a2 301C     		mov	r0, r6
 1357 00a4 291C     		mov	r1, r5
 1358 00a6 0122     		mov	r2, #1
 1359 00a8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1360              	.LVL86:
 236:Src/main.c    **** 		  HAL_Delay(500);
 1361              		.loc 1 236 0 discriminator 1
 1362 00ac 201C     		mov	r0, r4
 1363 00ae FFF7FEFF 		bl	HAL_Delay
 1364              	.LVL87:
 237:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1365              		.loc 1 237 0 discriminator 1
 1366 00b2 301C     		mov	r0, r6
 1367 00b4 291C     		mov	r1, r5
 1368 00b6 0022     		mov	r2, #0
ARM GAS  /tmp/ccelT0ZE.s 			page 61


 1369 00b8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1370              	.LVL88:
 238:Src/main.c    **** 		  HAL_Delay(500);
 1371              		.loc 1 238 0 discriminator 1
 1372 00bc 201C     		mov	r0, r4
 1373 00be FFF7FEFF 		bl	HAL_Delay
 1374              	.LVL89:
 1375 00c2 EEE7     		b	.L95
 1376              	.L70:
 244:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1377              		.loc 1 244 0
 1378 00c4 994E     		ldr	r6, .L98+44
 1379 00c6 FE25     		mov	r5, #254
 1380 00c8 6D00     		lsl	r5, r5, #1
 248:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1381              		.loc 1 248 0
 1382 00ca 9024     		mov	r4, #144
 1383 00cc E405     		lsl	r4, r4, #23
 1384              	.L96:
 244:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1385              		.loc 1 244 0
 1386 00ce 735D     		ldrb	r3, [r6, r5]
 1387 00d0 032B     		cmp	r3, #3
 1388 00d2 0FD1     		bne	.L72
 245:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1389              		.loc 1 245 0
 1390 00d4 9020     		mov	r0, #144
 1391 00d6 C005     		lsl	r0, r0, #23
 1392 00d8 8021     		mov	r1, #128
 1393 00da 0902     		lsl	r1, r1, #8
 1394 00dc 0122     		mov	r2, #1
 1395 00de FFF7FEFF 		bl	HAL_GPIO_WritePin
 1396              	.LVL90:
 252:Src/main.c    ****   MX_TIM17_Init();
 1397              		.loc 1 252 0
 1398 00e2 FFF7FEFF 		bl	MX_TIM17_Init
 1399              	.LVL91:
 253:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim17);
 1400              		.loc 1 253 0
 1401 00e6 9248     		ldr	r0, .L98+48
 1402 00e8 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1403              	.LVL92:
 1404              	.LBB31:
 255:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1405              		.loc 1 255 0
 1406 00ec 0024     		mov	r4, #0
 1407 00ee 914E     		ldr	r6, .L98+52
 256:Src/main.c    ****     Vset = i;
 1408              		.loc 1 256 0
 1409 00f0 914D     		ldr	r5, .L98+56
 255:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1410              		.loc 1 255 0
 1411 00f2 0BE0     		b	.L73
 1412              	.LVL93:
 1413              	.L72:
 1414              	.LBE31:
 248:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
ARM GAS  /tmp/ccelT0ZE.s 			page 62


 1415              		.loc 1 248 0
 1416 00f4 201C     		mov	r0, r4
 1417 00f6 8021     		mov	r1, #128
 1418 00f8 0902     		lsl	r1, r1, #8
 1419 00fa 0022     		mov	r2, #0
 1420 00fc FFF7FEFF 		bl	HAL_GPIO_WritePin
 1421              	.LVL94:
 250:Src/main.c    ****   }
 1422              		.loc 1 250 0
 1423 0100 E5E7     		b	.L96
 1424              	.LVL95:
 1425              	.L74:
 1426              	.LBB32:
 256:Src/main.c    ****     Vset = i;
 1427              		.loc 1 256 0 discriminator 2
 1428 0102 2C60     		str	r4, [r5]
 257:Src/main.c    ****     HAL_Delay(1);
 1429              		.loc 1 257 0 discriminator 2
 1430 0104 0120     		mov	r0, #1
 1431 0106 FFF7FEFF 		bl	HAL_Delay
 1432              	.LVL96:
 255:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1433              		.loc 1 255 0 discriminator 2
 1434 010a 6434     		add	r4, r4, #100
 1435              	.LVL97:
 1436              	.L73:
 255:Src/main.c    ****   for (uint32_t i = 0; i < Vmax; i+=100) {
 1437              		.loc 1 255 0 is_stmt 0 discriminator 1
 1438 010c 3368     		ldr	r3, [r6]
 1439 010e 9C42     		cmp	r4, r3
 1440 0110 F7D3     		bcc	.L74
 1441              	.LBE32:
 260:Src/main.c    ****   Vset = Vmax;
 1442              		.loc 1 260 0 is_stmt 1
 1443 0112 894A     		ldr	r2, .L98+56
 1444 0114 1360     		str	r3, [r2]
 1445              	.LBB33:
 362:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1446              		.loc 1 362 0
 1447 0116 7B4D     		ldr	r5, .L98+4
 1448 0118 794C     		ldr	r4, .L98
 1449              	.LVL98:
 1450              	.LBE33:
 312:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 1451              		.loc 1 312 0
 1452 011a 8849     		ldr	r1, .L98+60
 1453 011c 8846     		mov	r8, r1
 1454 011e 0094     		str	r4, [sp]
 1455 0120 0195     		str	r5, [sp, #4]
 1456              	.L94:
 267:Src/main.c    **** 			if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1457              		.loc 1 267 0
 1458 0122 FE23     		mov	r3, #254
 1459 0124 5B00     		lsl	r3, r3, #1
 1460 0126 814A     		ldr	r2, .L98+44
 1461 0128 D35C     		ldrb	r3, [r2, r3]
 1462 012a 032B     		cmp	r3, #3
ARM GAS  /tmp/ccelT0ZE.s 			page 63


 1463 012c 0ED1     		bne	.L76
 268:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1464              		.loc 1 268 0
 1465 012e 9026     		mov	r6, #144
 1466 0130 F605     		lsl	r6, r6, #23
 1467 0132 301C     		mov	r0, r6
 1468 0134 8021     		mov	r1, #128
 1469 0136 0902     		lsl	r1, r1, #8
 1470 0138 0122     		mov	r2, #1
 1471 013a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1472              	.LVL99:
 277:Src/main.c    ****     if (HAL_GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN)) {
 1473              		.loc 1 277 0
 1474 013e 301C     		mov	r0, r6
 1475 0140 8021     		mov	r1, #128
 1476 0142 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 1477              	.LVL100:
 1478 0146 0028     		cmp	r0, #0
 1479 0148 17D0     		beq	.L97
 1480 014a 14E0     		b	.L77
 1481              	.L76:
 271:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1482              		.loc 1 271 0
 1483 014c 9027     		mov	r7, #144
 1484 014e FF05     		lsl	r7, r7, #23
 1485 0150 8026     		mov	r6, #128
 1486 0152 3602     		lsl	r6, r6, #8
 1487 0154 381C     		mov	r0, r7
 1488 0156 311C     		mov	r1, r6
 1489 0158 0122     		mov	r2, #1
 1490 015a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1491              	.LVL101:
 272:Src/main.c    **** 			  HAL_Delay(200);
 1492              		.loc 1 272 0
 1493 015e C820     		mov	r0, #200
 1494 0160 FFF7FEFF 		bl	HAL_Delay
 1495              	.LVL102:
 273:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1496              		.loc 1 273 0
 1497 0164 381C     		mov	r0, r7
 1498 0166 311C     		mov	r1, r6
 1499 0168 0022     		mov	r2, #0
 1500 016a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1501              	.LVL103:
 274:Src/main.c    **** 			  HAL_Delay(200);
 1502              		.loc 1 274 0
 1503 016e C820     		mov	r0, #200
 1504 0170 FFF7FEFF 		bl	HAL_Delay
 1505              	.LVL104:
 276:Src/main.c    **** 	  }
 1506              		.loc 1 276 0
 1507 0174 D5E7     		b	.L94
 1508              	.L77:
 278:Src/main.c    ****       dfu_otter_bootloader();
 1509              		.loc 1 278 0
 1510 0176 FFF7FEFF 		bl	dfu_otter_bootloader
 1511              	.LVL105:
ARM GAS  /tmp/ccelT0ZE.s 			page 64


 1512              	.L97:
 282:Src/main.c    **** 		curTone0 = 0;
 1513              		.loc 1 282 0
 1514 017a 0023     		mov	r3, #0
 1515 017c 704A     		ldr	r2, .L98+64
 1516 017e 1380     		strh	r3, [r2]
 283:Src/main.c    **** 		curTone1 = 0;
 1517              		.loc 1 283 0
 1518 0180 704A     		ldr	r2, .L98+68
 1519 0182 1380     		strh	r3, [r2]
 1520              	.LVL106:
 1521              	.LBB34:
 286:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 1522              		.loc 1 286 0
 1523 0184 704E     		ldr	r6, .L98+72
 1524 0186 6E48     		ldr	r0, .L98+64
 290:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 1525              		.loc 1 290 0
 1526 0188 9246     		mov	r10, r2
 287:Src/main.c    **** 	          curTone1 = curTone0;
 1527              		.loc 1 287 0
 1528 018a 151C     		mov	r5, r2
 288:Src/main.c    **** 	          curTone0 = freqs[i];
 1529              		.loc 1 288 0
 1530 018c 071C     		mov	r7, r0
 285:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1531              		.loc 1 285 0
 1532 018e 0EE0     		b	.L80
 1533              	.LVL107:
 1534              	.L83:
 286:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 1535              		.loc 1 286 0
 1536 0190 5A00     		lsl	r2, r3, #1
 1537 0192 925B     		ldrh	r2, [r2, r6]
 1538 0194 0188     		ldrh	r1, [r0]
 1539 0196 8A42     		cmp	r2, r1
 1540 0198 02D9     		bls	.L81
 287:Src/main.c    **** 	          curTone1 = curTone0;
 1541              		.loc 1 287 0
 1542 019a 2980     		strh	r1, [r5]
 288:Src/main.c    **** 	          curTone0 = freqs[i];
 1543              		.loc 1 288 0
 1544 019c 3A80     		strh	r2, [r7]
 1545 019e 05E0     		b	.L82
 1546              	.L81:
 290:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 1547              		.loc 1 290 0
 1548 01a0 5446     		mov	r4, r10
 1549 01a2 2188     		ldrh	r1, [r4]
 1550 01a4 8A42     		cmp	r2, r1
 1551 01a6 01D9     		bls	.L82
 291:Src/main.c    **** 	          curTone1 = freqs[i];
 1552              		.loc 1 291 0
 1553 01a8 6649     		ldr	r1, .L98+68
 1554 01aa 0A80     		strh	r2, [r1]
 1555              	.L82:
 285:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
ARM GAS  /tmp/ccelT0ZE.s 			page 65


 1556              		.loc 1 285 0
 1557 01ac 0133     		add	r3, r3, #1
 1558              	.LVL108:
 1559              	.L80:
 285:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1560              		.loc 1 285 0 is_stmt 0 discriminator 1
 1561 01ae 0F2B     		cmp	r3, #15
 1562 01b0 EEDD     		ble	.L83
 1563              	.LBE34:
 295:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 1564              		.loc 1 295 0 is_stmt 1
 1565 01b2 634B     		ldr	r3, .L98+64
 1566              	.LVL109:
 1567 01b4 1988     		ldrh	r1, [r3]
 1568 01b6 1429     		cmp	r1, #20
 1569 01b8 20D9     		bls	.L84
 295:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 1570              		.loc 1 295 0 is_stmt 0 discriminator 1
 1571 01ba 644B     		ldr	r3, .L98+76
 1572 01bc 1B88     		ldrh	r3, [r3]
 1573 01be 9942     		cmp	r1, r3
 1574 01c0 1CD0     		beq	.L84
 296:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 1575              		.loc 1 296 0 is_stmt 1
 1576 01c2 4046     		mov	r0, r8
 1577 01c4 FFF7FEFF 		bl	__aeabi_uidiv
 1578              	.LVL110:
 1579 01c8 614B     		ldr	r3, .L98+80
 1580 01ca 1860     		str	r0, [r3]
 297:Src/main.c    **** 			TIM14->CNT = 0;
 1581              		.loc 1 297 0
 1582 01cc 504B     		ldr	r3, .L98+16
 1583 01ce 0022     		mov	r2, #0
 1584 01d0 5A62     		str	r2, [r3, #36]
 298:Src/main.c    **** 			TIM14->ARR = curPeriode0;
 1585              		.loc 1 298 0
 1586 01d2 D862     		str	r0, [r3, #44]
 299:Src/main.c    **** 			TIM14->CR1 = TIM14->CR1 | 1;
 1587              		.loc 1 299 0
 1588 01d4 1968     		ldr	r1, [r3]
 1589 01d6 0122     		mov	r2, #1
 1590 01d8 0A43     		orr	r2, r1
 1591 01da 1A60     		str	r2, [r3]
 300:Src/main.c    **** 			lastTone0 = curTone0;
 1592              		.loc 1 300 0
 1593 01dc 584B     		ldr	r3, .L98+64
 1594 01de 1A88     		ldrh	r2, [r3]
 1595 01e0 5A4B     		ldr	r3, .L98+76
 1596 01e2 1A80     		strh	r2, [r3]
 301:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 1597              		.loc 1 301 0
 1598 01e4 FFF7FEFF 		bl	HAL_GetTick
 1599              	.LVL111:
 1600 01e8 5A4B     		ldr	r3, .L98+84
 1601 01ea 1860     		str	r0, [r3]
 303:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 1602              		.loc 1 303 0
ARM GAS  /tmp/ccelT0ZE.s 			page 66


 1603 01ec 9020     		mov	r0, #144
 1604 01ee C005     		lsl	r0, r0, #23
 1605 01f0 8021     		mov	r1, #128
 1606 01f2 C900     		lsl	r1, r1, #3
 1607 01f4 0122     		mov	r2, #1
 1608 01f6 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1609              	.LVL112:
 1610 01fa 13E0     		b	.L85
 1611              	.L84:
 304:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 1612              		.loc 1 304 0
 1613 01fc 1329     		cmp	r1, #19
 1614 01fe 11D8     		bhi	.L85
 304:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 1615              		.loc 1 304 0 is_stmt 0 discriminator 1
 1616 0200 524B     		ldr	r3, .L98+76
 1617 0202 1B88     		ldrh	r3, [r3]
 1618 0204 9942     		cmp	r1, r3
 1619 0206 0DD0     		beq	.L85
 305:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 1620              		.loc 1 305 0 is_stmt 1
 1621 0208 414B     		ldr	r3, .L98+16
 1622 020a 1A68     		ldr	r2, [r3]
 1623 020c 0121     		mov	r1, #1
 1624 020e 8A43     		bic	r2, r1
 1625 0210 1A60     		str	r2, [r3]
 306:Src/main.c    ****       curPeriode0 = 0;
 1626              		.loc 1 306 0
 1627 0212 0022     		mov	r2, #0
 1628 0214 4E4B     		ldr	r3, .L98+80
 1629 0216 1A60     		str	r2, [r3]
 308:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1630              		.loc 1 308 0
 1631 0218 9020     		mov	r0, #144
 1632 021a C005     		lsl	r0, r0, #23
 1633 021c 8021     		mov	r1, #128
 1634 021e C900     		lsl	r1, r1, #3
 1635 0220 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1636              	.LVL113:
 1637              	.L85:
 311:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 1638              		.loc 1 311 0
 1639 0224 474B     		ldr	r3, .L98+68
 1640 0226 1988     		ldrh	r1, [r3]
 1641 0228 1429     		cmp	r1, #20
 1642 022a 19D9     		bls	.L86
 311:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 1643              		.loc 1 311 0 is_stmt 0 discriminator 1
 1644 022c 4A4B     		ldr	r3, .L98+88
 1645 022e 1B88     		ldrh	r3, [r3]
 1646 0230 9942     		cmp	r1, r3
 1647 0232 15D0     		beq	.L86
 312:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 1648              		.loc 1 312 0 is_stmt 1
 1649 0234 4046     		mov	r0, r8
 1650 0236 FFF7FEFF 		bl	__aeabi_uidiv
 1651              	.LVL114:
ARM GAS  /tmp/ccelT0ZE.s 			page 67


 1652 023a 484B     		ldr	r3, .L98+92
 1653 023c 1860     		str	r0, [r3]
 313:Src/main.c    **** 			TIM15->CNT = 0;
 1654              		.loc 1 313 0
 1655 023e 364B     		ldr	r3, .L98+24
 1656 0240 0022     		mov	r2, #0
 1657 0242 5A62     		str	r2, [r3, #36]
 314:Src/main.c    **** 			TIM15->ARR = curPeriode1;
 1658              		.loc 1 314 0
 1659 0244 D862     		str	r0, [r3, #44]
 315:Src/main.c    **** 			TIM15->CR1 = TIM15->CR1 | 1;
 1660              		.loc 1 315 0
 1661 0246 1968     		ldr	r1, [r3]
 1662 0248 0122     		mov	r2, #1
 1663 024a 0A43     		orr	r2, r1
 1664 024c 1A60     		str	r2, [r3]
 316:Src/main.c    **** 			lastTone1 = curTone1;
 1665              		.loc 1 316 0
 1666 024e 3D4B     		ldr	r3, .L98+68
 1667 0250 1A88     		ldrh	r2, [r3]
 1668 0252 414B     		ldr	r3, .L98+88
 1669 0254 1A80     		strh	r2, [r3]
 317:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 1670              		.loc 1 317 0
 1671 0256 FFF7FEFF 		bl	HAL_GetTick
 1672              	.LVL115:
 1673 025a 3E4B     		ldr	r3, .L98+84
 1674 025c 1860     		str	r0, [r3]
 1675 025e 0DE0     		b	.L87
 1676              	.L86:
 318:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 1677              		.loc 1 318 0
 1678 0260 1329     		cmp	r1, #19
 1679 0262 0BD8     		bhi	.L87
 318:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 1680              		.loc 1 318 0 is_stmt 0 discriminator 1
 1681 0264 3C4B     		ldr	r3, .L98+88
 1682 0266 1B88     		ldrh	r3, [r3]
 1683 0268 9942     		cmp	r1, r3
 1684 026a 07D0     		beq	.L87
 319:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 1685              		.loc 1 319 0 is_stmt 1
 1686 026c 2A4B     		ldr	r3, .L98+24
 1687 026e 1A68     		ldr	r2, [r3]
 1688 0270 0121     		mov	r1, #1
 1689 0272 8A43     		bic	r2, r1
 1690 0274 1A60     		str	r2, [r3]
 320:Src/main.c    ****       curPeriode1 = 0;
 1691              		.loc 1 320 0
 1692 0276 0022     		mov	r2, #0
 1693 0278 384B     		ldr	r3, .L98+92
 1694 027a 1A60     		str	r2, [r3]
 1695              	.L87:
 323:Src/main.c    **** 		if ((HAL_GetTick() - noteTimeout) > 1000) {
 1696              		.loc 1 323 0
 1697 027c FFF7FEFF 		bl	HAL_GetTick
 1698              	.LVL116:
ARM GAS  /tmp/ccelT0ZE.s 			page 68


 1699 0280 344B     		ldr	r3, .L98+84
 1700 0282 1B68     		ldr	r3, [r3]
 1701 0284 C01A     		sub	r0, r0, r3
 1702 0286 FA23     		mov	r3, #250
 1703 0288 9B00     		lsl	r3, r3, #2
 1704 028a 9842     		cmp	r0, r3
 1705 028c 18D9     		bls	.L88
 324:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 1706              		.loc 1 324 0
 1707 028e 204B     		ldr	r3, .L98+16
 1708 0290 1968     		ldr	r1, [r3]
 1709 0292 0122     		mov	r2, #1
 1710 0294 9143     		bic	r1, r2
 1711 0296 1960     		str	r1, [r3]
 325:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 1712              		.loc 1 325 0
 1713 0298 1F4B     		ldr	r3, .L98+24
 1714 029a 1968     		ldr	r1, [r3]
 1715 029c 9143     		bic	r1, r2
 1716 029e 1960     		str	r1, [r3]
 1717              	.LVL117:
 1718              	.LBB35:
 326:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1719              		.loc 1 326 0
 1720 02a0 0023     		mov	r3, #0
 327:Src/main.c    **** 				freqs[i] = 0;
 1721              		.loc 1 327 0
 1722 02a2 2948     		ldr	r0, .L98+72
 1723 02a4 0021     		mov	r1, #0
 326:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1724              		.loc 1 326 0
 1725 02a6 02E0     		b	.L89
 1726              	.LVL118:
 1727              	.L90:
 327:Src/main.c    **** 				freqs[i] = 0;
 1728              		.loc 1 327 0 discriminator 2
 1729 02a8 5A00     		lsl	r2, r3, #1
 1730 02aa 1152     		strh	r1, [r2, r0]
 326:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1731              		.loc 1 326 0 discriminator 2
 1732 02ac 0133     		add	r3, r3, #1
 1733              	.LVL119:
 1734              	.L89:
 326:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1735              		.loc 1 326 0 is_stmt 0 discriminator 1
 1736 02ae 0F2B     		cmp	r3, #15
 1737 02b0 FADD     		ble	.L90
 1738              	.LBE35:
 330:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1739              		.loc 1 330 0 is_stmt 1
 1740 02b2 9020     		mov	r0, #144
 1741 02b4 C005     		lsl	r0, r0, #23
 1742 02b6 8021     		mov	r1, #128
 1743 02b8 C900     		lsl	r1, r1, #3
 1744 02ba 0022     		mov	r2, #0
 1745 02bc FFF7FEFF 		bl	HAL_GPIO_WritePin
 1746              	.LVL120:
ARM GAS  /tmp/ccelT0ZE.s 			page 69


 1747              	.L88:
 336:Src/main.c    **** 		if( FUNC_SUCCESS == midiGetFromUsbRx(0, &uart_tx_dat)){
 1748              		.loc 1 336 0
 1749 02c0 0020     		mov	r0, #0
 1750 02c2 2749     		ldr	r1, .L98+96
 1751 02c4 FFF7FEFF 		bl	midiGetFromUsbRx
 1752              	.LVL121:
 1753 02c8 0128     		cmp	r0, #1
 1754 02ca 00D0     		beq	.LCB1489
 1755 02cc 29E7     		b	.L94	@long jump
 1756              	.LCB1489:
 337:Src/main.c    **** 			if (uart_tx_dat >> 7 == 1) {
 1757              		.loc 1 337 0
 1758 02ce 244B     		ldr	r3, .L98+96
 1759 02d0 1B78     		ldrb	r3, [r3]
 1760 02d2 DA09     		lsr	r2, r3, #7
 1761 02d4 012A     		cmp	r2, #1
 1762 02d6 08D1     		bne	.L91
 338:Src/main.c    **** 				midiBuffer[0] = uart_tx_dat;
 1763              		.loc 1 338 0
 1764 02d8 224A     		ldr	r2, .L98+100
 1765 02da 1370     		strb	r3, [r2]
 339:Src/main.c    **** 				midiBuffer[1] = 0;
 1766              		.loc 1 339 0
 1767 02dc 0023     		mov	r3, #0
 1768 02de 5370     		strb	r3, [r2, #1]
 340:Src/main.c    **** 				midiBuffer[2] = 0;
 1769              		.loc 1 340 0
 1770 02e0 9370     		strb	r3, [r2, #2]
 341:Src/main.c    **** 				midiState = 1;
 1771              		.loc 1 341 0
 1772 02e2 0122     		mov	r2, #1
 1773 02e4 204B     		ldr	r3, .L98+104
 1774 02e6 1A70     		strb	r2, [r3]
 1775 02e8 1BE7     		b	.L94
 1776              	.L91:
 342:Src/main.c    **** 			} else if (midiState == 1) {
 1777              		.loc 1 342 0
 1778 02ea 1F4A     		ldr	r2, .L98+104
 1779 02ec 1278     		ldrb	r2, [r2]
 1780 02ee 012A     		cmp	r2, #1
 1781 02f0 3CD1     		bne	.L92
 343:Src/main.c    **** 				midiBuffer[1] = uart_tx_dat;
 1782              		.loc 1 343 0
 1783 02f2 1C4A     		ldr	r2, .L98+100
 1784 02f4 5370     		strb	r3, [r2, #1]
 344:Src/main.c    **** 				midiState = 2;
 1785              		.loc 1 344 0
 1786 02f6 0222     		mov	r2, #2
 1787 02f8 1B4B     		ldr	r3, .L98+104
 1788 02fa 1A70     		strb	r2, [r3]
 1789 02fc 11E7     		b	.L94
 1790              	.L99:
 1791 02fe C046     		.align	3
 1792              	.L98:
 1793 0300 00000000 		.word	0
 1794 0304 00002840 		.word	1076363264
ARM GAS  /tmp/ccelT0ZE.s 			page 70


 1795 0308 00000000 		.word	hdac
 1796 030c 00000000 		.word	htim14
 1797 0310 00200040 		.word	1073750016
 1798 0314 00000000 		.word	htim15
 1799 0318 00400140 		.word	1073823744
 1800 031c 00000000 		.word	hadc
 1801 0320 00000000 		.word	adcBuffer
 1802 0324 00000000 		.word	htim1
 1803 0328 00000000 		.word	htim2
 1804 032c 00000000 		.word	hUsbDeviceFS
 1805 0330 00000000 		.word	htim17
 1806 0334 00000000 		.word	.LANCHOR5
 1807 0338 00000000 		.word	.LANCHOR2
 1808 033c 40420F00 		.word	1000000
 1809 0340 00000000 		.word	.LANCHOR6
 1810 0344 00000000 		.word	.LANCHOR7
 1811 0348 00000000 		.word	.LANCHOR8
 1812 034c 00000000 		.word	.LANCHOR9
 1813 0350 00000000 		.word	.LANCHOR3
 1814 0354 00000000 		.word	.LANCHOR10
 1815 0358 00000000 		.word	.LANCHOR11
 1816 035c 00000000 		.word	.LANCHOR4
 1817 0360 00000000 		.word	uart_tx_dat
 1818 0364 00000000 		.word	midiBuffer
 1819 0368 00000000 		.word	.LANCHOR12
 1820              	.L92:
 345:Src/main.c    **** 			} else if (midiState == 2) {
 1821              		.loc 1 345 0
 1822 036c 022A     		cmp	r2, #2
 1823 036e 00D0     		beq	.LCB1553
 1824 0370 D7E6     		b	.L94	@long jump
 1825              	.LCB1553:
 346:Src/main.c    **** 				midiBuffer[2] = uart_tx_dat;
 1826              		.loc 1 346 0
 1827 0372 274A     		ldr	r2, .L100+16
 1828 0374 9370     		strb	r3, [r2, #2]
 347:Src/main.c    **** 				midiState = 3;
 1829              		.loc 1 347 0
 1830 0376 0321     		mov	r1, #3
 1831 0378 264B     		ldr	r3, .L100+20
 1832 037a 1970     		strb	r1, [r3]
 349:Src/main.c    **** 				if ((midiBuffer[0] & 0xF0) == 0x90) { // Note on, 2 data bytes
 1833              		.loc 1 349 0
 1834 037c 1378     		ldrb	r3, [r2]
 1835 037e 0F22     		mov	r2, #15
 1836 0380 9343     		bic	r3, r2
 1837 0382 902B     		cmp	r3, #144
 1838 0384 1CD1     		bne	.L93
 1839              	.LBB36:
 350:Src/main.c    **** 					char key = midiBuffer[1];
 1840              		.loc 1 350 0
 1841 0386 224E     		ldr	r6, .L100+16
 1842 0388 7078     		ldrb	r0, [r6, #1]
 1843              	.LVL122:
 353:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1844              		.loc 1 353 0
 1845 038a 4538     		sub	r0, r0, #69
ARM GAS  /tmp/ccelT0ZE.s 			page 71


 1846 038c FFF7FEFF 		bl	__aeabi_i2d
 1847              	.LVL123:
 1848 0390 009A     		ldr	r2, [sp]
 1849 0392 019B     		ldr	r3, [sp, #4]
 1850 0394 FFF7FEFF 		bl	__aeabi_ddiv
 1851              	.LVL124:
 1852 0398 021C     		mov	r2, r0
 1853 039a 0B1C     		mov	r3, r1
 1854 039c 1949     		ldr	r1, .L100+4
 1855 039e 1848     		ldr	r0, .L100
 1856 03a0 FFF7FEFF 		bl	pow
 1857              	.LVL125:
 1858 03a4 184A     		ldr	r2, .L100+8
 1859 03a6 194B     		ldr	r3, .L100+12
 1860 03a8 FFF7FEFF 		bl	__aeabi_dmul
 1861              	.LVL126:
 1862 03ac FFF7FEFF 		bl	__aeabi_d2uiz
 1863              	.LVL127:
 354:Src/main.c    **** 					curChannel = midiBuffer[0] & 0xF;
 1864              		.loc 1 354 0
 1865 03b0 3278     		ldrb	r2, [r6]
 1866 03b2 0F23     		mov	r3, #15
 1867 03b4 1340     		and	r3, r2
 1868 03b6 184A     		ldr	r2, .L100+24
 1869 03b8 1380     		strh	r3, [r2]
 355:Src/main.c    **** 					freqs[curChannel] = freq;
 1870              		.loc 1 355 0
 1871 03ba 5B00     		lsl	r3, r3, #1
 1872 03bc 174A     		ldr	r2, .L100+28
 1873 03be D052     		strh	r0, [r2, r3]
 1874              	.LVL128:
 1875              	.L93:
 1876              	.LBE36:
 358:Src/main.c    **** 				} if ((midiBuffer[0] &0xF0) == 0x80) { // Note off, 2 data bytes
 1877              		.loc 1 358 0
 1878 03c0 134B     		ldr	r3, .L100+16
 1879 03c2 1B78     		ldrb	r3, [r3]
 1880 03c4 0F22     		mov	r2, #15
 1881 03c6 9343     		bic	r3, r2
 1882 03c8 802B     		cmp	r3, #128
 1883 03ca 00D0     		beq	.LCB1612
 1884 03cc A9E6     		b	.L94	@long jump
 1885              	.LCB1612:
 1886              	.LBB37:
 359:Src/main.c    **** 					char key = midiBuffer[1];
 1887              		.loc 1 359 0
 1888 03ce 104E     		ldr	r6, .L100+16
 1889 03d0 7078     		ldrb	r0, [r6, #1]
 1890              	.LVL129:
 362:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1891              		.loc 1 362 0
 1892 03d2 4538     		sub	r0, r0, #69
 1893 03d4 FFF7FEFF 		bl	__aeabi_i2d
 1894              	.LVL130:
 1895 03d8 009A     		ldr	r2, [sp]
 1896 03da 019B     		ldr	r3, [sp, #4]
 1897 03dc FFF7FEFF 		bl	__aeabi_ddiv
ARM GAS  /tmp/ccelT0ZE.s 			page 72


 1898              	.LVL131:
 1899 03e0 021C     		mov	r2, r0
 1900 03e2 0B1C     		mov	r3, r1
 1901 03e4 0749     		ldr	r1, .L100+4
 1902 03e6 0648     		ldr	r0, .L100
 1903 03e8 FFF7FEFF 		bl	pow
 1904              	.LVL132:
 365:Src/main.c    **** 					freqs[midiBuffer[0] & 0xF] = 0;
 1905              		.loc 1 365 0
 1906 03ec 3278     		ldrb	r2, [r6]
 1907 03ee 0F23     		mov	r3, #15
 1908 03f0 1A40     		and	r2, r3
 1909 03f2 5200     		lsl	r2, r2, #1
 1910 03f4 0021     		mov	r1, #0
 1911 03f6 094B     		ldr	r3, .L100+28
 1912 03f8 D152     		strh	r1, [r2, r3]
 1913 03fa 92E6     		b	.L94
 1914              	.L101:
 1915 03fc C046C046 		.align	3
 1916              	.L100:
 1917 0400 00000000 		.word	0
 1918 0404 00000040 		.word	1073741824
 1919 0408 00000000 		.word	0
 1920 040c 00807B40 		.word	1081835520
 1921 0410 00000000 		.word	midiBuffer
 1922 0414 00000000 		.word	.LANCHOR12
 1923 0418 00000000 		.word	.LANCHOR13
 1924 041c 00000000 		.word	.LANCHOR8
 1925              	.LBE37:
 1926              		.cfi_endproc
 1927              	.LFE37:
 1929              		.global	freqs
 1930              		.global	noteTimeout
 1931              		.global	lastTone1
 1932              		.global	lastTone0
 1933              		.global	curChannel
 1934              		.global	curTone1
 1935              		.global	curTone0
 1936              		.global	midiState
 1937              		.comm	midiBuffer,4,4
 1938              		.global	curPeriode1
 1939              		.global	curPeriode0
 1940              		.global	Vmax
 1941              		.global	Vset
 1942              		.global	Iout
 1943              		.global	Vout
 1944              		.comm	uart_tx_dat,1,1
 1945              		.comm	adcBuffer,6,4
 1946              		.comm	hdma_adc,68,4
 1947              		.comm	hadc,76,4
 1948              		.comm	hdac,20,4
 1949              		.comm	htim1,64,4
 1950              		.comm	htim2,64,4
 1951              		.comm	htim17,64,4
 1952              		.comm	htim15,64,4
 1953              		.comm	htim14,64,4
 1954              		.section	.bss.curTone1,"aw",%nobits
ARM GAS  /tmp/ccelT0ZE.s 			page 73


 1955              		.align	1
 1956              		.set	.LANCHOR7,. + 0
 1959              	curTone1:
 1960 0000 0000     		.space	2
 1961              		.section	.bss.lastTone0,"aw",%nobits
 1962              		.align	1
 1963              		.set	.LANCHOR9,. + 0
 1966              	lastTone0:
 1967 0000 0000     		.space	2
 1968              		.section	.bss.lastTone1,"aw",%nobits
 1969              		.align	1
 1970              		.set	.LANCHOR11,. + 0
 1973              	lastTone1:
 1974 0000 0000     		.space	2
 1975              		.section	.bss.curTone0,"aw",%nobits
 1976              		.align	1
 1977              		.set	.LANCHOR6,. + 0
 1980              	curTone0:
 1981 0000 0000     		.space	2
 1982              		.section	.bss.Vout,"aw",%nobits
 1983              		.align	2
 1984              		.set	.LANCHOR1,. + 0
 1987              	Vout:
 1988 0000 00000000 		.space	4
 1989              		.section	.bss.curPeriode0,"aw",%nobits
 1990              		.align	2
 1991              		.set	.LANCHOR3,. + 0
 1994              	curPeriode0:
 1995 0000 00000000 		.space	4
 1996              		.section	.bss.curPeriode1,"aw",%nobits
 1997              		.align	2
 1998              		.set	.LANCHOR4,. + 0
 2001              	curPeriode1:
 2002 0000 00000000 		.space	4
 2003              		.section	.bss.noteTimeout,"aw",%nobits
 2004              		.align	2
 2005              		.set	.LANCHOR10,. + 0
 2008              	noteTimeout:
 2009 0000 00000000 		.space	4
 2010              		.section	.bss.freqs,"aw",%nobits
 2011              		.align	2
 2012              		.set	.LANCHOR8,. + 0
 2015              	freqs:
 2016 0000 00000000 		.space	32
 2016      00000000 
 2016      00000000 
 2016      00000000 
 2016      00000000 
 2017              		.section	.rodata.str1.4,"aMS",%progbits,1
 2018              		.align	2
 2019              	.LC9:
 2020 0000 5372632F 		.ascii	"Src/main.c\000"
 2020      6D61696E 
 2020      2E6300
 2021 000b 00       		.section	.data.Vmax,"aw",%progbits
 2022              		.align	2
 2023              		.set	.LANCHOR5,. + 0
ARM GAS  /tmp/ccelT0ZE.s 			page 74


 2026              	Vmax:
 2027 0000 20CB0000 		.word	52000
 2028              		.section	.bss.curChannel,"aw",%nobits
 2029              		.align	1
 2030              		.set	.LANCHOR13,. + 0
 2033              	curChannel:
 2034 0000 0000     		.space	2
 2035              		.section	.bss.midiState,"aw",%nobits
 2036              		.set	.LANCHOR12,. + 0
 2039              	midiState:
 2040 0000 00       		.space	1
 2041              		.section	.bss.Iout,"aw",%nobits
 2042              		.align	1
 2043              		.set	.LANCHOR0,. + 0
 2046              	Iout:
 2047 0000 0000     		.space	2
 2048              		.section	.bss.Vset,"aw",%nobits
 2049              		.align	2
 2050              		.set	.LANCHOR2,. + 0
 2053              	Vset:
 2054 0000 00000000 		.space	4
 2055              		.text
 2056              	.Letext0:
 2057              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 2058              		.file 5 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_defaul
 2059              		.file 6 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 2060              		.file 7 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h"
 2061              		.file 8 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h"
 2062              		.file 9 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc.h"
 2063              		.file 10 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc_ex.h"
 2064              		.file 11 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 2065              		.file 12 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma.h"
 2066              		.file 13 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_adc.h"
 2067              		.file 14 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dac.h"
 2068              		.file 15 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim.h"
 2069              		.file 16 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim_ex.h"
 2070              		.file 17 "Middlewares/ST/STM32_USB_Device_Library/Core/Inc/usbd_def.h"
 2071              		.file 18 "Inc/curelib_inc/curemisc.h"
 2072              		.file 19 "Inc/usb_device.h"
 2073              		.file 20 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_cortex.h"
 2074              		.file 21 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h"
 2075              		.file 22 "Inc/usbd_midi_if.h"
 2076              		.file 23 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/math.h"
ARM GAS  /tmp/ccelT0ZE.s 			page 75


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccelT0ZE.s:18     .text.MX_GPIO_Init:00000000 $t
     /tmp/ccelT0ZE.s:22     .text.MX_GPIO_Init:00000000 MX_GPIO_Init
     /tmp/ccelT0ZE.s:105    .text.MX_GPIO_Init:00000068 $d
     /tmp/ccelT0ZE.s:110    .text.MX_DMA_Init:00000000 $t
     /tmp/ccelT0ZE.s:114    .text.MX_DMA_Init:00000000 MX_DMA_Init
     /tmp/ccelT0ZE.s:154    .text.MX_DMA_Init:0000002c $d
     /tmp/ccelT0ZE.s:159    .text.USER_TIM2_Init:00000000 $t
     /tmp/ccelT0ZE.s:163    .text.USER_TIM2_Init:00000000 USER_TIM2_Init
     /tmp/ccelT0ZE.s:252    .text.USER_TIM2_Init:0000006c $d
                            *COM*:00000040 htim2
     /tmp/ccelT0ZE.s:262    .text.htim17_update:00000000 $t
     /tmp/ccelT0ZE.s:267    .text.htim17_update:00000000 htim17_update
     /tmp/ccelT0ZE.s:348    .text.htim17_update:00000060 $d
                            *COM*:00000006 adcBuffer
     /tmp/ccelT0ZE.s:361    .text.dfu_otter_bootloader:00000000 $t
     /tmp/ccelT0ZE.s:366    .text.dfu_otter_bootloader:00000000 dfu_otter_bootloader
     /tmp/ccelT0ZE.s:412    .text.dfu_otter_bootloader:00000018 $d
     /tmp/ccelT0ZE.s:425    .text.HAL_TIM_PeriodElapsedCallback:00000000 $t
     /tmp/ccelT0ZE.s:430    .text.HAL_TIM_PeriodElapsedCallback:00000000 HAL_TIM_PeriodElapsedCallback
     /tmp/ccelT0ZE.s:520    .text.HAL_TIM_PeriodElapsedCallback:00000074 $d
     /tmp/ccelT0ZE.s:529    .text._Error_Handler:00000000 $t
     /tmp/ccelT0ZE.s:534    .text._Error_Handler:00000000 _Error_Handler
     /tmp/ccelT0ZE.s:545    .text.MX_DAC_Init:00000000 $t
     /tmp/ccelT0ZE.s:549    .text.MX_DAC_Init:00000000 MX_DAC_Init
     /tmp/ccelT0ZE.s:603    .text.MX_DAC_Init:0000003c $d
                            *COM*:00000014 hdac
     /tmp/ccelT0ZE.s:611    .text.MX_TIM14_Init:00000000 $t
     /tmp/ccelT0ZE.s:615    .text.MX_TIM14_Init:00000000 MX_TIM14_Init
     /tmp/ccelT0ZE.s:663    .text.MX_TIM14_Init:00000034 $d
                            *COM*:00000040 htim14
     /tmp/ccelT0ZE.s:671    .text.MX_TIM15_Init:00000000 $t
     /tmp/ccelT0ZE.s:675    .text.MX_TIM15_Init:00000000 MX_TIM15_Init
     /tmp/ccelT0ZE.s:723    .text.MX_TIM15_Init:00000034 $d
                            *COM*:00000040 htim15
     /tmp/ccelT0ZE.s:731    .text.MX_ADC_Init:00000000 $t
     /tmp/ccelT0ZE.s:735    .text.MX_ADC_Init:00000000 MX_ADC_Init
     /tmp/ccelT0ZE.s:871    .text.MX_ADC_Init:000000b0 $d
                            *COM*:0000004c hadc
     /tmp/ccelT0ZE.s:879    .text.USER_TIM1_Init:00000000 $t
     /tmp/ccelT0ZE.s:883    .text.USER_TIM1_Init:00000000 USER_TIM1_Init
     /tmp/ccelT0ZE.s:1030   .text.USER_TIM1_Init:000000bc $d
                            *COM*:00000040 htim1
     /tmp/ccelT0ZE.s:1042   .text.MX_TIM17_Init:00000000 $t
     /tmp/ccelT0ZE.s:1046   .text.MX_TIM17_Init:00000000 MX_TIM17_Init
     /tmp/ccelT0ZE.s:1095   .text.MX_TIM17_Init:00000034 $d
                            *COM*:00000040 htim17
     /tmp/ccelT0ZE.s:1103   .text.SystemClock_Config:00000000 $t
     /tmp/ccelT0ZE.s:1108   .text.SystemClock_Config:00000000 SystemClock_Config
     /tmp/ccelT0ZE.s:1218   .text.SystemClock_Config:00000094 $d
     /tmp/ccelT0ZE.s:1227   .text.main:00000000 $t
     /tmp/ccelT0ZE.s:1232   .text.main:00000000 main
     /tmp/ccelT0ZE.s:1793   .text.main:00000300 $d
                            *COM*:00000001 uart_tx_dat
                            *COM*:00000004 midiBuffer
     /tmp/ccelT0ZE.s:1822   .text.main:0000036c $t
ARM GAS  /tmp/ccelT0ZE.s 			page 76


     /tmp/ccelT0ZE.s:1917   .text.main:00000400 $d
     /tmp/ccelT0ZE.s:2015   .bss.freqs:00000000 freqs
     /tmp/ccelT0ZE.s:2008   .bss.noteTimeout:00000000 noteTimeout
     /tmp/ccelT0ZE.s:1973   .bss.lastTone1:00000000 lastTone1
     /tmp/ccelT0ZE.s:1966   .bss.lastTone0:00000000 lastTone0
     /tmp/ccelT0ZE.s:2033   .bss.curChannel:00000000 curChannel
     /tmp/ccelT0ZE.s:1959   .bss.curTone1:00000000 curTone1
     /tmp/ccelT0ZE.s:1980   .bss.curTone0:00000000 curTone0
     /tmp/ccelT0ZE.s:2039   .bss.midiState:00000000 midiState
     /tmp/ccelT0ZE.s:2001   .bss.curPeriode1:00000000 curPeriode1
     /tmp/ccelT0ZE.s:1994   .bss.curPeriode0:00000000 curPeriode0
     /tmp/ccelT0ZE.s:2026   .data.Vmax:00000000 Vmax
     /tmp/ccelT0ZE.s:2053   .bss.Vset:00000000 Vset
     /tmp/ccelT0ZE.s:2046   .bss.Iout:00000000 Iout
     /tmp/ccelT0ZE.s:1987   .bss.Vout:00000000 Vout
                            *COM*:00000044 hdma_adc
     /tmp/ccelT0ZE.s:1955   .bss.curTone1:00000000 $d
     /tmp/ccelT0ZE.s:1962   .bss.lastTone0:00000000 $d
     /tmp/ccelT0ZE.s:1969   .bss.lastTone1:00000000 $d
     /tmp/ccelT0ZE.s:1976   .bss.curTone0:00000000 $d
     /tmp/ccelT0ZE.s:1983   .bss.Vout:00000000 $d
     /tmp/ccelT0ZE.s:1990   .bss.curPeriode0:00000000 $d
     /tmp/ccelT0ZE.s:1997   .bss.curPeriode1:00000000 $d
     /tmp/ccelT0ZE.s:2004   .bss.noteTimeout:00000000 $d
     /tmp/ccelT0ZE.s:2011   .bss.freqs:00000000 $d
     /tmp/ccelT0ZE.s:2018   .rodata.str1.4:00000000 $d
     /tmp/ccelT0ZE.s:2022   .data.Vmax:00000000 $d
     /tmp/ccelT0ZE.s:2029   .bss.curChannel:00000000 $d
     /tmp/ccelT0ZE.s:2040   .bss.midiState:00000000 $d
     /tmp/ccelT0ZE.s:2042   .bss.Iout:00000000 $d
     /tmp/ccelT0ZE.s:2049   .bss.Vset:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
HAL_GPIO_WritePin
HAL_GPIO_Init
HAL_NVIC_SetPriority
HAL_NVIC_EnableIRQ
HAL_TIM_Base_Init
HAL_TIMEx_MasterConfigSynchronization
HAL_TIM_PWM_ConfigChannel
HAL_TIM_OnePulse_Init
HAL_TIM_MspPostInit
__aeabi_i2f
__aeabi_fmul
__aeabi_f2uiz
__aeabi_idiv
__aeabi_uidiv
HAL_DAC_Init
HAL_DAC_ConfigChannel
HAL_ADC_Init
HAL_ADC_ConfigChannel
HAL_TIM_PWM_Init
HAL_TIMEx_ConfigBreakDeadTime
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_RCCEx_PeriphCLKConfig
ARM GAS  /tmp/ccelT0ZE.s 			page 77


HAL_RCC_GetHCLKFreq
HAL_SYSTICK_Config
HAL_SYSTICK_CLKSourceConfig
__aeabi_i2d
__aeabi_ddiv
__aeabi_dmul
__aeabi_d2uiz
HAL_Init
HAL_DAC_Start
HAL_DAC_SetValue
HAL_TIM_Base_Start_IT
HAL_ADC_Start_DMA
HAL_TIM_PWM_Start_IT
HAL_TIM_Base_Start
HAL_TIM_OnePulse_Start
MX_USB_MIDI_INIT
midiInit
HAL_Delay
HAL_GPIO_ReadPin
HAL_GetTick
midiGetFromUsbRx
hUsbDeviceFS
pow
