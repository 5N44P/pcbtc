ARM GAS  /tmp/ccv6GvnB.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 1
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"main.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.MX_GPIO_Init,"ax",%progbits
  18              		.align	2
  19              		.code	16
  20              		.thumb_func
  22              	MX_GPIO_Init:
  23              	.LFB45:
  24              		.file 1 "Src/main.c"
   1:Src/main.c    **** 
   2:Src/main.c    **** /**
   3:Src/main.c    ****   ******************************************************************************
   4:Src/main.c    ****   * @file           : main.c
   5:Src/main.c    ****   * @brief          : Main program body
   6:Src/main.c    ****   ******************************************************************************
   7:Src/main.c    ****   * This notice applies to any and all portions of this file
   8:Src/main.c    ****   * that are not between comment pairs USER CODE BEGIN and
   9:Src/main.c    ****   * USER CODE END. Other portions of this file, whether
  10:Src/main.c    ****   * inserted by the user or by software development tools
  11:Src/main.c    ****   * are owned by their respective copyright owners.
  12:Src/main.c    ****   *
  13:Src/main.c    ****   * Copyright (c) 2018 STMicroelectronics International N.V.
  14:Src/main.c    ****   * All rights reserved.
  15:Src/main.c    ****   *
  16:Src/main.c    ****   * Redistribution and use in source and binary forms, with or without
  17:Src/main.c    ****   * modification, are permitted, provided that the following conditions are met:
  18:Src/main.c    ****   *
  19:Src/main.c    ****   * 1. Redistribution of source code must retain the above copyright notice,
  20:Src/main.c    ****   *    this list of conditions and the following disclaimer.
  21:Src/main.c    ****   * 2. Redistributions in binary form must reproduce the above copyright notice,
  22:Src/main.c    ****   *    this list of conditions and the following disclaimer in the documentation
  23:Src/main.c    ****   *    and/or other materials provided with the distribution.
  24:Src/main.c    ****   * 3. Neither the name of STMicroelectronics nor the names of other
  25:Src/main.c    ****   *    contributors to this software may be used to endorse or promote products
  26:Src/main.c    ****   *    derived from this software without specific written permission.
  27:Src/main.c    ****   * 4. This software, including modifications and/or derivative works of this
  28:Src/main.c    ****   *    software, must execute solely and exclusively on microcontroller or
  29:Src/main.c    ****   *    microprocessor devices manufactured by or for STMicroelectronics.
  30:Src/main.c    ****   * 5. Redistribution and use of this software other than as permitted under
  31:Src/main.c    ****   *    this license is void and will automatically terminate your rights under
  32:Src/main.c    ****   *    this license.
  33:Src/main.c    ****   *
  34:Src/main.c    ****   * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS"
ARM GAS  /tmp/ccv6GvnB.s 			page 2


  35:Src/main.c    ****   * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT
  36:Src/main.c    ****   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  37:Src/main.c    ****   * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
  38:Src/main.c    ****   * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT
  39:Src/main.c    ****   * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  40:Src/main.c    ****   * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  41:Src/main.c    ****   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
  42:Src/main.c    ****   * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  43:Src/main.c    ****   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  44:Src/main.c    ****   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  45:Src/main.c    ****   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  46:Src/main.c    ****   *
  47:Src/main.c    ****   ******************************************************************************
  48:Src/main.c    ****   */
  49:Src/main.c    **** /* Includes ------------------------------------------------------------------*/
  50:Src/main.c    **** #include "main.h"
  51:Src/main.c    **** #include "stm32f0xx_hal.h"
  52:Src/main.c    **** #include "usb_device.h"
  53:Src/main.c    **** 
  54:Src/main.c    **** /* USER CODE BEGIN Includes */
  55:Src/main.c    **** #include "device_conf.h"
  56:Src/main.c    **** #include "curemisc.h"
  57:Src/main.c    **** #include "curebuffer.h"
  58:Src/main.c    **** #include "usbd_midi_if.h"
  59:Src/main.c    **** #include "math.h"
  60:Src/main.c    **** 
  61:Src/main.c    **** /* USER CODE END Includes */
  62:Src/main.c    **** 
  63:Src/main.c    **** /* Private variables ---------------------------------------------------------*/
  64:Src/main.c    **** TIM_HandleTypeDef htim14;
  65:Src/main.c    **** TIM_HandleTypeDef htim15;
  66:Src/main.c    **** 
  67:Src/main.c    **** TIM_HandleTypeDef htim2;
  68:Src/main.c    **** 
  69:Src/main.c    **** TIM_HandleTypeDef htim1;
  70:Src/main.c    **** 
  71:Src/main.c    **** DAC_HandleTypeDef hdac;
  72:Src/main.c    **** 
  73:Src/main.c    **** ADC_HandleTypeDef hadc;
  74:Src/main.c    **** DMA_HandleTypeDef hdma_adc;
  75:Src/main.c    **** 
  76:Src/main.c    **** uint16_t adcBuffer[3];
  77:Src/main.c    **** 
  78:Src/main.c    **** 
  79:Src/main.c    **** uint8_t uart_tx_dat;
  80:Src/main.c    **** /* USER CODE END PV */
  81:Src/main.c    **** 
  82:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
  83:Src/main.c    **** void SystemClock_Config(void);
  84:Src/main.c    **** static void MX_GPIO_Init(void);
  85:Src/main.c    **** 
  86:Src/main.c    **** static void MX_TIM14_Init(void);
  87:Src/main.c    **** static void MX_TIM15_Init(void);
  88:Src/main.c    **** static void USER_TIM2_Init(void);
  89:Src/main.c    **** static void USER_TIM1_Init(void);
  90:Src/main.c    **** 
  91:Src/main.c    **** static void MX_DAC_Init(void);
ARM GAS  /tmp/ccv6GvnB.s 			page 3


  92:Src/main.c    **** 
  93:Src/main.c    **** static void MX_DMA_Init(void);
  94:Src/main.c    **** static void MX_ADC_Init(void);
  95:Src/main.c    **** 
  96:Src/main.c    **** /* USER CODE BEGIN PFP */
  97:Src/main.c    **** /* Private function prototypes -----------------------------------------------*/
  98:Src/main.c    **** void dfu_otter_bootloader(void)
  99:Src/main.c    **** {
 100:Src/main.c    ****   *((unsigned long *)0x20003FF0) = 0xDEADBEEF;
 101:Src/main.c    ****   NVIC_SystemReset();
 102:Src/main.c    **** }
 103:Src/main.c    **** /* USER CODE END PFP */
 104:Src/main.c    **** 
 105:Src/main.c    **** /* USER CODE BEGIN 0 */
 106:Src/main.c    **** 
 107:Src/main.c    **** uint32_t curPeriode0 = 0;
 108:Src/main.c    **** uint32_t curPeriode1 = 0;
 109:Src/main.c    **** 
 110:Src/main.c    **** void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
 111:Src/main.c    **** {
 112:Src/main.c    **** 	if(htim->Instance == TIM14)
 113:Src/main.c    **** 	{
 114:Src/main.c    **** 		//HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 115:Src/main.c    ****     if (TIM2->CNT == 0) {
 116:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / 5); // Play first channel
 117:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 118:Src/main.c    ****     }
 119:Src/main.c    **** 	}
 120:Src/main.c    **** 	if(htim->Instance == TIM15)
 121:Src/main.c    **** 	{
 122:Src/main.c    **** 		//HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 123:Src/main.c    ****     if (TIM2->CNT == 0) {
 124:Src/main.c    ****     	TIM2->ARR = (uint32_t)(curPeriode1 / 10); // Play second channel with less power
 125:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 126:Src/main.c    ****     }
 127:Src/main.c    **** 	}
 128:Src/main.c    **** }
 129:Src/main.c    **** 
 130:Src/main.c    **** /**
 131:Src/main.c    ****   * @brief  The application entry point.
 132:Src/main.c    ****   *
 133:Src/main.c    ****   * @retval None
 134:Src/main.c    ****   */
 135:Src/main.c    **** 
 136:Src/main.c    **** 
 137:Src/main.c    **** uint8_t midiBuffer[4];
 138:Src/main.c    **** uint8_t midiState = 0;
 139:Src/main.c    **** 
 140:Src/main.c    **** uint16_t curTone0 = 0;
 141:Src/main.c    **** uint16_t curTone1 = 0;
 142:Src/main.c    **** uint16_t curChannel = 0;
 143:Src/main.c    **** uint16_t lastTone0 = 0;
 144:Src/main.c    **** uint16_t lastTone1 = 0;
 145:Src/main.c    **** uint32_t noteTimeout = 0;
 146:Src/main.c    **** 
 147:Src/main.c    **** uint16_t freqs[16] = {0};
 148:Src/main.c    **** 
ARM GAS  /tmp/ccv6GvnB.s 			page 4


 149:Src/main.c    **** 
 150:Src/main.c    **** int main(void)
 151:Src/main.c    **** {
 152:Src/main.c    ****   /* USER CODE BEGIN 1 */
 153:Src/main.c    **** 
 154:Src/main.c    ****   /* USER CODE END 1 */
 155:Src/main.c    **** 
 156:Src/main.c    ****   /* MCU Configuration----------------------------------------------------------*/
 157:Src/main.c    **** 
 158:Src/main.c    ****   /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
 159:Src/main.c    ****   HAL_Init();
 160:Src/main.c    **** 
 161:Src/main.c    ****   /* USER CODE BEGIN Init */
 162:Src/main.c    **** 
 163:Src/main.c    ****   /* USER CODE END Init */
 164:Src/main.c    **** 
 165:Src/main.c    ****   /* Configure the system clock */
 166:Src/main.c    ****   SystemClock_Config();
 167:Src/main.c    **** 
 168:Src/main.c    ****   /* USER CODE BEGIN SysInit */
 169:Src/main.c    **** 
 170:Src/main.c    ****   /* USER CODE END SysInit */
 171:Src/main.c    **** 
 172:Src/main.c    ****   /* Initialize all configured peripherals */
 173:Src/main.c    ****   MX_GPIO_Init();
 174:Src/main.c    **** 	MX_DAC_Init();
 175:Src/main.c    **** 
 176:Src/main.c    **** 	HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
 177:Src/main.c    **** 	HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048);
 178:Src/main.c    **** 
 179:Src/main.c    **** 	MX_TIM14_Init();
 180:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim14);
 181:Src/main.c    **** 	TIM14->CR1 &= ~(1UL);
 182:Src/main.c    **** 
 183:Src/main.c    **** 	MX_TIM15_Init();
 184:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim15);
 185:Src/main.c    **** 	TIM15->CR1 &= ~(1UL);
 186:Src/main.c    **** 
 187:Src/main.c    **** 	USER_TIM1_Init();
 188:Src/main.c    **** 
 189:Src/main.c    ****   //HAL_TIM_PWM_Start(&htim1);
 190:Src/main.c    ****   HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
 191:Src/main.c    **** 
 192:Src/main.c    ****   //__HAL_TIM_SET_COMPARE(&htim1, TIM_CHANNEL_1, 1000);
 193:Src/main.c    **** 
 194:Src/main.c    ****   USER_TIM2_Init();
 195:Src/main.c    **** 
 196:Src/main.c    **** 	HAL_TIM_Base_Start(&htim2);
 197:Src/main.c    **** 	HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 198:Src/main.c    **** 
 199:Src/main.c    ****   MX_DMA_Init();
 200:Src/main.c    ****   MX_ADC_Init();
 201:Src/main.c    **** 
 202:Src/main.c    ****   HAL_ADC_Start_DMA(&hadc, (uint32_t*)adcBuffer, 3);
 203:Src/main.c    **** 
 204:Src/main.c    ****   /* USER CODE BEGIN 2 */
 205:Src/main.c    **** 
ARM GAS  /tmp/ccv6GvnB.s 			page 5


 206:Src/main.c    ****   //USB-MIDI Init
 207:Src/main.c    ****   MX_USB_MIDI_INIT();
 208:Src/main.c    **** 
 209:Src/main.c    **** 
 210:Src/main.c    ****   if(FUNC_ERROR == midiInit() ){
 211:Src/main.c    **** 	  while(1){
 212:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 213:Src/main.c    **** 		  HAL_Delay(500);
 214:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 215:Src/main.c    **** 		  HAL_Delay(500);
 216:Src/main.c    **** 	  }
 217:Src/main.c    ****   }
 218:Src/main.c    **** 
 219:Src/main.c    ****   //Wait usb configuration.
 220:Src/main.c    ****   while(1){
 221:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 222:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 223:Src/main.c    **** 		  break;
 224:Src/main.c    **** 	  }else{
 225:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 226:Src/main.c    **** 	  }
 227:Src/main.c    ****   }
 228:Src/main.c    **** 
 229:Src/main.c    ****   while (1)
 230:Src/main.c    ****   {
 231:Src/main.c    ****   //Wait USB configuration when USB connection error has occurred.
 232:Src/main.c    **** 	 /* while(1){
 233:Src/main.c    **** 				//HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 234:Src/main.c    **** 			if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 235:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 236:Src/main.c    **** 			  break;
 237:Src/main.c    **** 		  }else{
 238:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 239:Src/main.c    **** 			  HAL_Delay(200);
 240:Src/main.c    **** 			  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 241:Src/main.c    **** 			  HAL_Delay(200);
 242:Src/main.c    **** 		  }
 243:Src/main.c    **** 	  }*/
 244:Src/main.c    **** 
 245:Src/main.c    ****     if (HAL_GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN)) {
 246:Src/main.c    ****       dfu_otter_bootloader();
 247:Src/main.c    ****     }
 248:Src/main.c    **** 
 249:Src/main.c    ****     float Vout = ((float)adcBuffer[1] / 4096.0f) * 68.0f;
 250:Src/main.c    **** 
 251:Src/main.c    ****     if (Vout > 20) {
 252:Src/main.c    ****       HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 253:Src/main.c    ****     } else {
 254:Src/main.c    ****       HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 255:Src/main.c    ****     }
 256:Src/main.c    **** 
 257:Src/main.c    **** 		curTone0 = 0;
 258:Src/main.c    **** 		curTone1 = 0;
 259:Src/main.c    **** 
 260:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 261:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 262:Src/main.c    **** 	          curTone1 = curTone0;
ARM GAS  /tmp/ccv6GvnB.s 			page 6


 263:Src/main.c    **** 	          curTone0 = freqs[i];
 264:Src/main.c    **** 	      }
 265:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 266:Src/main.c    **** 	          curTone1 = freqs[i];
 267:Src/main.c    **** 	      }
 268:Src/main.c    **** 	  }
 269:Src/main.c    **** 
 270:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 271:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 272:Src/main.c    **** 			TIM14->CNT = 0;
 273:Src/main.c    **** 			TIM14->ARR = curPeriode0;
 274:Src/main.c    **** 			TIM14->CR1 = TIM14->CR1 | 1;
 275:Src/main.c    **** 			lastTone0 = curTone0;
 276:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 277:Src/main.c    **** 
 278:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 279:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 280:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 281:Src/main.c    ****       curPeriode0 = 0;
 282:Src/main.c    **** 
 283:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 284:Src/main.c    **** 		}
 285:Src/main.c    **** 
 286:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 287:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 288:Src/main.c    **** 			TIM15->CNT = 0;
 289:Src/main.c    **** 			TIM15->ARR = curPeriode1;
 290:Src/main.c    **** 			TIM15->CR1 = TIM15->CR1 | 1;
 291:Src/main.c    **** 			lastTone1 = curTone1;
 292:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 293:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 294:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 295:Src/main.c    ****       curPeriode1 = 0;
 296:Src/main.c    **** 		}
 297:Src/main.c    **** 
 298:Src/main.c    **** 		if ((HAL_GetTick() - noteTimeout) > 1000) {
 299:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 300:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 301:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 302:Src/main.c    **** 				freqs[i] = 0;
 303:Src/main.c    **** 			}
 304:Src/main.c    **** 
 305:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 306:Src/main.c    **** 		}
 307:Src/main.c    **** 
 308:Src/main.c    **** 
 309:Src/main.c    **** 		//[USB-MIDI IN] to [MIDI JACK OUT]
 310:Src/main.c    **** 
 311:Src/main.c    **** 		if( FUNC_SUCCESS == midiGetFromUsbRx(0, &uart_tx_dat)){
 312:Src/main.c    **** 			if (uart_tx_dat >> 7 == 1) {
 313:Src/main.c    **** 				midiBuffer[0] = uart_tx_dat;
 314:Src/main.c    **** 				midiBuffer[1] = 0;
 315:Src/main.c    **** 				midiBuffer[2] = 0;
 316:Src/main.c    **** 				midiState = 1;
 317:Src/main.c    **** 			} else if (midiState == 1) {
 318:Src/main.c    **** 				midiBuffer[1] = uart_tx_dat;
 319:Src/main.c    **** 				midiState = 2;
ARM GAS  /tmp/ccv6GvnB.s 			page 7


 320:Src/main.c    **** 			} else if (midiState == 2) {
 321:Src/main.c    **** 				midiBuffer[2] = uart_tx_dat;
 322:Src/main.c    **** 				midiState = 3;
 323:Src/main.c    **** 
 324:Src/main.c    **** 				if ((midiBuffer[0] & 0xF0) == 0x90) { // Note on, 2 data bytes
 325:Src/main.c    **** 					char key = midiBuffer[1];
 326:Src/main.c    **** 					char vel = midiBuffer[2];
 327:Src/main.c    **** 
 328:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 329:Src/main.c    **** 					curChannel = midiBuffer[0] & 0xF;
 330:Src/main.c    **** 					freqs[curChannel] = freq;
 331:Src/main.c    **** 
 332:Src/main.c    **** 
 333:Src/main.c    **** 				} if ((midiBuffer[0] &0xF0) == 0x80) { // Note off, 2 data bytes
 334:Src/main.c    **** 					char key = midiBuffer[1];
 335:Src/main.c    **** 					char vel = midiBuffer[2];
 336:Src/main.c    **** 
 337:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 338:Src/main.c    **** 
 339:Src/main.c    **** 					//if (freqs[midiBuffer[0] & 0xF] == freq) {
 340:Src/main.c    **** 					freqs[midiBuffer[0] & 0xF] = 0;
 341:Src/main.c    **** 					//}
 342:Src/main.c    **** 				}
 343:Src/main.c    **** 			}
 344:Src/main.c    **** 		}
 345:Src/main.c    **** 
 346:Src/main.c    **** 	//[MIDI JACK IN] to [USB-MIDI OUT]
 347:Src/main.c    **** 	//midiProcess();
 348:Src/main.c    **** 
 349:Src/main.c    **** 
 350:Src/main.c    ****   }
 351:Src/main.c    ****   /* USER CODE END 3 */
 352:Src/main.c    **** 
 353:Src/main.c    **** }
 354:Src/main.c    **** 
 355:Src/main.c    **** /** System Clock Configuration
 356:Src/main.c    **** */
 357:Src/main.c    **** void SystemClock_Config(void)
 358:Src/main.c    **** {
 359:Src/main.c    **** 
 360:Src/main.c    ****   RCC_OscInitTypeDef RCC_OscInitStruct;
 361:Src/main.c    ****   RCC_ClkInitTypeDef RCC_ClkInitStruct;
 362:Src/main.c    ****   RCC_PeriphCLKInitTypeDef PeriphClkInit;
 363:Src/main.c    **** 
 364:Src/main.c    ****     /**Initializes the CPU, AHB and APB busses clocks
 365:Src/main.c    ****     */
 366:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48;
 367:Src/main.c    ****   RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 368:Src/main.c    ****   RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 369:Src/main.c    ****   RCC_OscInitStruct.HSI14CalibrationValue = 16;
 370:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 371:Src/main.c    ****   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 372:Src/main.c    ****   {
 373:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 374:Src/main.c    ****   }
 375:Src/main.c    **** 
 376:Src/main.c    ****     /**Initializes the CPU, AHB and APB busses clocks
ARM GAS  /tmp/ccv6GvnB.s 			page 8


 377:Src/main.c    ****     */
 378:Src/main.c    ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 379:Src/main.c    ****                               |RCC_CLOCKTYPE_PCLK1;
 380:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 381:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 382:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 383:Src/main.c    **** 
 384:Src/main.c    ****   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 385:Src/main.c    ****   {
 386:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 387:Src/main.c    ****   }
 388:Src/main.c    **** 
 389:Src/main.c    ****   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 390:Src/main.c    ****   PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 391:Src/main.c    **** 
 392:Src/main.c    ****   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 393:Src/main.c    ****   {
 394:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 395:Src/main.c    ****   }
 396:Src/main.c    **** 
 397:Src/main.c    ****     /**Configure the Systick interrupt time
 398:Src/main.c    ****     */
 399:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 400:Src/main.c    **** 
 401:Src/main.c    ****     /**Configure the Systick
 402:Src/main.c    ****     */
 403:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 404:Src/main.c    **** 
 405:Src/main.c    ****   /* SysTick_IRQn interrupt configuration */
 406:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 407:Src/main.c    **** }
 408:Src/main.c    **** 
 409:Src/main.c    **** /* ADC init function */
 410:Src/main.c    **** static void MX_ADC_Init(void)
 411:Src/main.c    **** {
 412:Src/main.c    ****   __HAL_RCC_ADC1_CLK_ENABLE();
 413:Src/main.c    ****   ADC_ChannelConfTypeDef sConfig;
 414:Src/main.c    **** 
 415:Src/main.c    ****     /**Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of co
 416:Src/main.c    ****     */
 417:Src/main.c    ****   hadc.Instance = ADC1;
 418:Src/main.c    ****   hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 419:Src/main.c    ****   hadc.Init.Resolution = ADC_RESOLUTION_12B;
 420:Src/main.c    ****   hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 421:Src/main.c    ****   hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 422:Src/main.c    ****   hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 423:Src/main.c    ****   hadc.Init.LowPowerAutoWait = DISABLE;
 424:Src/main.c    ****   hadc.Init.LowPowerAutoPowerOff = DISABLE;
 425:Src/main.c    ****   hadc.Init.ContinuousConvMode = DISABLE;
 426:Src/main.c    ****   hadc.Init.DiscontinuousConvMode = DISABLE;
 427:Src/main.c    ****   hadc.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_TRGO;
 428:Src/main.c    ****   hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 429:Src/main.c    ****   hadc.Init.DMAContinuousRequests = ENABLE;
 430:Src/main.c    ****   hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 431:Src/main.c    ****   if (HAL_ADC_Init(&hadc) != HAL_OK)
 432:Src/main.c    ****   {
 433:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
ARM GAS  /tmp/ccv6GvnB.s 			page 9


 434:Src/main.c    ****   }
 435:Src/main.c    **** 
 436:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 437:Src/main.c    ****     */
 438:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_0;
 439:Src/main.c    ****   sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 440:Src/main.c    ****   sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES_5;
 441:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 442:Src/main.c    ****   {
 443:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 444:Src/main.c    ****   }
 445:Src/main.c    **** 
 446:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 447:Src/main.c    ****     */
 448:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_1;
 449:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 450:Src/main.c    ****   {
 451:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 452:Src/main.c    ****   }
 453:Src/main.c    **** 
 454:Src/main.c    ****     /**Configure for the selected ADC regular channel to be converted.
 455:Src/main.c    ****     */
 456:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_2;
 457:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 458:Src/main.c    ****   {
 459:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 460:Src/main.c    ****   }
 461:Src/main.c    **** 
 462:Src/main.c    **** 
 463:Src/main.c    **** }
 464:Src/main.c    **** 
 465:Src/main.c    **** /**
 466:Src/main.c    ****   * Enable DMA controller clock
 467:Src/main.c    ****   */
 468:Src/main.c    **** static void MX_DMA_Init(void)
 469:Src/main.c    **** {
 470:Src/main.c    ****   /* DMA controller clock enable */
 471:Src/main.c    ****   __HAL_RCC_DMA1_CLK_ENABLE();
 472:Src/main.c    **** 
 473:Src/main.c    ****   /* DMA interrupt init */
 474:Src/main.c    ****   /* DMA1_Channel1_IRQn interrupt configuration */
 475:Src/main.c    ****   HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 476:Src/main.c    ****   HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 477:Src/main.c    **** 
 478:Src/main.c    **** }
 479:Src/main.c    **** 
 480:Src/main.c    **** 
 481:Src/main.c    **** /* TIM14 init function */
 482:Src/main.c    **** static void MX_TIM14_Init(void)
 483:Src/main.c    **** {
 484:Src/main.c    ****   htim14.Instance = TIM14;
 485:Src/main.c    ****   htim14.Init.Prescaler = 11;
 486:Src/main.c    ****   htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 487:Src/main.c    ****   htim14.Init.Period = 1000;
 488:Src/main.c    ****   htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 489:Src/main.c    ****   htim14.Init.RepetitionCounter = 0;
 490:Src/main.c    ****   htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
ARM GAS  /tmp/ccv6GvnB.s 			page 10


 491:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
 492:Src/main.c    ****   {
 493:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 494:Src/main.c    ****   }
 495:Src/main.c    **** }
 496:Src/main.c    **** 
 497:Src/main.c    **** /* TIM15 init function */
 498:Src/main.c    **** static void MX_TIM15_Init(void)
 499:Src/main.c    **** {
 500:Src/main.c    ****   htim15.Instance = TIM15;
 501:Src/main.c    ****   htim15.Init.Prescaler = 11;
 502:Src/main.c    ****   htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 503:Src/main.c    ****   htim15.Init.Period = 1000;
 504:Src/main.c    ****   htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 505:Src/main.c    ****   htim15.Init.RepetitionCounter = 0;
 506:Src/main.c    ****   htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 507:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 508:Src/main.c    ****   {
 509:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 510:Src/main.c    ****   }
 511:Src/main.c    **** }
 512:Src/main.c    **** 
 513:Src/main.c    **** static void USER_TIM2_Init(void) {
 514:Src/main.c    **** 	__HAL_RCC_TIM2_CLK_ENABLE();
 515:Src/main.c    **** 
 516:Src/main.c    **** 	TIM_ClockConfigTypeDef sClockSourceConfig;
 517:Src/main.c    **** 	TIM_MasterConfigTypeDef sMasterConfig;
 518:Src/main.c    **** 	TIM_OC_InitTypeDef sConfigOC;
 519:Src/main.c    **** 
 520:Src/main.c    **** 	htim2.Instance = TIM2;
 521:Src/main.c    **** 	htim2.Init.Prescaler = 0;
 522:Src/main.c    **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 523:Src/main.c    **** 	htim2.Init.Period = 3200;
 524:Src/main.c    **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 525:Src/main.c    **** 	HAL_TIM_Base_Init(&htim2);
 526:Src/main.c    **** 
 527:Src/main.c    **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 528:Src/main.c    **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 529:Src/main.c    **** 	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 530:Src/main.c    **** 
 531:Src/main.c    **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 532:Src/main.c    **** 	sConfigOC.Pulse = 1;
 533:Src/main.c    **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
 534:Src/main.c    **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 535:Src/main.c    **** 	HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
 536:Src/main.c    **** 
 537:Src/main.c    **** 	HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
 538:Src/main.c    **** 	HAL_TIM_MspPostInit(&htim2);
 539:Src/main.c    **** }
 540:Src/main.c    **** 
 541:Src/main.c    **** static void USER_TIM1_Init(void)
 542:Src/main.c    **** {
 543:Src/main.c    ****   __HAL_RCC_TIM1_CLK_ENABLE();
 544:Src/main.c    **** 
 545:Src/main.c    ****   TIM_MasterConfigTypeDef sMasterConfig;
 546:Src/main.c    ****   TIM_OC_InitTypeDef sConfigOC;
 547:Src/main.c    ****   TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig;
ARM GAS  /tmp/ccv6GvnB.s 			page 11


 548:Src/main.c    **** 
 549:Src/main.c    ****   htim1.Instance = TIM1;
 550:Src/main.c    ****   htim1.Init.Prescaler = 0;
 551:Src/main.c    ****   htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 552:Src/main.c    ****   htim1.Init.Period = 1024;
 553:Src/main.c    ****   htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 554:Src/main.c    ****   htim1.Init.RepetitionCounter = 0;
 555:Src/main.c    ****   htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 556:Src/main.c    ****   if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 557:Src/main.c    ****   {
 558:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 559:Src/main.c    ****   }
 560:Src/main.c    **** 
 561:Src/main.c    ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 562:Src/main.c    ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 563:Src/main.c    ****   if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 564:Src/main.c    ****   {
 565:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 566:Src/main.c    ****   }
 567:Src/main.c    **** 
 568:Src/main.c    ****   sConfigOC.OCMode = TIM_OCMODE_PWM1;
 569:Src/main.c    ****   sConfigOC.Pulse = 100;
 570:Src/main.c    ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 571:Src/main.c    ****   sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 572:Src/main.c    ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 573:Src/main.c    ****   sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 574:Src/main.c    ****   sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 575:Src/main.c    ****   if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 576:Src/main.c    ****   {
 577:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 578:Src/main.c    ****   }
 579:Src/main.c    **** 
 580:Src/main.c    ****   sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 581:Src/main.c    ****   sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 582:Src/main.c    ****   sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 583:Src/main.c    ****   sBreakDeadTimeConfig.DeadTime = 0;
 584:Src/main.c    ****   sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 585:Src/main.c    ****   sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 586:Src/main.c    ****   sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 587:Src/main.c    ****   if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 588:Src/main.c    ****   {
 589:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 590:Src/main.c    ****   }
 591:Src/main.c    **** 
 592:Src/main.c    ****   HAL_TIM_MspPostInit(&htim1);
 593:Src/main.c    **** 
 594:Src/main.c    **** }
 595:Src/main.c    **** 
 596:Src/main.c    **** 
 597:Src/main.c    **** /* DAC init function */
 598:Src/main.c    **** static void MX_DAC_Init(void)
 599:Src/main.c    **** {
 600:Src/main.c    **** 
 601:Src/main.c    ****   DAC_ChannelConfTypeDef sConfig;
 602:Src/main.c    **** 
 603:Src/main.c    ****     /**DAC Initialization
 604:Src/main.c    ****     */
ARM GAS  /tmp/ccv6GvnB.s 			page 12


 605:Src/main.c    ****   hdac.Instance = DAC;
 606:Src/main.c    ****   if (HAL_DAC_Init(&hdac) != HAL_OK)
 607:Src/main.c    ****   {
 608:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 609:Src/main.c    ****   }
 610:Src/main.c    **** 
 611:Src/main.c    ****     /**DAC channel OUT1 config
 612:Src/main.c    ****     */
 613:Src/main.c    ****   sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 614:Src/main.c    ****   sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 615:Src/main.c    ****   if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 616:Src/main.c    ****   {
 617:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 618:Src/main.c    ****   }
 619:Src/main.c    **** 
 620:Src/main.c    **** }
 621:Src/main.c    **** 
 622:Src/main.c    **** 
 623:Src/main.c    **** 
 624:Src/main.c    **** /**
 625:Src/main.c    ****   * Enable DMA controller clock
 626:Src/main.c    ****   */
 627:Src/main.c    **** 
 628:Src/main.c    **** 
 629:Src/main.c    **** /** Configure pins as
 630:Src/main.c    ****         * Analog
 631:Src/main.c    ****         * Input
 632:Src/main.c    ****         * Output
 633:Src/main.c    ****         * EVENT_OUT
 634:Src/main.c    ****         * EXTI
 635:Src/main.c    **** */
 636:Src/main.c    **** static void MX_GPIO_Init(void)
 637:Src/main.c    **** {
  25              		.loc 1 637 0
  26              		.cfi_startproc
  27 0000 30B5     		push	{r4, r5, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 12
  30              		.cfi_offset 4, -12
  31              		.cfi_offset 5, -8
  32              		.cfi_offset 14, -4
  33 0002 89B0     		sub	sp, sp, #36
  34              	.LCFI1:
  35              		.cfi_def_cfa_offset 48
  36              	.LBB8:
 638:Src/main.c    **** 
 639:Src/main.c    ****   GPIO_InitTypeDef GPIO_InitStruct;
 640:Src/main.c    **** 
 641:Src/main.c    ****   /* GPIO Ports Clock Enable */
 642:Src/main.c    ****   __HAL_RCC_GPIOF_CLK_ENABLE();
  37              		.loc 1 642 0
  38 0004 184B     		ldr	r3, .L2
  39 0006 5969     		ldr	r1, [r3, #20]
  40 0008 8022     		mov	r2, #128
  41 000a D203     		lsl	r2, r2, #15
  42 000c 1143     		orr	r1, r2
  43 000e 5961     		str	r1, [r3, #20]
ARM GAS  /tmp/ccv6GvnB.s 			page 13


  44 0010 5969     		ldr	r1, [r3, #20]
  45 0012 0A40     		and	r2, r1
  46 0014 0092     		str	r2, [sp]
  47 0016 009A     		ldr	r2, [sp]
  48              	.LBE8:
  49              	.LBB9:
 643:Src/main.c    ****   __HAL_RCC_GPIOA_CLK_ENABLE();
  50              		.loc 1 643 0
  51 0018 5969     		ldr	r1, [r3, #20]
  52 001a 8022     		mov	r2, #128
  53 001c 9202     		lsl	r2, r2, #10
  54 001e 1143     		orr	r1, r2
  55 0020 5961     		str	r1, [r3, #20]
  56 0022 5969     		ldr	r1, [r3, #20]
  57 0024 0A40     		and	r2, r1
  58 0026 0192     		str	r2, [sp, #4]
  59 0028 019A     		ldr	r2, [sp, #4]
  60              	.LBE9:
  61              	.LBB10:
 644:Src/main.c    ****   __HAL_RCC_GPIOB_CLK_ENABLE();
  62              		.loc 1 644 0
  63 002a 5969     		ldr	r1, [r3, #20]
  64 002c 8022     		mov	r2, #128
  65 002e D202     		lsl	r2, r2, #11
  66 0030 1143     		orr	r1, r2
  67 0032 5961     		str	r1, [r3, #20]
  68 0034 5B69     		ldr	r3, [r3, #20]
  69 0036 1A40     		and	r2, r3
  70 0038 0292     		str	r2, [sp, #8]
  71 003a 029B     		ldr	r3, [sp, #8]
  72              	.LBE10:
 645:Src/main.c    **** 
 646:Src/main.c    ****   /*Configure GPIO pin Output Level */
 647:Src/main.c    ****   HAL_GPIO_WritePin(GPIOA, GPIO_PIN_10|GPIO_PIN_15, GPIO_PIN_RESET);
  73              		.loc 1 647 0
  74 003c 9024     		mov	r4, #144
  75 003e E405     		lsl	r4, r4, #23
  76 0040 8425     		mov	r5, #132
  77 0042 2D02     		lsl	r5, r5, #8
  78 0044 201C     		mov	r0, r4
  79 0046 291C     		mov	r1, r5
  80 0048 0022     		mov	r2, #0
  81 004a FFF7FEFF 		bl	HAL_GPIO_WritePin
  82              	.LVL0:
 648:Src/main.c    **** 
 649:Src/main.c    ****   /*Configure GPIO pins : PA4 PA5 PA6 PA7 */
 650:Src/main.c    ****   GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_15;
  83              		.loc 1 650 0
  84 004e 0395     		str	r5, [sp, #12]
 651:Src/main.c    ****   GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  85              		.loc 1 651 0
  86 0050 0123     		mov	r3, #1
  87 0052 0493     		str	r3, [sp, #16]
 652:Src/main.c    ****   GPIO_InitStruct.Pull = GPIO_NOPULL;
  88              		.loc 1 652 0
  89 0054 0023     		mov	r3, #0
  90 0056 0593     		str	r3, [sp, #20]
ARM GAS  /tmp/ccv6GvnB.s 			page 14


 653:Src/main.c    ****   GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  91              		.loc 1 653 0
  92 0058 0693     		str	r3, [sp, #24]
 654:Src/main.c    ****   HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  93              		.loc 1 654 0
  94 005a 201C     		mov	r0, r4
  95 005c 03A9     		add	r1, sp, #12
  96 005e FFF7FEFF 		bl	HAL_GPIO_Init
  97              	.LVL1:
 655:Src/main.c    **** }
  98              		.loc 1 655 0
  99 0062 09B0     		add	sp, sp, #36
 100              		@ sp needed
 101 0064 30BD     		pop	{r4, r5, pc}
 102              	.L3:
 103 0066 C046     		.align	2
 104              	.L2:
 105 0068 00100240 		.word	1073876992
 106              		.cfi_endproc
 107              	.LFE45:
 109              		.section	.text.USER_TIM2_Init,"ax",%progbits
 110              		.align	2
 111              		.code	16
 112              		.thumb_func
 114              	USER_TIM2_Init:
 115              	.LFB42:
 513:Src/main.c    **** static void USER_TIM2_Init(void) {
 116              		.loc 1 513 0
 117              		.cfi_startproc
 118 0000 70B5     		push	{r4, r5, r6, lr}
 119              	.LCFI2:
 120              		.cfi_def_cfa_offset 16
 121              		.cfi_offset 4, -16
 122              		.cfi_offset 5, -12
 123              		.cfi_offset 6, -8
 124              		.cfi_offset 14, -4
 125 0002 8AB0     		sub	sp, sp, #40
 126              	.LCFI3:
 127              		.cfi_def_cfa_offset 56
 128              	.LBB11:
 514:Src/main.c    **** 	__HAL_RCC_TIM2_CLK_ENABLE();
 129              		.loc 1 514 0
 130 0004 194B     		ldr	r3, .L5
 131 0006 DA69     		ldr	r2, [r3, #28]
 132 0008 0126     		mov	r6, #1
 133 000a 3243     		orr	r2, r6
 134 000c DA61     		str	r2, [r3, #28]
 135 000e DB69     		ldr	r3, [r3, #28]
 136 0010 3340     		and	r3, r6
 137 0012 0093     		str	r3, [sp]
 138 0014 009B     		ldr	r3, [sp]
 139              	.LBE11:
 520:Src/main.c    **** 	htim2.Instance = TIM2;
 140              		.loc 1 520 0
 141 0016 164C     		ldr	r4, .L5+4
 142 0018 8023     		mov	r3, #128
 143 001a DB05     		lsl	r3, r3, #23
ARM GAS  /tmp/ccv6GvnB.s 			page 15


 144 001c 2360     		str	r3, [r4]
 521:Src/main.c    **** 	htim2.Init.Prescaler = 0;
 145              		.loc 1 521 0
 146 001e 0025     		mov	r5, #0
 147 0020 6560     		str	r5, [r4, #4]
 522:Src/main.c    **** 	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 148              		.loc 1 522 0
 149 0022 A560     		str	r5, [r4, #8]
 523:Src/main.c    **** 	htim2.Init.Period = 3200;
 150              		.loc 1 523 0
 151 0024 C823     		mov	r3, #200
 152 0026 1B01     		lsl	r3, r3, #4
 153 0028 E360     		str	r3, [r4, #12]
 524:Src/main.c    **** 	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 154              		.loc 1 524 0
 155 002a 8023     		mov	r3, #128
 156 002c 9B00     		lsl	r3, r3, #2
 157 002e 2361     		str	r3, [r4, #16]
 525:Src/main.c    **** 	HAL_TIM_Base_Init(&htim2);
 158              		.loc 1 525 0
 159 0030 201C     		mov	r0, r4
 160 0032 FFF7FEFF 		bl	HAL_TIM_Base_Init
 161              	.LVL2:
 527:Src/main.c    **** 	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 162              		.loc 1 527 0
 163 0036 0895     		str	r5, [sp, #32]
 528:Src/main.c    **** 	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 164              		.loc 1 528 0
 165 0038 0995     		str	r5, [sp, #36]
 529:Src/main.c    **** 	HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);
 166              		.loc 1 529 0
 167 003a 201C     		mov	r0, r4
 168 003c 08A9     		add	r1, sp, #32
 169 003e FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 170              	.LVL3:
 531:Src/main.c    **** 	sConfigOC.OCMode = TIM_OCMODE_PWM1;
 171              		.loc 1 531 0
 172 0042 6023     		mov	r3, #96
 173 0044 0193     		str	r3, [sp, #4]
 532:Src/main.c    **** 	sConfigOC.Pulse = 1;
 174              		.loc 1 532 0
 175 0046 0296     		str	r6, [sp, #8]
 533:Src/main.c    **** 	sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
 176              		.loc 1 533 0
 177 0048 0223     		mov	r3, #2
 178 004a 0393     		str	r3, [sp, #12]
 534:Src/main.c    **** 	sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 179              		.loc 1 534 0
 180 004c 0595     		str	r5, [sp, #20]
 535:Src/main.c    **** 	HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_2);
 181              		.loc 1 535 0
 182 004e 201C     		mov	r0, r4
 183 0050 01A9     		add	r1, sp, #4
 184 0052 0422     		mov	r2, #4
 185 0054 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 186              	.LVL4:
 537:Src/main.c    **** 	HAL_TIM_OnePulse_Init(&htim2, TIM_OPMODE_SINGLE);
ARM GAS  /tmp/ccv6GvnB.s 			page 16


 187              		.loc 1 537 0
 188 0058 201C     		mov	r0, r4
 189 005a 0821     		mov	r1, #8
 190 005c FFF7FEFF 		bl	HAL_TIM_OnePulse_Init
 191              	.LVL5:
 538:Src/main.c    **** 	HAL_TIM_MspPostInit(&htim2);
 192              		.loc 1 538 0
 193 0060 201C     		mov	r0, r4
 194 0062 FFF7FEFF 		bl	HAL_TIM_MspPostInit
 195              	.LVL6:
 539:Src/main.c    **** }
 196              		.loc 1 539 0
 197 0066 0AB0     		add	sp, sp, #40
 198              		@ sp needed
 199 0068 70BD     		pop	{r4, r5, r6, pc}
 200              	.L6:
 201 006a C046     		.align	2
 202              	.L5:
 203 006c 00100240 		.word	1073876992
 204 0070 00000000 		.word	htim2
 205              		.cfi_endproc
 206              	.LFE42:
 208              		.section	.text.MX_DMA_Init,"ax",%progbits
 209              		.align	2
 210              		.code	16
 211              		.thumb_func
 213              	MX_DMA_Init:
 214              	.LFB39:
 469:Src/main.c    **** {
 215              		.loc 1 469 0
 216              		.cfi_startproc
 217 0000 00B5     		push	{lr}
 218              	.LCFI4:
 219              		.cfi_def_cfa_offset 4
 220              		.cfi_offset 14, -4
 221 0002 83B0     		sub	sp, sp, #12
 222              	.LCFI5:
 223              		.cfi_def_cfa_offset 16
 224              	.LBB12:
 471:Src/main.c    ****   __HAL_RCC_DMA1_CLK_ENABLE();
 225              		.loc 1 471 0
 226 0004 094B     		ldr	r3, .L8
 227 0006 5969     		ldr	r1, [r3, #20]
 228 0008 0122     		mov	r2, #1
 229 000a 1143     		orr	r1, r2
 230 000c 5961     		str	r1, [r3, #20]
 231 000e 5B69     		ldr	r3, [r3, #20]
 232 0010 1A40     		and	r2, r3
 233 0012 0192     		str	r2, [sp, #4]
 234 0014 019B     		ldr	r3, [sp, #4]
 235              	.LBE12:
 475:Src/main.c    ****   HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 236              		.loc 1 475 0
 237 0016 0920     		mov	r0, #9
 238 0018 0021     		mov	r1, #0
 239 001a 0022     		mov	r2, #0
 240 001c FFF7FEFF 		bl	HAL_NVIC_SetPriority
ARM GAS  /tmp/ccv6GvnB.s 			page 17


 241              	.LVL7:
 476:Src/main.c    ****   HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 242              		.loc 1 476 0
 243 0020 0920     		mov	r0, #9
 244 0022 FFF7FEFF 		bl	HAL_NVIC_EnableIRQ
 245              	.LVL8:
 478:Src/main.c    **** }
 246              		.loc 1 478 0
 247 0026 03B0     		add	sp, sp, #12
 248              		@ sp needed
 249 0028 00BD     		pop	{pc}
 250              	.L9:
 251 002a C046     		.align	2
 252              	.L8:
 253 002c 00100240 		.word	1073876992
 254              		.cfi_endproc
 255              	.LFE39:
 257              		.section	.text.dfu_otter_bootloader,"ax",%progbits
 258              		.align	2
 259              		.global	dfu_otter_bootloader
 260              		.code	16
 261              		.thumb_func
 263              	dfu_otter_bootloader:
 264              	.LFB34:
  99:Src/main.c    **** {
 265              		.loc 1 99 0
 266              		.cfi_startproc
 100:Src/main.c    ****   *((unsigned long *)0x20003FF0) = 0xDEADBEEF;
 267              		.loc 1 100 0
 268 0000 054A     		ldr	r2, .L12
 269 0002 064B     		ldr	r3, .L12+4
 270 0004 1A60     		str	r2, [r3]
 271              	.LBB21:
 272              	.LBB22:
 273              	.LBB23:
 274              	.LBB24:
 275              		.file 2 "Drivers/CMSIS/Include/cmsis_gcc.h"
   1:Drivers/CMSIS/Include/cmsis_gcc.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @brief    CMSIS Cortex-M Core Function/Instruction Header File
   4:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/cmsis_gcc.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/cmsis_gcc.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/cmsis_gcc.h **** 
   9:Drivers/CMSIS/Include/cmsis_gcc.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/cmsis_gcc.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/cmsis_gcc.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/cmsis_gcc.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/cmsis_gcc.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/cmsis_gcc.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/cmsis_gcc.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/cmsis_gcc.h ****      specific prior written permission.
  20:Drivers/CMSIS/Include/cmsis_gcc.h ****    *
ARM GAS  /tmp/ccv6GvnB.s 			page 18


  21:Drivers/CMSIS/Include/cmsis_gcc.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/cmsis_gcc.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/cmsis_gcc.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/cmsis_gcc.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/cmsis_gcc.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/cmsis_gcc.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/cmsis_gcc.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/cmsis_gcc.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/cmsis_gcc.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:Drivers/CMSIS/Include/cmsis_gcc.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  34:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  35:Drivers/CMSIS/Include/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  36:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_H
  37:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  38:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ignore some GCC warnings */
  39:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined ( __GNUC__ )
  40:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic push
  41:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
  42:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  43:Drivers/CMSIS/Include/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  44:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
  45:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  46:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  47:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
  48:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
  49:Drivers/CMSIS/Include/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
  50:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
  51:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  52:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  53:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  54:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
  55:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
  56:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
  57:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  58:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
  59:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  60:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
  61:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  62:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  63:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  64:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  65:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
  66:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  67:Drivers/CMSIS/Include/cmsis_gcc.h ****   Can only be executed in Privileged modes.
  68:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  69:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
  70:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  71:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
  72:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  73:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  74:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  75:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  76:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Control Register
  77:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the Control Register.
ARM GAS  /tmp/ccv6GvnB.s 			page 19


  78:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Control Register value
  79:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  80:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
  81:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  82:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
  83:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  84:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
  85:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
  86:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  87:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  88:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  89:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
  90:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Control Register
  91:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
  92:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
  93:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
  94:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
  95:Drivers/CMSIS/Include/cmsis_gcc.h **** {
  96:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
  97:Drivers/CMSIS/Include/cmsis_gcc.h **** }
  98:Drivers/CMSIS/Include/cmsis_gcc.h **** 
  99:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 100:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 101:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get IPSR Register
 102:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 103:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               IPSR Register value
 104:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 105:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
 106:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 107:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 108:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 109:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 110:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 111:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 112:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 113:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 114:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 115:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get APSR Register
 116:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 117:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               APSR Register value
 118:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 119:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
 120:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 121:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 122:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 123:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 124:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 125:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 126:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 127:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 128:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 129:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get xPSR Register
 130:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 131:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 132:Drivers/CMSIS/Include/cmsis_gcc.h ****     \return               xPSR Register value
 133:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 134:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
ARM GAS  /tmp/ccv6GvnB.s 			page 20


 135:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 136:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 137:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 138:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 139:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 140:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 141:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 142:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 143:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 144:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 145:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 146:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               PSP Register value
 147:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 148:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
 149:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 150:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 151:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 152:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 153:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 154:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 155:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 156:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 157:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 158:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 159:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 160:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 161:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 162:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
 163:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 164:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 165:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 166:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 167:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 168:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 169:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 170:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 171:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               MSP Register value
 172:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 173:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
 174:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 175:Drivers/CMSIS/Include/cmsis_gcc.h ****   register uint32_t result;
 176:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 177:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
 178:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 179:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 180:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 181:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 182:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 183:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 184:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 185:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 186:Drivers/CMSIS/Include/cmsis_gcc.h ****     \param [in]    topOfMainStack  Main Stack Pointer value to set
 187:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 188:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
 189:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 190:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
 191:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccv6GvnB.s 			page 21


 192:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 193:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 194:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 195:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Priority Mask
 196:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 197:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Priority Mask value
 198:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 199:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
 200:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 201:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 202:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 203:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) );
 204:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 205:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 206:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 207:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 208:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 209:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Priority Mask
 210:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 211:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 212:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 213:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
 214:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 215:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 216:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 217:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 218:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 219:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M >= 0x03U)
 220:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 221:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 222:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Enable FIQ
 223:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 224:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 225:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 226:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
 227:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 228:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 229:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 230:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 231:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 232:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 233:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Disable FIQ
 234:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 235:Drivers/CMSIS/Include/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 236:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 237:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
 238:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 239:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 240:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 241:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 242:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 243:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 244:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Base Priority
 245:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 246:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Base Priority register value
 247:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 248:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
ARM GAS  /tmp/ccv6GvnB.s 			page 22


 249:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 250:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 251:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 252:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 253:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 254:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 255:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 256:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 257:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 258:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority
 259:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 260:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 261:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 262:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
 263:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 264:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 265:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 266:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 267:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 268:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 269:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 270:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 271:Drivers/CMSIS/Include/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 272:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 273:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 274:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
 275:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 276:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
 277:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 278:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 279:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 280:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 281:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get Fault Mask
 282:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 283:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Fault Mask register value
 284:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 285:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
 286:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 287:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 288:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 289:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 290:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 291:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 292:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 293:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 294:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 295:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set Fault Mask
 296:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 297:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 298:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 299:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
 300:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 301:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 302:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 303:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 304:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M >= 0x03U) */
 305:Drivers/CMSIS/Include/cmsis_gcc.h **** 
ARM GAS  /tmp/ccv6GvnB.s 			page 23


 306:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 307:Drivers/CMSIS/Include/cmsis_gcc.h **** #if       (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U)
 308:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 309:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 310:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Get FPSCR
 311:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 312:Drivers/CMSIS/Include/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 313:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 314:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
 315:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 316:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 317:Drivers/CMSIS/Include/cmsis_gcc.h ****   uint32_t result;
 318:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 319:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 320:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 321:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 322:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 323:Drivers/CMSIS/Include/cmsis_gcc.h ****   return(result);
 324:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 325:Drivers/CMSIS/Include/cmsis_gcc.h ****    return(0);
 326:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 327:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 328:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 329:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 330:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 331:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Set FPSCR
 332:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 333:Drivers/CMSIS/Include/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 334:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 335:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
 336:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 337:Drivers/CMSIS/Include/cmsis_gcc.h **** #if (__FPU_PRESENT == 1U) && (__FPU_USED == 1U)
 338:Drivers/CMSIS/Include/cmsis_gcc.h ****   /* Empty asm statement works as a scheduling barrier */
 339:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 340:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
 341:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("");
 342:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 343:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 344:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 345:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif /* (__CORTEX_M == 0x04U) || (__CORTEX_M == 0x07U) */
 346:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 347:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 348:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 349:Drivers/CMSIS/Include/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 350:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 351:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 352:Drivers/CMSIS/Include/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 353:Drivers/CMSIS/Include/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 354:Drivers/CMSIS/Include/cmsis_gcc.h ****   Access to dedicated instructions
 355:Drivers/CMSIS/Include/cmsis_gcc.h ****   @{
 356:Drivers/CMSIS/Include/cmsis_gcc.h **** */
 357:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 358:Drivers/CMSIS/Include/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 359:Drivers/CMSIS/Include/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 360:Drivers/CMSIS/Include/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 361:Drivers/CMSIS/Include/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 362:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
ARM GAS  /tmp/ccv6GvnB.s 			page 24


 363:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 364:Drivers/CMSIS/Include/cmsis_gcc.h **** #else
 365:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 366:Drivers/CMSIS/Include/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 367:Drivers/CMSIS/Include/cmsis_gcc.h **** #endif
 368:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 369:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 370:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   No Operation
 371:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 372:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 373:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
 374:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 376:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 377:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 378:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 379:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 380:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Interrupt
 381:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 382:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 383:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
 384:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 385:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfi");
 386:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 387:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 388:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 389:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 390:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Wait For Event
 391:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 392:Drivers/CMSIS/Include/cmsis_gcc.h ****     a low-power state until one of a number of events occurs.
 393:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 394:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
 395:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 396:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("wfe");
 397:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 398:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 399:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 400:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 401:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Send Event
 402:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 403:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 404:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
 405:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 406:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("sev");
 407:Drivers/CMSIS/Include/cmsis_gcc.h **** }
 408:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 409:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 410:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 411:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 412:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 413:Drivers/CMSIS/Include/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 414:Drivers/CMSIS/Include/cmsis_gcc.h ****            after the instruction has been completed.
 415:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 416:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
 417:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 418:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 419:Drivers/CMSIS/Include/cmsis_gcc.h **** }
ARM GAS  /tmp/ccv6GvnB.s 			page 25


 420:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 421:Drivers/CMSIS/Include/cmsis_gcc.h **** 
 422:Drivers/CMSIS/Include/cmsis_gcc.h **** /**
 423:Drivers/CMSIS/Include/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 424:Drivers/CMSIS/Include/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 425:Drivers/CMSIS/Include/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 426:Drivers/CMSIS/Include/cmsis_gcc.h ****  */
 427:Drivers/CMSIS/Include/cmsis_gcc.h **** __attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
 428:Drivers/CMSIS/Include/cmsis_gcc.h **** {
 429:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 276              		.loc 2 429 0
 277              	@ 429 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 278 0006 BFF34F8F 		dsb 0xF
 279              	@ 0 "" 2
 280              		.code	16
 281              	.LBE24:
 282              	.LBE23:
 283              		.file 3 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V4.30
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     20. October 2015
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /* Copyright (c) 2009 - 2015 ARM LIMITED
   8:Drivers/CMSIS/Include/core_cm0.h **** 
   9:Drivers/CMSIS/Include/core_cm0.h ****    All rights reserved.
  10:Drivers/CMSIS/Include/core_cm0.h ****    Redistribution and use in source and binary forms, with or without
  11:Drivers/CMSIS/Include/core_cm0.h ****    modification, are permitted provided that the following conditions are met:
  12:Drivers/CMSIS/Include/core_cm0.h ****    - Redistributions of source code must retain the above copyright
  13:Drivers/CMSIS/Include/core_cm0.h ****      notice, this list of conditions and the following disclaimer.
  14:Drivers/CMSIS/Include/core_cm0.h ****    - Redistributions in binary form must reproduce the above copyright
  15:Drivers/CMSIS/Include/core_cm0.h ****      notice, this list of conditions and the following disclaimer in the
  16:Drivers/CMSIS/Include/core_cm0.h ****      documentation and/or other materials provided with the distribution.
  17:Drivers/CMSIS/Include/core_cm0.h ****    - Neither the name of ARM nor the names of its contributors may be used
  18:Drivers/CMSIS/Include/core_cm0.h ****      to endorse or promote products derived from this software without
  19:Drivers/CMSIS/Include/core_cm0.h ****      specific prior written permission.
  20:Drivers/CMSIS/Include/core_cm0.h ****    *
  21:Drivers/CMSIS/Include/core_cm0.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:Drivers/CMSIS/Include/core_cm0.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:Drivers/CMSIS/Include/core_cm0.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:Drivers/CMSIS/Include/core_cm0.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  25:Drivers/CMSIS/Include/core_cm0.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:Drivers/CMSIS/Include/core_cm0.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:Drivers/CMSIS/Include/core_cm0.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:Drivers/CMSIS/Include/core_cm0.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:Drivers/CMSIS/Include/core_cm0.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:Drivers/CMSIS/Include/core_cm0.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:Drivers/CMSIS/Include/core_cm0.h ****    POSSIBILITY OF SUCH DAMAGE.
  32:Drivers/CMSIS/Include/core_cm0.h ****    ---------------------------------------------------------------------------*/
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** 
  35:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  36:Drivers/CMSIS/Include/core_cm0.h ****  #pragma system_include         /* treat file as system include file for MISRA check */
  37:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  38:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  39:Drivers/CMSIS/Include/core_cm0.h **** #endif
ARM GAS  /tmp/ccv6GvnB.s 			page 26


  40:Drivers/CMSIS/Include/core_cm0.h **** 
  41:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  42:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  45:Drivers/CMSIS/Include/core_cm0.h **** 
  46:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  47:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  48:Drivers/CMSIS/Include/core_cm0.h **** #endif
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h **** /**
  51:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  52:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  55:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  56:Drivers/CMSIS/Include/core_cm0.h **** 
  57:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  58:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  59:Drivers/CMSIS/Include/core_cm0.h **** 
  60:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  61:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  62:Drivers/CMSIS/Include/core_cm0.h ****  */
  63:Drivers/CMSIS/Include/core_cm0.h **** 
  64:Drivers/CMSIS/Include/core_cm0.h **** 
  65:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  66:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  67:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  68:Drivers/CMSIS/Include/core_cm0.h **** /**
  69:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  70:Drivers/CMSIS/Include/core_cm0.h ****   @{
  71:Drivers/CMSIS/Include/core_cm0.h ****  */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  74:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (0x04U)                                      /*!< [31:16] CMSIS H
  75:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (0x1EU)                                      /*!< [15:0]  CMSIS H
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  77:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )        /*!< CMSIS HAL versi
  78:Drivers/CMSIS/Include/core_cm0.h **** 
  79:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0x00U)                                      /*!< Cortex-M Core *
  80:Drivers/CMSIS/Include/core_cm0.h **** 
  81:Drivers/CMSIS/Include/core_cm0.h **** 
  82:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __CC_ARM )
  83:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  84:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  85:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static __inline
  86:Drivers/CMSIS/Include/core_cm0.h **** 
  87:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  88:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for ARM Comp
  89:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         __inline                                   /*!< inline keyword for ARM C
  90:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static __inline
  91:Drivers/CMSIS/Include/core_cm0.h **** 
  92:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  93:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for GNU Comp
  94:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for GNU C
  95:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
  96:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  /tmp/ccv6GvnB.s 			page 27


  97:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  98:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for IAR Comp
  99:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for IAR C
 100:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 101:Drivers/CMSIS/Include/core_cm0.h **** 
 102:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TMS470__ )
 103:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TI CCS C
 104:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 105:Drivers/CMSIS/Include/core_cm0.h **** 
 106:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 107:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            __asm                                      /*!< asm keyword for TASKING 
 108:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                     /*!< inline keyword for TASKI
 109:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 110:Drivers/CMSIS/Include/core_cm0.h **** 
 111:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 112:Drivers/CMSIS/Include/core_cm0.h ****   #define __packed
 113:Drivers/CMSIS/Include/core_cm0.h ****   #define __ASM            _asm                                      /*!< asm keyword for COSMIC Co
 114:Drivers/CMSIS/Include/core_cm0.h ****   #define __INLINE         inline                                    /*!< inline keyword for COSMIC
 115:Drivers/CMSIS/Include/core_cm0.h ****   #define __STATIC_INLINE  static inline
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** #else
 118:Drivers/CMSIS/Include/core_cm0.h ****   #error Unknown compiler
 119:Drivers/CMSIS/Include/core_cm0.h **** #endif
 120:Drivers/CMSIS/Include/core_cm0.h **** 
 121:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
 122:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
 123:Drivers/CMSIS/Include/core_cm0.h **** */
 124:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
 127:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
 128:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 129:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 130:Drivers/CMSIS/Include/core_cm0.h **** 
 131:Drivers/CMSIS/Include/core_cm0.h **** #elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
 132:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
 133:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 134:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 135:Drivers/CMSIS/Include/core_cm0.h **** 
 136:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
 137:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
 138:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 139:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 140:Drivers/CMSIS/Include/core_cm0.h **** 
 141:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
 142:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
 143:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 144:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 145:Drivers/CMSIS/Include/core_cm0.h **** 
 146:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TMS470__ )
 147:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 148:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 149:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 152:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 153:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
ARM GAS  /tmp/ccv6GvnB.s 			page 28


 154:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 155:Drivers/CMSIS/Include/core_cm0.h **** 
 156:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 157:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 158:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 159:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 160:Drivers/CMSIS/Include/core_cm0.h **** 
 161:Drivers/CMSIS/Include/core_cm0.h **** #endif
 162:Drivers/CMSIS/Include/core_cm0.h **** 
 163:Drivers/CMSIS/Include/core_cm0.h **** #include "core_cmInstr.h"                /* Core Instruction Access */
 164:Drivers/CMSIS/Include/core_cm0.h **** #include "core_cmFunc.h"                 /* Core Function Access */
 165:Drivers/CMSIS/Include/core_cm0.h **** 
 166:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 167:Drivers/CMSIS/Include/core_cm0.h **** }
 168:Drivers/CMSIS/Include/core_cm0.h **** #endif
 169:Drivers/CMSIS/Include/core_cm0.h **** 
 170:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 175:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 176:Drivers/CMSIS/Include/core_cm0.h **** 
 177:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 178:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 179:Drivers/CMSIS/Include/core_cm0.h **** #endif
 180:Drivers/CMSIS/Include/core_cm0.h **** 
 181:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 182:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 183:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 184:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 185:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 186:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 187:Drivers/CMSIS/Include/core_cm0.h **** 
 188:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 189:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 190:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 191:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 192:Drivers/CMSIS/Include/core_cm0.h **** 
 193:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 194:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 195:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 196:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 197:Drivers/CMSIS/Include/core_cm0.h **** #endif
 198:Drivers/CMSIS/Include/core_cm0.h **** 
 199:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 200:Drivers/CMSIS/Include/core_cm0.h **** /**
 201:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
 202:Drivers/CMSIS/Include/core_cm0.h **** 
 203:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 204:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 205:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 206:Drivers/CMSIS/Include/core_cm0.h **** */
 207:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 208:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 209:Drivers/CMSIS/Include/core_cm0.h **** #else
 210:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
ARM GAS  /tmp/ccv6GvnB.s 			page 29


 211:Drivers/CMSIS/Include/core_cm0.h **** #endif
 212:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 214:Drivers/CMSIS/Include/core_cm0.h **** 
 215:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 216:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 217:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 218:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 219:Drivers/CMSIS/Include/core_cm0.h **** 
 220:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** 
 223:Drivers/CMSIS/Include/core_cm0.h **** 
 224:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 225:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 226:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 227:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 228:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 229:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 230:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 231:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 232:Drivers/CMSIS/Include/core_cm0.h **** /**
 233:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 234:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 235:Drivers/CMSIS/Include/core_cm0.h **** */
 236:Drivers/CMSIS/Include/core_cm0.h **** 
 237:Drivers/CMSIS/Include/core_cm0.h **** /**
 238:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 239:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 240:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 241:Drivers/CMSIS/Include/core_cm0.h ****   @{
 242:Drivers/CMSIS/Include/core_cm0.h ****  */
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 257:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 258:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
 259:Drivers/CMSIS/Include/core_cm0.h **** 
 260:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 261:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 262:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 263:Drivers/CMSIS/Include/core_cm0.h **** 
 264:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
ARM GAS  /tmp/ccv6GvnB.s 			page 30


 268:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** 
 274:Drivers/CMSIS/Include/core_cm0.h **** /**
 275:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 276:Drivers/CMSIS/Include/core_cm0.h ****  */
 277:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 278:Drivers/CMSIS/Include/core_cm0.h **** {
 279:Drivers/CMSIS/Include/core_cm0.h ****   struct
 280:Drivers/CMSIS/Include/core_cm0.h ****   {
 281:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 282:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 283:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 284:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 285:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 286:Drivers/CMSIS/Include/core_cm0.h **** 
 287:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 288:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 289:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 290:Drivers/CMSIS/Include/core_cm0.h **** 
 291:Drivers/CMSIS/Include/core_cm0.h **** 
 292:Drivers/CMSIS/Include/core_cm0.h **** /**
 293:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 294:Drivers/CMSIS/Include/core_cm0.h ****  */
 295:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 296:Drivers/CMSIS/Include/core_cm0.h **** {
 297:Drivers/CMSIS/Include/core_cm0.h ****   struct
 298:Drivers/CMSIS/Include/core_cm0.h ****   {
 299:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 300:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 301:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 302:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 303:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 304:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 305:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 306:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 307:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 308:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 309:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 312:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 313:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 314:Drivers/CMSIS/Include/core_cm0.h **** 
 315:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
 316:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 317:Drivers/CMSIS/Include/core_cm0.h **** 
 318:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 319:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 320:Drivers/CMSIS/Include/core_cm0.h **** 
 321:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 322:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 323:Drivers/CMSIS/Include/core_cm0.h **** 
 324:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
ARM GAS  /tmp/ccv6GvnB.s 			page 31


 325:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 326:Drivers/CMSIS/Include/core_cm0.h **** 
 327:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 328:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 333:Drivers/CMSIS/Include/core_cm0.h ****  */
 334:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 335:Drivers/CMSIS/Include/core_cm0.h **** {
 336:Drivers/CMSIS/Include/core_cm0.h ****   struct
 337:Drivers/CMSIS/Include/core_cm0.h ****   {
 338:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 339:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 340:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 341:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 342:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 343:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 344:Drivers/CMSIS/Include/core_cm0.h **** 
 345:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 346:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 347:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 348:Drivers/CMSIS/Include/core_cm0.h **** 
 349:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 350:Drivers/CMSIS/Include/core_cm0.h **** 
 351:Drivers/CMSIS/Include/core_cm0.h **** 
 352:Drivers/CMSIS/Include/core_cm0.h **** /**
 353:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 354:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 355:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 356:Drivers/CMSIS/Include/core_cm0.h ****   @{
 357:Drivers/CMSIS/Include/core_cm0.h ****  */
 358:Drivers/CMSIS/Include/core_cm0.h **** 
 359:Drivers/CMSIS/Include/core_cm0.h **** /**
 360:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 361:Drivers/CMSIS/Include/core_cm0.h ****  */
 362:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 363:Drivers/CMSIS/Include/core_cm0.h **** {
 364:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 365:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 366:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 367:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 368:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 369:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 370:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 371:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 372:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
 373:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 374:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 375:Drivers/CMSIS/Include/core_cm0.h **** 
 376:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 377:Drivers/CMSIS/Include/core_cm0.h **** 
 378:Drivers/CMSIS/Include/core_cm0.h **** 
 379:Drivers/CMSIS/Include/core_cm0.h **** /**
 380:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 381:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
ARM GAS  /tmp/ccv6GvnB.s 			page 32


 382:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 383:Drivers/CMSIS/Include/core_cm0.h ****   @{
 384:Drivers/CMSIS/Include/core_cm0.h ****  */
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** /**
 387:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 388:Drivers/CMSIS/Include/core_cm0.h ****  */
 389:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 390:Drivers/CMSIS/Include/core_cm0.h **** {
 391:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 392:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 393:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 394:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 395:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 396:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 397:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 398:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 399:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 400:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 405:Drivers/CMSIS/Include/core_cm0.h **** 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 408:Drivers/CMSIS/Include/core_cm0.h **** 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 411:Drivers/CMSIS/Include/core_cm0.h **** 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 414:Drivers/CMSIS/Include/core_cm0.h **** 
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 421:Drivers/CMSIS/Include/core_cm0.h **** 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 424:Drivers/CMSIS/Include/core_cm0.h **** 
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** 
 434:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 435:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 438:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
ARM GAS  /tmp/ccv6GvnB.s 			page 33


 439:Drivers/CMSIS/Include/core_cm0.h **** 
 440:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 441:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 442:Drivers/CMSIS/Include/core_cm0.h **** 
 443:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 444:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 445:Drivers/CMSIS/Include/core_cm0.h **** 
 446:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 447:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 448:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 449:Drivers/CMSIS/Include/core_cm0.h **** 
 450:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 451:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 452:Drivers/CMSIS/Include/core_cm0.h **** 
 453:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 454:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 458:Drivers/CMSIS/Include/core_cm0.h **** 
 459:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 461:Drivers/CMSIS/Include/core_cm0.h **** 
 462:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 471:Drivers/CMSIS/Include/core_cm0.h **** 
 472:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 473:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 475:Drivers/CMSIS/Include/core_cm0.h **** 
 476:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 477:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 478:Drivers/CMSIS/Include/core_cm0.h **** 
 479:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 480:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 482:Drivers/CMSIS/Include/core_cm0.h **** 
 483:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 484:Drivers/CMSIS/Include/core_cm0.h **** 
 485:Drivers/CMSIS/Include/core_cm0.h **** 
 486:Drivers/CMSIS/Include/core_cm0.h **** /**
 487:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 488:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 489:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 490:Drivers/CMSIS/Include/core_cm0.h ****   @{
 491:Drivers/CMSIS/Include/core_cm0.h ****  */
 492:Drivers/CMSIS/Include/core_cm0.h **** 
 493:Drivers/CMSIS/Include/core_cm0.h **** /**
 494:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 495:Drivers/CMSIS/Include/core_cm0.h ****  */
ARM GAS  /tmp/ccv6GvnB.s 			page 34


 496:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 497:Drivers/CMSIS/Include/core_cm0.h **** {
 498:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 499:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 500:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 501:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 502:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 503:Drivers/CMSIS/Include/core_cm0.h **** 
 504:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 505:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 506:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 507:Drivers/CMSIS/Include/core_cm0.h **** 
 508:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 509:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 510:Drivers/CMSIS/Include/core_cm0.h **** 
 511:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 512:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 513:Drivers/CMSIS/Include/core_cm0.h **** 
 514:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 515:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 516:Drivers/CMSIS/Include/core_cm0.h **** 
 517:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 518:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 519:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 520:Drivers/CMSIS/Include/core_cm0.h **** 
 521:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 522:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 523:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 526:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 527:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 528:Drivers/CMSIS/Include/core_cm0.h **** 
 529:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 530:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 531:Drivers/CMSIS/Include/core_cm0.h **** 
 532:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 533:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 534:Drivers/CMSIS/Include/core_cm0.h **** 
 535:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 536:Drivers/CMSIS/Include/core_cm0.h **** 
 537:Drivers/CMSIS/Include/core_cm0.h **** 
 538:Drivers/CMSIS/Include/core_cm0.h **** /**
 539:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 540:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 541:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 542:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 543:Drivers/CMSIS/Include/core_cm0.h ****   @{
 544:Drivers/CMSIS/Include/core_cm0.h ****  */
 545:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /**
 549:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 550:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 551:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 552:Drivers/CMSIS/Include/core_cm0.h ****   @{
ARM GAS  /tmp/ccv6GvnB.s 			page 35


 553:Drivers/CMSIS/Include/core_cm0.h ****  */
 554:Drivers/CMSIS/Include/core_cm0.h **** 
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 557:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 558:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field.
 559:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 560:Drivers/CMSIS/Include/core_cm0.h **** */
 561:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    ((value << field ## _Pos) & field ## _Msk)
 562:Drivers/CMSIS/Include/core_cm0.h **** 
 563:Drivers/CMSIS/Include/core_cm0.h **** /**
 564:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 565:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 566:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register.
 567:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 568:Drivers/CMSIS/Include/core_cm0.h **** */
 569:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    ((value & field ## _Msk) >> field ## _Pos)
 570:Drivers/CMSIS/Include/core_cm0.h **** 
 571:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 572:Drivers/CMSIS/Include/core_cm0.h **** 
 573:Drivers/CMSIS/Include/core_cm0.h **** 
 574:Drivers/CMSIS/Include/core_cm0.h **** /**
 575:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 576:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 577:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 578:Drivers/CMSIS/Include/core_cm0.h ****   @{
 579:Drivers/CMSIS/Include/core_cm0.h ****  */
 580:Drivers/CMSIS/Include/core_cm0.h **** 
 581:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Cortex-M0 Hardware */
 582:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 583:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 584:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 585:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 586:Drivers/CMSIS/Include/core_cm0.h **** 
 587:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 588:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 589:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 590:Drivers/CMSIS/Include/core_cm0.h **** 
 591:Drivers/CMSIS/Include/core_cm0.h **** 
 592:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 593:Drivers/CMSIS/Include/core_cm0.h **** 
 594:Drivers/CMSIS/Include/core_cm0.h **** 
 595:Drivers/CMSIS/Include/core_cm0.h **** 
 596:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 597:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 598:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 599:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 600:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
 601:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 602:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 603:Drivers/CMSIS/Include/core_cm0.h **** /**
 604:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 605:Drivers/CMSIS/Include/core_cm0.h **** */
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** 
 609:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
ARM GAS  /tmp/ccv6GvnB.s 			page 36


 610:Drivers/CMSIS/Include/core_cm0.h **** /**
 611:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 612:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 613:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 614:Drivers/CMSIS/Include/core_cm0.h ****   @{
 615:Drivers/CMSIS/Include/core_cm0.h ****  */
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under ARMv6M                   */
 618:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
 619:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 620:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 621:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 622:Drivers/CMSIS/Include/core_cm0.h **** 
 623:Drivers/CMSIS/Include/core_cm0.h **** 
 624:Drivers/CMSIS/Include/core_cm0.h **** /**
 625:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable External Interrupt
 626:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device-specific interrupt in the NVIC interrupt controller.
 627:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 628:Drivers/CMSIS/Include/core_cm0.h ****  */
 629:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
 630:Drivers/CMSIS/Include/core_cm0.h **** {
 631:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 632:Drivers/CMSIS/Include/core_cm0.h **** }
 633:Drivers/CMSIS/Include/core_cm0.h **** 
 634:Drivers/CMSIS/Include/core_cm0.h **** 
 635:Drivers/CMSIS/Include/core_cm0.h **** /**
 636:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable External Interrupt
 637:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device-specific interrupt in the NVIC interrupt controller.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 643:Drivers/CMSIS/Include/core_cm0.h **** }
 644:Drivers/CMSIS/Include/core_cm0.h **** 
 645:Drivers/CMSIS/Include/core_cm0.h **** 
 646:Drivers/CMSIS/Include/core_cm0.h **** /**
 647:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 648:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the pending register in the NVIC and returns the pending bit for the specified int
 649:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 650:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 651:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 652:Drivers/CMSIS/Include/core_cm0.h ****  */
 653:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
 654:Drivers/CMSIS/Include/core_cm0.h **** {
 655:Drivers/CMSIS/Include/core_cm0.h ****   return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL
 656:Drivers/CMSIS/Include/core_cm0.h **** }
 657:Drivers/CMSIS/Include/core_cm0.h **** 
 658:Drivers/CMSIS/Include/core_cm0.h **** 
 659:Drivers/CMSIS/Include/core_cm0.h **** /**
 660:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 661:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of an external interrupt.
 662:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number. Value cannot be negative.
 663:Drivers/CMSIS/Include/core_cm0.h ****  */
 664:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
 665:Drivers/CMSIS/Include/core_cm0.h **** {
 666:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
ARM GAS  /tmp/ccv6GvnB.s 			page 37


 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of an external interrupt.
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  External interrupt number. Value cannot be negative.
 674:Drivers/CMSIS/Include/core_cm0.h ****  */
 675:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 676:Drivers/CMSIS/Include/core_cm0.h **** {
 677:Drivers/CMSIS/Include/core_cm0.h ****   NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 678:Drivers/CMSIS/Include/core_cm0.h **** }
 679:Drivers/CMSIS/Include/core_cm0.h **** 
 680:Drivers/CMSIS/Include/core_cm0.h **** 
 681:Drivers/CMSIS/Include/core_cm0.h **** /**
 682:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 683:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of an interrupt.
 684:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every core interrupt.
 685:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 686:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 687:Drivers/CMSIS/Include/core_cm0.h ****  */
 688:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 689:Drivers/CMSIS/Include/core_cm0.h **** {
 690:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 691:Drivers/CMSIS/Include/core_cm0.h ****   {
 692:Drivers/CMSIS/Include/core_cm0.h ****     SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))
 693:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 694:Drivers/CMSIS/Include/core_cm0.h ****   }
 695:Drivers/CMSIS/Include/core_cm0.h ****   else
 696:Drivers/CMSIS/Include/core_cm0.h ****   {
 697:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 698:Drivers/CMSIS/Include/core_cm0.h ****        (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
 699:Drivers/CMSIS/Include/core_cm0.h ****   }
 700:Drivers/CMSIS/Include/core_cm0.h **** }
 701:Drivers/CMSIS/Include/core_cm0.h **** 
 702:Drivers/CMSIS/Include/core_cm0.h **** 
 703:Drivers/CMSIS/Include/core_cm0.h **** /**
 704:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Priority
 705:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the priority of an interrupt.
 706:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify an external (device specific) interrupt,
 707:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify an internal (core) interrupt.
 708:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]   IRQn  Interrupt number.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \return             Interrupt Priority.
 710:Drivers/CMSIS/Include/core_cm0.h ****                       Value is aligned automatically to the implemented priority bits of the microc
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h **** 
 715:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) < 0)
 716:Drivers/CMSIS/Include/core_cm0.h ****   {
 717:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 718:Drivers/CMSIS/Include/core_cm0.h ****   }
 719:Drivers/CMSIS/Include/core_cm0.h ****   else
 720:Drivers/CMSIS/Include/core_cm0.h ****   {
 721:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U -
 722:Drivers/CMSIS/Include/core_cm0.h ****   }
 723:Drivers/CMSIS/Include/core_cm0.h **** }
ARM GAS  /tmp/ccv6GvnB.s 			page 38


 724:Drivers/CMSIS/Include/core_cm0.h **** 
 725:Drivers/CMSIS/Include/core_cm0.h **** 
 726:Drivers/CMSIS/Include/core_cm0.h **** /**
 727:Drivers/CMSIS/Include/core_cm0.h ****   \brief   System Reset
 728:Drivers/CMSIS/Include/core_cm0.h ****   \details Initiates a system reset request to reset the MCU.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void NVIC_SystemReset(void)
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   __DSB();                                                          /* Ensure all outstanding memor
 733:Drivers/CMSIS/Include/core_cm0.h ****                                                                        buffered write are completed
 734:Drivers/CMSIS/Include/core_cm0.h ****   SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 284              		.loc 3 734 0
 285 000a 054A     		ldr	r2, .L12+8
 286 000c 054B     		ldr	r3, .L12+12
 287 000e DA60     		str	r2, [r3, #12]
 288              	.LBB25:
 289              	.LBB26:
 290              		.loc 2 429 0
 291              	@ 429 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 292 0010 BFF34F8F 		dsb 0xF
 293              	@ 0 "" 2
 294              		.code	16
 295              	.L11:
 296              	.LBE26:
 297              	.LBE25:
 298              	.LBB27:
 299              	.LBB28:
 375:Drivers/CMSIS/Include/cmsis_gcc.h ****   __ASM volatile ("nop");
 300              		.loc 2 375 0
 301              	@ 375 "Drivers/CMSIS/Include/cmsis_gcc.h" 1
 302 0014 C046     		nop
 303              	@ 0 "" 2
 304              		.code	16
 305 0016 FDE7     		b	.L11
 306              	.L13:
 307              		.align	2
 308              	.L12:
 309 0018 EFBEADDE 		.word	-559038737
 310 001c F03F0020 		.word	536887280
 311 0020 0400FA05 		.word	100270084
 312 0024 00ED00E0 		.word	-536810240
 313              	.LBE28:
 314              	.LBE27:
 315              	.LBE22:
 316              	.LBE21:
 317              		.cfi_endproc
 318              	.LFE34:
 320              		.global	__aeabi_uidiv
 321              		.section	.text.HAL_TIM_PeriodElapsedCallback,"ax",%progbits
 322              		.align	2
 323              		.global	HAL_TIM_PeriodElapsedCallback
 324              		.code	16
 325              		.thumb_func
 327              	HAL_TIM_PeriodElapsedCallback:
 328              	.LFB35:
 111:Src/main.c    **** {
 329              		.loc 1 111 0
ARM GAS  /tmp/ccv6GvnB.s 			page 39


 330              		.cfi_startproc
 331              	.LVL9:
 332 0000 10B5     		push	{r4, lr}
 333              	.LCFI6:
 334              		.cfi_def_cfa_offset 8
 335              		.cfi_offset 4, -8
 336              		.cfi_offset 14, -4
 337 0002 041C     		mov	r4, r0
 112:Src/main.c    **** 	if(htim->Instance == TIM14)
 338              		.loc 1 112 0
 339 0004 154B     		ldr	r3, .L17
 340 0006 0268     		ldr	r2, [r0]
 341 0008 9A42     		cmp	r2, r3
 342 000a 10D1     		bne	.L15
 115:Src/main.c    ****     if (TIM2->CNT == 0) {
 343              		.loc 1 115 0
 344 000c 8023     		mov	r3, #128
 345 000e DB05     		lsl	r3, r3, #23
 346 0010 5B6A     		ldr	r3, [r3, #36]
 347 0012 002B     		cmp	r3, #0
 348 0014 0BD1     		bne	.L15
 116:Src/main.c    ****       TIM2->ARR = (uint32_t)(curPeriode0 / 5); // Play first channel
 349              		.loc 1 116 0
 350 0016 124B     		ldr	r3, .L17+4
 351 0018 1868     		ldr	r0, [r3]
 352              	.LVL10:
 353 001a 0521     		mov	r1, #5
 354 001c FFF7FEFF 		bl	__aeabi_uidiv
 355              	.LVL11:
 356 0020 8023     		mov	r3, #128
 357 0022 DB05     		lsl	r3, r3, #23
 358 0024 D862     		str	r0, [r3, #44]
 117:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 359              		.loc 1 117 0
 360 0026 1968     		ldr	r1, [r3]
 361 0028 0122     		mov	r2, #1
 362 002a 0A43     		orr	r2, r1
 363 002c 1A60     		str	r2, [r3]
 364              	.L15:
 120:Src/main.c    **** 	if(htim->Instance == TIM15)
 365              		.loc 1 120 0
 366 002e 2268     		ldr	r2, [r4]
 367 0030 0C4B     		ldr	r3, .L17+8
 368 0032 9A42     		cmp	r2, r3
 369 0034 10D1     		bne	.L14
 123:Src/main.c    ****     if (TIM2->CNT == 0) {
 370              		.loc 1 123 0
 371 0036 8023     		mov	r3, #128
 372 0038 DB05     		lsl	r3, r3, #23
 373 003a 5B6A     		ldr	r3, [r3, #36]
 374 003c 002B     		cmp	r3, #0
 375 003e 0BD1     		bne	.L14
 124:Src/main.c    ****     	TIM2->ARR = (uint32_t)(curPeriode1 / 10); // Play second channel with less power
 376              		.loc 1 124 0
 377 0040 094B     		ldr	r3, .L17+12
 378 0042 1868     		ldr	r0, [r3]
 379 0044 0A21     		mov	r1, #10
ARM GAS  /tmp/ccv6GvnB.s 			page 40


 380 0046 FFF7FEFF 		bl	__aeabi_uidiv
 381              	.LVL12:
 382 004a 8023     		mov	r3, #128
 383 004c DB05     		lsl	r3, r3, #23
 384 004e D862     		str	r0, [r3, #44]
 125:Src/main.c    ****     	TIM2->CR1 = TIM2->CR1 | 1;
 385              		.loc 1 125 0
 386 0050 1968     		ldr	r1, [r3]
 387 0052 0122     		mov	r2, #1
 388 0054 0A43     		orr	r2, r1
 389 0056 1A60     		str	r2, [r3]
 390              	.L14:
 128:Src/main.c    **** }
 391              		.loc 1 128 0
 392              		@ sp needed
 393              	.LVL13:
 394 0058 10BD     		pop	{r4, pc}
 395              	.L18:
 396 005a C046     		.align	2
 397              	.L17:
 398 005c 00200040 		.word	1073750016
 399 0060 00000000 		.word	.LANCHOR0
 400 0064 00400140 		.word	1073823744
 401 0068 00000000 		.word	.LANCHOR1
 402              		.cfi_endproc
 403              	.LFE35:
 405              		.section	.text._Error_Handler,"ax",%progbits
 406              		.align	2
 407              		.global	_Error_Handler
 408              		.code	16
 409              		.thumb_func
 411              	_Error_Handler:
 412              	.LFB46:
 656:Src/main.c    **** 
 657:Src/main.c    **** /* USER CODE BEGIN 4 */
 658:Src/main.c    **** 
 659:Src/main.c    **** /* USER CODE END 4 */
 660:Src/main.c    **** 
 661:Src/main.c    **** /**
 662:Src/main.c    ****   * @brief  This function is executed in case of error occurrence.
 663:Src/main.c    ****   * @param  file: The file name as string.
 664:Src/main.c    ****   * @param  line: The line in file as a number.
 665:Src/main.c    ****   * @retval None
 666:Src/main.c    ****   */
 667:Src/main.c    **** void _Error_Handler(char *file, int line)
 668:Src/main.c    **** {
 413              		.loc 1 668 0
 414              		.cfi_startproc
 415              	.LVL14:
 416              	.L20:
 417 0000 FEE7     		b	.L20
 418              		.cfi_endproc
 419              	.LFE46:
 421 0002 C046     		.section	.text.MX_DAC_Init,"ax",%progbits
 422              		.align	2
 423              		.code	16
 424              		.thumb_func
ARM GAS  /tmp/ccv6GvnB.s 			page 41


 426              	MX_DAC_Init:
 427              	.LFB44:
 599:Src/main.c    **** {
 428              		.loc 1 599 0
 429              		.cfi_startproc
 599:Src/main.c    **** {
 430              		.loc 1 599 0
 431 0000 00B5     		push	{lr}
 432              	.LCFI7:
 433              		.cfi_def_cfa_offset 4
 434              		.cfi_offset 14, -4
 435 0002 83B0     		sub	sp, sp, #12
 436              	.LCFI8:
 437              		.cfi_def_cfa_offset 16
 605:Src/main.c    ****   hdac.Instance = DAC;
 438              		.loc 1 605 0
 439 0004 0D48     		ldr	r0, .L24
 440 0006 0E4B     		ldr	r3, .L24+4
 441 0008 0360     		str	r3, [r0]
 606:Src/main.c    ****   if (HAL_DAC_Init(&hdac) != HAL_OK)
 442              		.loc 1 606 0
 443 000a FFF7FEFF 		bl	HAL_DAC_Init
 444              	.LVL15:
 445 000e 0028     		cmp	r0, #0
 446 0010 04D0     		beq	.L22
 608:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 447              		.loc 1 608 0
 448 0012 0C48     		ldr	r0, .L24+8
 449 0014 9821     		mov	r1, #152
 450 0016 8900     		lsl	r1, r1, #2
 451 0018 FFF7FEFF 		bl	_Error_Handler
 452              	.LVL16:
 453              	.L22:
 613:Src/main.c    ****   sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
 454              		.loc 1 613 0
 455 001c 0023     		mov	r3, #0
 456 001e 0093     		str	r3, [sp]
 614:Src/main.c    ****   sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
 457              		.loc 1 614 0
 458 0020 0193     		str	r3, [sp, #4]
 615:Src/main.c    ****   if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
 459              		.loc 1 615 0
 460 0022 0648     		ldr	r0, .L24
 461 0024 6946     		mov	r1, sp
 462 0026 0022     		mov	r2, #0
 463 0028 FFF7FEFF 		bl	HAL_DAC_ConfigChannel
 464              	.LVL17:
 465 002c 0028     		cmp	r0, #0
 466 002e 03D0     		beq	.L21
 617:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 467              		.loc 1 617 0
 468 0030 0448     		ldr	r0, .L24+8
 469 0032 0549     		ldr	r1, .L24+12
 470 0034 FFF7FEFF 		bl	_Error_Handler
 471              	.LVL18:
 472              	.L21:
 620:Src/main.c    **** }
ARM GAS  /tmp/ccv6GvnB.s 			page 42


 473              		.loc 1 620 0
 474 0038 03B0     		add	sp, sp, #12
 475              		@ sp needed
 476 003a 00BD     		pop	{pc}
 477              	.L25:
 478              		.align	2
 479              	.L24:
 480 003c 00000000 		.word	hdac
 481 0040 00740040 		.word	1073771520
 482 0044 00000000 		.word	.LC4
 483 0048 69020000 		.word	617
 484              		.cfi_endproc
 485              	.LFE44:
 487              		.section	.text.MX_TIM14_Init,"ax",%progbits
 488              		.align	2
 489              		.code	16
 490              		.thumb_func
 492              	MX_TIM14_Init:
 493              	.LFB40:
 483:Src/main.c    **** {
 494              		.loc 1 483 0
 495              		.cfi_startproc
 496 0000 08B5     		push	{r3, lr}
 497              	.LCFI9:
 498              		.cfi_def_cfa_offset 8
 499              		.cfi_offset 3, -8
 500              		.cfi_offset 14, -4
 484:Src/main.c    ****   htim14.Instance = TIM14;
 501              		.loc 1 484 0
 502 0002 0C48     		ldr	r0, .L28
 503 0004 0C4B     		ldr	r3, .L28+4
 504 0006 0360     		str	r3, [r0]
 485:Src/main.c    ****   htim14.Init.Prescaler = 11;
 505              		.loc 1 485 0
 506 0008 0B23     		mov	r3, #11
 507 000a 4360     		str	r3, [r0, #4]
 486:Src/main.c    ****   htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
 508              		.loc 1 486 0
 509 000c 0023     		mov	r3, #0
 510 000e 8360     		str	r3, [r0, #8]
 487:Src/main.c    ****   htim14.Init.Period = 1000;
 511              		.loc 1 487 0
 512 0010 FA22     		mov	r2, #250
 513 0012 9200     		lsl	r2, r2, #2
 514 0014 C260     		str	r2, [r0, #12]
 488:Src/main.c    ****   htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 515              		.loc 1 488 0
 516 0016 8022     		mov	r2, #128
 517 0018 9200     		lsl	r2, r2, #2
 518 001a 0261     		str	r2, [r0, #16]
 489:Src/main.c    ****   htim14.Init.RepetitionCounter = 0;
 519              		.loc 1 489 0
 520 001c 4361     		str	r3, [r0, #20]
 490:Src/main.c    ****   htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 521              		.loc 1 490 0
 522 001e 8361     		str	r3, [r0, #24]
 491:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
ARM GAS  /tmp/ccv6GvnB.s 			page 43


 523              		.loc 1 491 0
 524 0020 FFF7FEFF 		bl	HAL_TIM_Base_Init
 525              	.LVL19:
 526 0024 0028     		cmp	r0, #0
 527 0026 04D0     		beq	.L26
 493:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 528              		.loc 1 493 0
 529 0028 0448     		ldr	r0, .L28+8
 530 002a EE21     		mov	r1, #238
 531 002c FF31     		add	r1, r1, #255
 532 002e FFF7FEFF 		bl	_Error_Handler
 533              	.LVL20:
 534              	.L26:
 495:Src/main.c    **** }
 535              		.loc 1 495 0
 536              		@ sp needed
 537 0032 08BD     		pop	{r3, pc}
 538              	.L29:
 539              		.align	2
 540              	.L28:
 541 0034 00000000 		.word	htim14
 542 0038 00200040 		.word	1073750016
 543 003c 00000000 		.word	.LC4
 544              		.cfi_endproc
 545              	.LFE40:
 547              		.section	.text.MX_TIM15_Init,"ax",%progbits
 548              		.align	2
 549              		.code	16
 550              		.thumb_func
 552              	MX_TIM15_Init:
 553              	.LFB41:
 499:Src/main.c    **** {
 554              		.loc 1 499 0
 555              		.cfi_startproc
 556 0000 08B5     		push	{r3, lr}
 557              	.LCFI10:
 558              		.cfi_def_cfa_offset 8
 559              		.cfi_offset 3, -8
 560              		.cfi_offset 14, -4
 500:Src/main.c    ****   htim15.Instance = TIM15;
 561              		.loc 1 500 0
 562 0002 0C48     		ldr	r0, .L32
 563 0004 0C4B     		ldr	r3, .L32+4
 564 0006 0360     		str	r3, [r0]
 501:Src/main.c    ****   htim15.Init.Prescaler = 11;
 565              		.loc 1 501 0
 566 0008 0B23     		mov	r3, #11
 567 000a 4360     		str	r3, [r0, #4]
 502:Src/main.c    ****   htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
 568              		.loc 1 502 0
 569 000c 0023     		mov	r3, #0
 570 000e 8360     		str	r3, [r0, #8]
 503:Src/main.c    ****   htim15.Init.Period = 1000;
 571              		.loc 1 503 0
 572 0010 FA22     		mov	r2, #250
 573 0012 9200     		lsl	r2, r2, #2
 574 0014 C260     		str	r2, [r0, #12]
ARM GAS  /tmp/ccv6GvnB.s 			page 44


 504:Src/main.c    ****   htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
 575              		.loc 1 504 0
 576 0016 8022     		mov	r2, #128
 577 0018 9200     		lsl	r2, r2, #2
 578 001a 0261     		str	r2, [r0, #16]
 505:Src/main.c    ****   htim15.Init.RepetitionCounter = 0;
 579              		.loc 1 505 0
 580 001c 4361     		str	r3, [r0, #20]
 506:Src/main.c    ****   htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 581              		.loc 1 506 0
 582 001e 8361     		str	r3, [r0, #24]
 507:Src/main.c    ****   if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
 583              		.loc 1 507 0
 584 0020 FFF7FEFF 		bl	HAL_TIM_Base_Init
 585              	.LVL21:
 586 0024 0028     		cmp	r0, #0
 587 0026 04D0     		beq	.L30
 509:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 588              		.loc 1 509 0
 589 0028 0448     		ldr	r0, .L32+8
 590 002a FE21     		mov	r1, #254
 591 002c FF31     		add	r1, r1, #255
 592 002e FFF7FEFF 		bl	_Error_Handler
 593              	.LVL22:
 594              	.L30:
 511:Src/main.c    **** }
 595              		.loc 1 511 0
 596              		@ sp needed
 597 0032 08BD     		pop	{r3, pc}
 598              	.L33:
 599              		.align	2
 600              	.L32:
 601 0034 00000000 		.word	htim15
 602 0038 00400140 		.word	1073823744
 603 003c 00000000 		.word	.LC4
 604              		.cfi_endproc
 605              	.LFE41:
 607              		.section	.text.USER_TIM1_Init,"ax",%progbits
 608              		.align	2
 609              		.code	16
 610              		.thumb_func
 612              	USER_TIM1_Init:
 613              	.LFB43:
 542:Src/main.c    **** {
 614              		.loc 1 542 0
 615              		.cfi_startproc
 616 0000 00B5     		push	{lr}
 617              	.LCFI11:
 618              		.cfi_def_cfa_offset 4
 619              		.cfi_offset 14, -4
 620 0002 93B0     		sub	sp, sp, #76
 621              	.LCFI12:
 622              		.cfi_def_cfa_offset 80
 623              	.LBB29:
 543:Src/main.c    ****   __HAL_RCC_TIM1_CLK_ENABLE();
 624              		.loc 1 543 0
 625 0004 2C4B     		ldr	r3, .L39
ARM GAS  /tmp/ccv6GvnB.s 			page 45


 626 0006 9969     		ldr	r1, [r3, #24]
 627 0008 8022     		mov	r2, #128
 628 000a 1201     		lsl	r2, r2, #4
 629 000c 1143     		orr	r1, r2
 630 000e 9961     		str	r1, [r3, #24]
 631 0010 9B69     		ldr	r3, [r3, #24]
 632 0012 1A40     		and	r2, r3
 633 0014 0192     		str	r2, [sp, #4]
 634 0016 019B     		ldr	r3, [sp, #4]
 635              	.LBE29:
 549:Src/main.c    ****   htim1.Instance = TIM1;
 636              		.loc 1 549 0
 637 0018 2848     		ldr	r0, .L39+4
 638 001a 294B     		ldr	r3, .L39+8
 639 001c 0360     		str	r3, [r0]
 550:Src/main.c    ****   htim1.Init.Prescaler = 0;
 640              		.loc 1 550 0
 641 001e 0023     		mov	r3, #0
 642 0020 4360     		str	r3, [r0, #4]
 551:Src/main.c    ****   htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 643              		.loc 1 551 0
 644 0022 8360     		str	r3, [r0, #8]
 552:Src/main.c    ****   htim1.Init.Period = 1024;
 645              		.loc 1 552 0
 646 0024 8022     		mov	r2, #128
 647 0026 D200     		lsl	r2, r2, #3
 648 0028 C260     		str	r2, [r0, #12]
 553:Src/main.c    ****   htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 649              		.loc 1 553 0
 650 002a 0361     		str	r3, [r0, #16]
 554:Src/main.c    ****   htim1.Init.RepetitionCounter = 0;
 651              		.loc 1 554 0
 652 002c 4361     		str	r3, [r0, #20]
 555:Src/main.c    ****   htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
 653              		.loc 1 555 0
 654 002e 8023     		mov	r3, #128
 655 0030 8361     		str	r3, [r0, #24]
 556:Src/main.c    ****   if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
 656              		.loc 1 556 0
 657 0032 FFF7FEFF 		bl	HAL_TIM_PWM_Init
 658              	.LVL23:
 659 0036 0028     		cmp	r0, #0
 660 0038 03D0     		beq	.L35
 558:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 661              		.loc 1 558 0
 662 003a 2248     		ldr	r0, .L39+12
 663 003c 2249     		ldr	r1, .L39+16
 664 003e FFF7FEFF 		bl	_Error_Handler
 665              	.LVL24:
 666              	.L35:
 561:Src/main.c    ****   sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 667              		.loc 1 561 0
 668 0042 0023     		mov	r3, #0
 669 0044 1093     		str	r3, [sp, #64]
 562:Src/main.c    ****   sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 670              		.loc 1 562 0
 671 0046 1193     		str	r3, [sp, #68]
ARM GAS  /tmp/ccv6GvnB.s 			page 46


 563:Src/main.c    ****   if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
 672              		.loc 1 563 0
 673 0048 1C48     		ldr	r0, .L39+4
 674 004a 10A9     		add	r1, sp, #64
 675 004c FFF7FEFF 		bl	HAL_TIMEx_MasterConfigSynchronization
 676              	.LVL25:
 677 0050 0028     		cmp	r0, #0
 678 0052 03D0     		beq	.L36
 565:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 679              		.loc 1 565 0
 680 0054 1B48     		ldr	r0, .L39+12
 681 0056 1D49     		ldr	r1, .L39+20
 682 0058 FFF7FEFF 		bl	_Error_Handler
 683              	.LVL26:
 684              	.L36:
 568:Src/main.c    ****   sConfigOC.OCMode = TIM_OCMODE_PWM1;
 685              		.loc 1 568 0
 686 005c 6023     		mov	r3, #96
 687 005e 0993     		str	r3, [sp, #36]
 569:Src/main.c    ****   sConfigOC.Pulse = 100;
 688              		.loc 1 569 0
 689 0060 6423     		mov	r3, #100
 690 0062 0A93     		str	r3, [sp, #40]
 570:Src/main.c    ****   sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
 691              		.loc 1 570 0
 692 0064 0023     		mov	r3, #0
 693 0066 0B93     		str	r3, [sp, #44]
 571:Src/main.c    ****   sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
 694              		.loc 1 571 0
 695 0068 0C93     		str	r3, [sp, #48]
 572:Src/main.c    ****   sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
 696              		.loc 1 572 0
 697 006a 0D93     		str	r3, [sp, #52]
 573:Src/main.c    ****   sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
 698              		.loc 1 573 0
 699 006c 0E93     		str	r3, [sp, #56]
 574:Src/main.c    ****   sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
 700              		.loc 1 574 0
 701 006e 0F93     		str	r3, [sp, #60]
 575:Src/main.c    ****   if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
 702              		.loc 1 575 0
 703 0070 1248     		ldr	r0, .L39+4
 704 0072 09A9     		add	r1, sp, #36
 705 0074 0022     		mov	r2, #0
 706 0076 FFF7FEFF 		bl	HAL_TIM_PWM_ConfigChannel
 707              	.LVL27:
 708 007a 0028     		cmp	r0, #0
 709 007c 03D0     		beq	.L37
 577:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 710              		.loc 1 577 0
 711 007e 1148     		ldr	r0, .L39+12
 712 0080 1349     		ldr	r1, .L39+24
 713 0082 FFF7FEFF 		bl	_Error_Handler
 714              	.LVL28:
 715              	.L37:
 580:Src/main.c    ****   sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
 716              		.loc 1 580 0
ARM GAS  /tmp/ccv6GvnB.s 			page 47


 717 0086 0023     		mov	r3, #0
 718 0088 0293     		str	r3, [sp, #8]
 581:Src/main.c    ****   sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
 719              		.loc 1 581 0
 720 008a 0393     		str	r3, [sp, #12]
 582:Src/main.c    ****   sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
 721              		.loc 1 582 0
 722 008c 0493     		str	r3, [sp, #16]
 583:Src/main.c    ****   sBreakDeadTimeConfig.DeadTime = 0;
 723              		.loc 1 583 0
 724 008e 0593     		str	r3, [sp, #20]
 584:Src/main.c    ****   sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
 725              		.loc 1 584 0
 726 0090 0693     		str	r3, [sp, #24]
 585:Src/main.c    ****   sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
 727              		.loc 1 585 0
 728 0092 8022     		mov	r2, #128
 729 0094 9201     		lsl	r2, r2, #6
 730 0096 0792     		str	r2, [sp, #28]
 586:Src/main.c    ****   sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
 731              		.loc 1 586 0
 732 0098 0893     		str	r3, [sp, #32]
 587:Src/main.c    ****   if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
 733              		.loc 1 587 0
 734 009a 0848     		ldr	r0, .L39+4
 735 009c 02A9     		add	r1, sp, #8
 736 009e FFF7FEFF 		bl	HAL_TIMEx_ConfigBreakDeadTime
 737              	.LVL29:
 738 00a2 0028     		cmp	r0, #0
 739 00a4 03D0     		beq	.L38
 589:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 740              		.loc 1 589 0
 741 00a6 0748     		ldr	r0, .L39+12
 742 00a8 0A49     		ldr	r1, .L39+28
 743 00aa FFF7FEFF 		bl	_Error_Handler
 744              	.LVL30:
 745              	.L38:
 592:Src/main.c    ****   HAL_TIM_MspPostInit(&htim1);
 746              		.loc 1 592 0
 747 00ae 0348     		ldr	r0, .L39+4
 748 00b0 FFF7FEFF 		bl	HAL_TIM_MspPostInit
 749              	.LVL31:
 594:Src/main.c    **** }
 750              		.loc 1 594 0
 751 00b4 13B0     		add	sp, sp, #76
 752              		@ sp needed
 753 00b6 00BD     		pop	{pc}
 754              	.L40:
 755              		.align	2
 756              	.L39:
 757 00b8 00100240 		.word	1073876992
 758 00bc 00000000 		.word	htim1
 759 00c0 002C0140 		.word	1073818624
 760 00c4 00000000 		.word	.LC4
 761 00c8 2E020000 		.word	558
 762 00cc 35020000 		.word	565
 763 00d0 41020000 		.word	577
ARM GAS  /tmp/ccv6GvnB.s 			page 48


 764 00d4 4D020000 		.word	589
 765              		.cfi_endproc
 766              	.LFE43:
 768              		.section	.text.MX_ADC_Init,"ax",%progbits
 769              		.align	2
 770              		.code	16
 771              		.thumb_func
 773              	MX_ADC_Init:
 774              	.LFB38:
 411:Src/main.c    **** {
 775              		.loc 1 411 0
 776              		.cfi_startproc
 777 0000 00B5     		push	{lr}
 778              	.LCFI13:
 779              		.cfi_def_cfa_offset 4
 780              		.cfi_offset 14, -4
 781 0002 85B0     		sub	sp, sp, #20
 782              	.LCFI14:
 783              		.cfi_def_cfa_offset 24
 784              	.LBB30:
 412:Src/main.c    ****   __HAL_RCC_ADC1_CLK_ENABLE();
 785              		.loc 1 412 0
 786 0004 2A4B     		ldr	r3, .L46
 787 0006 9969     		ldr	r1, [r3, #24]
 788 0008 8022     		mov	r2, #128
 789 000a 9200     		lsl	r2, r2, #2
 790 000c 1143     		orr	r1, r2
 791 000e 9961     		str	r1, [r3, #24]
 792 0010 9B69     		ldr	r3, [r3, #24]
 793 0012 1A40     		and	r2, r3
 794 0014 0092     		str	r2, [sp]
 795 0016 009B     		ldr	r3, [sp]
 796              	.LBE30:
 417:Src/main.c    ****   hadc.Instance = ADC1;
 797              		.loc 1 417 0
 798 0018 2648     		ldr	r0, .L46+4
 799 001a 274B     		ldr	r3, .L46+8
 800 001c 0360     		str	r3, [r0]
 418:Src/main.c    ****   hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 801              		.loc 1 418 0
 802 001e 0023     		mov	r3, #0
 803 0020 4360     		str	r3, [r0, #4]
 419:Src/main.c    ****   hadc.Init.Resolution = ADC_RESOLUTION_12B;
 804              		.loc 1 419 0
 805 0022 8360     		str	r3, [r0, #8]
 420:Src/main.c    ****   hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 806              		.loc 1 420 0
 807 0024 C360     		str	r3, [r0, #12]
 421:Src/main.c    ****   hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
 808              		.loc 1 421 0
 809 0026 0122     		mov	r2, #1
 810 0028 0261     		str	r2, [r0, #16]
 422:Src/main.c    ****   hadc.Init.EOCSelection = ADC_EOC_SEQ_CONV;
 811              		.loc 1 422 0
 812 002a 0821     		mov	r1, #8
 813 002c 4161     		str	r1, [r0, #20]
 423:Src/main.c    ****   hadc.Init.LowPowerAutoWait = DISABLE;
ARM GAS  /tmp/ccv6GvnB.s 			page 49


 814              		.loc 1 423 0
 815 002e 8361     		str	r3, [r0, #24]
 424:Src/main.c    ****   hadc.Init.LowPowerAutoPowerOff = DISABLE;
 816              		.loc 1 424 0
 817 0030 C361     		str	r3, [r0, #28]
 425:Src/main.c    ****   hadc.Init.ContinuousConvMode = DISABLE;
 818              		.loc 1 425 0
 819 0032 0362     		str	r3, [r0, #32]
 426:Src/main.c    ****   hadc.Init.DiscontinuousConvMode = DISABLE;
 820              		.loc 1 426 0
 821 0034 4362     		str	r3, [r0, #36]
 427:Src/main.c    ****   hadc.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_TRGO;
 822              		.loc 1 427 0
 823 0036 8362     		str	r3, [r0, #40]
 428:Src/main.c    ****   hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_RISING;
 824              		.loc 1 428 0
 825 0038 8023     		mov	r3, #128
 826 003a DB00     		lsl	r3, r3, #3
 827 003c C362     		str	r3, [r0, #44]
 429:Src/main.c    ****   hadc.Init.DMAContinuousRequests = ENABLE;
 828              		.loc 1 429 0
 829 003e 0263     		str	r2, [r0, #48]
 430:Src/main.c    ****   hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 830              		.loc 1 430 0
 831 0040 4263     		str	r2, [r0, #52]
 431:Src/main.c    ****   if (HAL_ADC_Init(&hadc) != HAL_OK)
 832              		.loc 1 431 0
 833 0042 FFF7FEFF 		bl	HAL_ADC_Init
 834              	.LVL32:
 835 0046 0028     		cmp	r0, #0
 836 0048 04D0     		beq	.L42
 433:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 837              		.loc 1 433 0
 838 004a 1C48     		ldr	r0, .L46+12
 839 004c B221     		mov	r1, #178
 840 004e FF31     		add	r1, r1, #255
 841 0050 FFF7FEFF 		bl	_Error_Handler
 842              	.LVL33:
 843              	.L42:
 438:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_0;
 844              		.loc 1 438 0
 845 0054 0023     		mov	r3, #0
 846 0056 0193     		str	r3, [sp, #4]
 439:Src/main.c    ****   sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
 847              		.loc 1 439 0
 848 0058 8023     		mov	r3, #128
 849 005a 5B01     		lsl	r3, r3, #5
 850 005c 0293     		str	r3, [sp, #8]
 440:Src/main.c    ****   sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES_5;
 851              		.loc 1 440 0
 852 005e 0323     		mov	r3, #3
 853 0060 0393     		str	r3, [sp, #12]
 441:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 854              		.loc 1 441 0
 855 0062 1448     		ldr	r0, .L46+4
 856 0064 01A9     		add	r1, sp, #4
 857 0066 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
ARM GAS  /tmp/ccv6GvnB.s 			page 50


 858              	.LVL34:
 859 006a 0028     		cmp	r0, #0
 860 006c 04D0     		beq	.L43
 443:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 861              		.loc 1 443 0
 862 006e 1348     		ldr	r0, .L46+12
 863 0070 BC21     		mov	r1, #188
 864 0072 FF31     		add	r1, r1, #255
 865 0074 FFF7FEFF 		bl	_Error_Handler
 866              	.LVL35:
 867              	.L43:
 448:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_1;
 868              		.loc 1 448 0
 869 0078 0123     		mov	r3, #1
 870 007a 0193     		str	r3, [sp, #4]
 449:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 871              		.loc 1 449 0
 872 007c 0D48     		ldr	r0, .L46+4
 873 007e 01A9     		add	r1, sp, #4
 874 0080 FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 875              	.LVL36:
 876 0084 0028     		cmp	r0, #0
 877 0086 04D0     		beq	.L44
 451:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 878              		.loc 1 451 0
 879 0088 0C48     		ldr	r0, .L46+12
 880 008a C421     		mov	r1, #196
 881 008c FF31     		add	r1, r1, #255
 882 008e FFF7FEFF 		bl	_Error_Handler
 883              	.LVL37:
 884              	.L44:
 456:Src/main.c    ****   sConfig.Channel = ADC_CHANNEL_2;
 885              		.loc 1 456 0
 886 0092 0223     		mov	r3, #2
 887 0094 0193     		str	r3, [sp, #4]
 457:Src/main.c    ****   if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
 888              		.loc 1 457 0
 889 0096 0748     		ldr	r0, .L46+4
 890 0098 01A9     		add	r1, sp, #4
 891 009a FFF7FEFF 		bl	HAL_ADC_ConfigChannel
 892              	.LVL38:
 893 009e 0028     		cmp	r0, #0
 894 00a0 04D0     		beq	.L41
 459:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 895              		.loc 1 459 0
 896 00a2 0648     		ldr	r0, .L46+12
 897 00a4 CC21     		mov	r1, #204
 898 00a6 FF31     		add	r1, r1, #255
 899 00a8 FFF7FEFF 		bl	_Error_Handler
 900              	.LVL39:
 901              	.L41:
 463:Src/main.c    **** }
 902              		.loc 1 463 0
 903 00ac 05B0     		add	sp, sp, #20
 904              		@ sp needed
 905 00ae 00BD     		pop	{pc}
 906              	.L47:
ARM GAS  /tmp/ccv6GvnB.s 			page 51


 907              		.align	2
 908              	.L46:
 909 00b0 00100240 		.word	1073876992
 910 00b4 00000000 		.word	hadc
 911 00b8 00240140 		.word	1073816576
 912 00bc 00000000 		.word	.LC4
 913              		.cfi_endproc
 914              	.LFE38:
 916              		.section	.text.SystemClock_Config,"ax",%progbits
 917              		.align	2
 918              		.global	SystemClock_Config
 919              		.code	16
 920              		.thumb_func
 922              	SystemClock_Config:
 923              	.LFB37:
 358:Src/main.c    **** {
 924              		.loc 1 358 0
 925              		.cfi_startproc
 926 0000 00B5     		push	{lr}
 927              	.LCFI15:
 928              		.cfi_def_cfa_offset 4
 929              		.cfi_offset 14, -4
 930 0002 99B0     		sub	sp, sp, #100
 931              	.LCFI16:
 932              		.cfi_def_cfa_offset 104
 366:Src/main.c    ****   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48;
 933              		.loc 1 366 0
 934 0004 3023     		mov	r3, #48
 935 0006 0B93     		str	r3, [sp, #44]
 367:Src/main.c    ****   RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
 936              		.loc 1 367 0
 937 0008 0123     		mov	r3, #1
 938 000a 1393     		str	r3, [sp, #76]
 368:Src/main.c    ****   RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
 939              		.loc 1 368 0
 940 000c 1093     		str	r3, [sp, #64]
 369:Src/main.c    ****   RCC_OscInitStruct.HSI14CalibrationValue = 16;
 941              		.loc 1 369 0
 942 000e 1023     		mov	r3, #16
 943 0010 1193     		str	r3, [sp, #68]
 370:Src/main.c    ****   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
 944              		.loc 1 370 0
 945 0012 0023     		mov	r3, #0
 946 0014 1493     		str	r3, [sp, #80]
 371:Src/main.c    ****   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 947              		.loc 1 371 0
 948 0016 0BA8     		add	r0, sp, #44
 949 0018 FFF7FEFF 		bl	HAL_RCC_OscConfig
 950              	.LVL40:
 951 001c 0028     		cmp	r0, #0
 952 001e 04D0     		beq	.L49
 373:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 953              		.loc 1 373 0
 954 0020 1C48     		ldr	r0, .L52
 955 0022 7621     		mov	r1, #118
 956 0024 FF31     		add	r1, r1, #255
 957 0026 FFF7FEFF 		bl	_Error_Handler
ARM GAS  /tmp/ccv6GvnB.s 			page 52


 958              	.LVL41:
 959              	.L49:
 378:Src/main.c    ****   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 960              		.loc 1 378 0
 961 002a 0723     		mov	r3, #7
 962 002c 0793     		str	r3, [sp, #28]
 380:Src/main.c    ****   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
 963              		.loc 1 380 0
 964 002e 0323     		mov	r3, #3
 965 0030 0893     		str	r3, [sp, #32]
 381:Src/main.c    ****   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 966              		.loc 1 381 0
 967 0032 0023     		mov	r3, #0
 968 0034 0993     		str	r3, [sp, #36]
 382:Src/main.c    ****   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 969              		.loc 1 382 0
 970 0036 0A93     		str	r3, [sp, #40]
 384:Src/main.c    ****   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 971              		.loc 1 384 0
 972 0038 07A8     		add	r0, sp, #28
 973 003a 0121     		mov	r1, #1
 974 003c FFF7FEFF 		bl	HAL_RCC_ClockConfig
 975              	.LVL42:
 976 0040 0028     		cmp	r0, #0
 977 0042 04D0     		beq	.L50
 386:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 978              		.loc 1 386 0
 979 0044 1348     		ldr	r0, .L52
 980 0046 C121     		mov	r1, #193
 981 0048 4900     		lsl	r1, r1, #1
 982 004a FFF7FEFF 		bl	_Error_Handler
 983              	.LVL43:
 984              	.L50:
 389:Src/main.c    ****   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 985              		.loc 1 389 0
 986 004e 8023     		mov	r3, #128
 987 0050 9B02     		lsl	r3, r3, #10
 988 0052 0093     		str	r3, [sp]
 390:Src/main.c    ****   PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
 989              		.loc 1 390 0
 990 0054 0023     		mov	r3, #0
 991 0056 0693     		str	r3, [sp, #24]
 392:Src/main.c    ****   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 992              		.loc 1 392 0
 993 0058 6846     		mov	r0, sp
 994 005a FFF7FEFF 		bl	HAL_RCCEx_PeriphCLKConfig
 995              	.LVL44:
 996 005e 0028     		cmp	r0, #0
 997 0060 04D0     		beq	.L51
 394:Src/main.c    ****     _Error_Handler(__FILE__, __LINE__);
 998              		.loc 1 394 0
 999 0062 0C48     		ldr	r0, .L52
 1000 0064 C521     		mov	r1, #197
 1001 0066 4900     		lsl	r1, r1, #1
 1002 0068 FFF7FEFF 		bl	_Error_Handler
 1003              	.LVL45:
 1004              	.L51:
ARM GAS  /tmp/ccv6GvnB.s 			page 53


 399:Src/main.c    ****   HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 1005              		.loc 1 399 0
 1006 006c FFF7FEFF 		bl	HAL_RCC_GetHCLKFreq
 1007              	.LVL46:
 1008 0070 FA21     		mov	r1, #250
 1009 0072 8900     		lsl	r1, r1, #2
 1010 0074 FFF7FEFF 		bl	__aeabi_uidiv
 1011              	.LVL47:
 1012 0078 FFF7FEFF 		bl	HAL_SYSTICK_Config
 1013              	.LVL48:
 403:Src/main.c    ****   HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 1014              		.loc 1 403 0
 1015 007c 0420     		mov	r0, #4
 1016 007e FFF7FEFF 		bl	HAL_SYSTICK_CLKSourceConfig
 1017              	.LVL49:
 406:Src/main.c    ****   HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 1018              		.loc 1 406 0
 1019 0082 0120     		mov	r0, #1
 1020 0084 4042     		neg	r0, r0
 1021 0086 0021     		mov	r1, #0
 1022 0088 0022     		mov	r2, #0
 1023 008a FFF7FEFF 		bl	HAL_NVIC_SetPriority
 1024              	.LVL50:
 407:Src/main.c    **** }
 1025              		.loc 1 407 0
 1026 008e 19B0     		add	sp, sp, #100
 1027              		@ sp needed
 1028 0090 00BD     		pop	{pc}
 1029              	.L53:
 1030 0092 C046     		.align	2
 1031              	.L52:
 1032 0094 00000000 		.word	.LC4
 1033              		.cfi_endproc
 1034              	.LFE37:
 1036              		.global	__aeabi_ui2f
 1037              		.global	__aeabi_fmul
 1038              		.global	__aeabi_fcmpgt
 1039              		.global	__aeabi_i2d
 1040              		.global	__aeabi_ddiv
 1041              		.global	__aeabi_dmul
 1042              		.global	__aeabi_d2uiz
 1043              		.section	.text.main,"ax",%progbits
 1044              		.align	2
 1045              		.global	main
 1046              		.code	16
 1047              		.thumb_func
 1049              	main:
 1050              	.LFB36:
 151:Src/main.c    **** {
 1051              		.loc 1 151 0
 1052              		.cfi_startproc
 1053 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 1054              	.LCFI17:
 1055              		.cfi_def_cfa_offset 20
 1056              		.cfi_offset 4, -20
 1057              		.cfi_offset 5, -16
 1058              		.cfi_offset 6, -12
ARM GAS  /tmp/ccv6GvnB.s 			page 54


 1059              		.cfi_offset 7, -8
 1060              		.cfi_offset 14, -4
 1061 0002 5746     		mov	r7, r10
 1062 0004 4E46     		mov	r6, r9
 1063 0006 4546     		mov	r5, r8
 1064 0008 E0B4     		push	{r5, r6, r7}
 1065              	.LCFI18:
 1066              		.cfi_def_cfa_offset 32
 1067              		.cfi_offset 8, -32
 1068              		.cfi_offset 9, -28
 1069              		.cfi_offset 10, -24
 159:Src/main.c    ****   HAL_Init();
 1070              		.loc 1 159 0
 1071 000a FFF7FEFF 		bl	HAL_Init
 1072              	.LVL51:
 166:Src/main.c    ****   SystemClock_Config();
 1073              		.loc 1 166 0
 1074 000e FFF7FEFF 		bl	SystemClock_Config
 1075              	.LVL52:
 173:Src/main.c    ****   MX_GPIO_Init();
 1076              		.loc 1 173 0
 1077 0012 FFF7FEFF 		bl	MX_GPIO_Init
 1078              	.LVL53:
 174:Src/main.c    **** 	MX_DAC_Init();
 1079              		.loc 1 174 0
 1080 0016 FFF7FEFF 		bl	MX_DAC_Init
 1081              	.LVL54:
 176:Src/main.c    **** 	HAL_DAC_Start(&hdac, DAC_CHANNEL_1);
 1082              		.loc 1 176 0
 1083 001a D74C     		ldr	r4, .L83+24
 1084 001c 201C     		mov	r0, r4
 1085 001e 0021     		mov	r1, #0
 1086 0020 FFF7FEFF 		bl	HAL_DAC_Start
 1087              	.LVL55:
 177:Src/main.c    **** 	HAL_DAC_SetValue(&hdac, DAC_CHANNEL_1, DAC_ALIGN_12B_R, 2048);
 1088              		.loc 1 177 0
 1089 0024 201C     		mov	r0, r4
 1090 0026 0021     		mov	r1, #0
 1091 0028 0022     		mov	r2, #0
 1092 002a 8023     		mov	r3, #128
 1093 002c 1B01     		lsl	r3, r3, #4
 1094 002e FFF7FEFF 		bl	HAL_DAC_SetValue
 1095              	.LVL56:
 179:Src/main.c    **** 	MX_TIM14_Init();
 1096              		.loc 1 179 0
 1097 0032 FFF7FEFF 		bl	MX_TIM14_Init
 1098              	.LVL57:
 180:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim14);
 1099              		.loc 1 180 0
 1100 0036 D148     		ldr	r0, .L83+28
 1101 0038 FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1102              	.LVL58:
 181:Src/main.c    **** 	TIM14->CR1 &= ~(1UL);
 1103              		.loc 1 181 0
 1104 003c D04B     		ldr	r3, .L83+32
 1105 003e 1A68     		ldr	r2, [r3]
 1106 0040 0124     		mov	r4, #1
ARM GAS  /tmp/ccv6GvnB.s 			page 55


 1107 0042 A243     		bic	r2, r4
 1108 0044 1A60     		str	r2, [r3]
 183:Src/main.c    **** 	MX_TIM15_Init();
 1109              		.loc 1 183 0
 1110 0046 FFF7FEFF 		bl	MX_TIM15_Init
 1111              	.LVL59:
 184:Src/main.c    **** 	HAL_TIM_Base_Start_IT(&htim15);
 1112              		.loc 1 184 0
 1113 004a CE48     		ldr	r0, .L83+36
 1114 004c FFF7FEFF 		bl	HAL_TIM_Base_Start_IT
 1115              	.LVL60:
 185:Src/main.c    **** 	TIM15->CR1 &= ~(1UL);
 1116              		.loc 1 185 0
 1117 0050 CD4B     		ldr	r3, .L83+40
 1118 0052 1A68     		ldr	r2, [r3]
 1119 0054 A243     		bic	r2, r4
 1120 0056 1A60     		str	r2, [r3]
 187:Src/main.c    **** 	USER_TIM1_Init();
 1121              		.loc 1 187 0
 1122 0058 FFF7FEFF 		bl	USER_TIM1_Init
 1123              	.LVL61:
 190:Src/main.c    ****   HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
 1124              		.loc 1 190 0
 1125 005c CB48     		ldr	r0, .L83+44
 1126 005e 0021     		mov	r1, #0
 1127 0060 FFF7FEFF 		bl	HAL_TIM_PWM_Start
 1128              	.LVL62:
 194:Src/main.c    ****   USER_TIM2_Init();
 1129              		.loc 1 194 0
 1130 0064 FFF7FEFF 		bl	USER_TIM2_Init
 1131              	.LVL63:
 196:Src/main.c    **** 	HAL_TIM_Base_Start(&htim2);
 1132              		.loc 1 196 0
 1133 0068 C94C     		ldr	r4, .L83+48
 1134 006a 201C     		mov	r0, r4
 1135 006c FFF7FEFF 		bl	HAL_TIM_Base_Start
 1136              	.LVL64:
 197:Src/main.c    **** 	HAL_TIM_OnePulse_Start(&htim2, TIM_CHANNEL_2);
 1137              		.loc 1 197 0
 1138 0070 201C     		mov	r0, r4
 1139 0072 0421     		mov	r1, #4
 1140 0074 FFF7FEFF 		bl	HAL_TIM_OnePulse_Start
 1141              	.LVL65:
 199:Src/main.c    ****   MX_DMA_Init();
 1142              		.loc 1 199 0
 1143 0078 FFF7FEFF 		bl	MX_DMA_Init
 1144              	.LVL66:
 200:Src/main.c    ****   MX_ADC_Init();
 1145              		.loc 1 200 0
 1146 007c FFF7FEFF 		bl	MX_ADC_Init
 1147              	.LVL67:
 202:Src/main.c    ****   HAL_ADC_Start_DMA(&hadc, (uint32_t*)adcBuffer, 3);
 1148              		.loc 1 202 0
 1149 0080 C448     		ldr	r0, .L83+52
 1150 0082 C549     		ldr	r1, .L83+56
 1151 0084 0322     		mov	r2, #3
 1152 0086 FFF7FEFF 		bl	HAL_ADC_Start_DMA
ARM GAS  /tmp/ccv6GvnB.s 			page 56


 1153              	.LVL68:
 207:Src/main.c    ****   MX_USB_MIDI_INIT();
 1154              		.loc 1 207 0
 1155 008a FFF7FEFF 		bl	MX_USB_MIDI_INIT
 1156              	.LVL69:
 210:Src/main.c    ****   if(FUNC_ERROR == midiInit() ){
 1157              		.loc 1 210 0
 1158 008e FFF7FEFF 		bl	midiInit
 1159              	.LVL70:
 1160 0092 0028     		cmp	r0, #0
 1161 0094 16D1     		bne	.L55
 212:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1162              		.loc 1 212 0 discriminator 1
 1163 0096 9026     		mov	r6, #144
 1164 0098 F605     		lsl	r6, r6, #23
 1165 009a 8025     		mov	r5, #128
 1166 009c 2D02     		lsl	r5, r5, #8
 213:Src/main.c    **** 		  HAL_Delay(500);
 1167              		.loc 1 213 0 discriminator 1
 1168 009e FA24     		mov	r4, #250
 1169 00a0 6400     		lsl	r4, r4, #1
 1170              	.L80:
 212:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1171              		.loc 1 212 0 discriminator 1
 1172 00a2 301C     		mov	r0, r6
 1173 00a4 291C     		mov	r1, r5
 1174 00a6 0122     		mov	r2, #1
 1175 00a8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1176              	.LVL71:
 213:Src/main.c    **** 		  HAL_Delay(500);
 1177              		.loc 1 213 0 discriminator 1
 1178 00ac 201C     		mov	r0, r4
 1179 00ae FFF7FEFF 		bl	HAL_Delay
 1180              	.LVL72:
 214:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1181              		.loc 1 214 0 discriminator 1
 1182 00b2 301C     		mov	r0, r6
 1183 00b4 291C     		mov	r1, r5
 1184 00b6 0022     		mov	r2, #0
 1185 00b8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1186              	.LVL73:
 215:Src/main.c    **** 		  HAL_Delay(500);
 1187              		.loc 1 215 0 discriminator 1
 1188 00bc 201C     		mov	r0, r4
 1189 00be FFF7FEFF 		bl	HAL_Delay
 1190              	.LVL74:
 1191 00c2 EEE7     		b	.L80
 1192              	.L55:
 221:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1193              		.loc 1 221 0
 1194 00c4 B54E     		ldr	r6, .L83+60
 1195 00c6 FE25     		mov	r5, #254
 1196 00c8 6D00     		lsl	r5, r5, #1
 225:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1197              		.loc 1 225 0
 1198 00ca 9024     		mov	r4, #144
 1199 00cc E405     		lsl	r4, r4, #23
ARM GAS  /tmp/ccv6GvnB.s 			page 57


 1200              	.L81:
 221:Src/main.c    **** 	  if(USBD_STATE_CONFIGURED == hUsbDeviceFS.dev_state){
 1201              		.loc 1 221 0
 1202 00ce 735D     		ldrb	r3, [r6, r5]
 1203 00d0 032B     		cmp	r3, #3
 1204 00d2 0ED1     		bne	.L57
 222:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1205              		.loc 1 222 0
 1206 00d4 9020     		mov	r0, #144
 1207 00d6 C005     		lsl	r0, r0, #23
 1208 00d8 8021     		mov	r1, #128
 1209 00da 0902     		lsl	r1, r1, #8
 1210 00dc 0122     		mov	r2, #1
 1211 00de FFF7FEFF 		bl	HAL_GPIO_WritePin
 1212              	.LVL75:
 1213              	.LBB31:
 249:Src/main.c    ****     float Vout = ((float)adcBuffer[1] / 4096.0f) * 68.0f;
 1214              		.loc 1 249 0
 1215 00e2 E621     		mov	r1, #230
 1216 00e4 8905     		lsl	r1, r1, #22
 1217 00e6 8A46     		mov	r10, r1
 1218 00e8 AD4A     		ldr	r2, .L83+64
 1219 00ea 9146     		mov	r9, r2
 271:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 1220              		.loc 1 271 0
 1221 00ec AD4B     		ldr	r3, .L83+68
 1222 00ee 9846     		mov	r8, r3
 1223              	.LBE31:
 223:Src/main.c    **** 		  break;
 1224              		.loc 1 223 0
 1225 00f0 06E0     		b	.L79
 1226              	.L57:
 225:Src/main.c    **** 		  HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1227              		.loc 1 225 0
 1228 00f2 201C     		mov	r0, r4
 1229 00f4 8021     		mov	r1, #128
 1230 00f6 0902     		lsl	r1, r1, #8
 1231 00f8 0022     		mov	r2, #0
 1232 00fa FFF7FEFF 		bl	HAL_GPIO_WritePin
 1233              	.LVL76:
 227:Src/main.c    ****   }
 1234              		.loc 1 227 0
 1235 00fe E6E7     		b	.L81
 1236              	.L79:
 1237              	.LBB36:
 245:Src/main.c    ****     if (HAL_GPIO_ReadPin(BUTTON_GPIO, BUTTON_PIN)) {
 1238              		.loc 1 245 0
 1239 0100 9020     		mov	r0, #144
 1240 0102 C005     		lsl	r0, r0, #23
 1241 0104 8021     		mov	r1, #128
 1242 0106 FFF7FEFF 		bl	HAL_GPIO_ReadPin
 1243              	.LVL77:
 1244 010a 0028     		cmp	r0, #0
 1245 010c 01D0     		beq	.L59
 246:Src/main.c    ****       dfu_otter_bootloader();
 1246              		.loc 1 246 0
 1247 010e FFF7FEFF 		bl	dfu_otter_bootloader
ARM GAS  /tmp/ccv6GvnB.s 			page 58


 1248              	.LVL78:
 1249              	.L59:
 249:Src/main.c    ****     float Vout = ((float)adcBuffer[1] / 4096.0f) * 68.0f;
 1250              		.loc 1 249 0
 1251 0112 A149     		ldr	r1, .L83+56
 1252 0114 4888     		ldrh	r0, [r1, #2]
 1253 0116 FFF7FEFF 		bl	__aeabi_ui2f
 1254              	.LVL79:
 1255 011a 5146     		mov	r1, r10
 1256 011c FFF7FEFF 		bl	__aeabi_fmul
 1257              	.LVL80:
 1258 0120 4946     		mov	r1, r9
 1259 0122 FFF7FEFF 		bl	__aeabi_fmul
 1260              	.LVL81:
 251:Src/main.c    ****     if (Vout > 20) {
 1261              		.loc 1 251 0
 1262 0126 A049     		ldr	r1, .L83+72
 1263 0128 FFF7FEFF 		bl	__aeabi_fcmpgt
 1264              	.LVL82:
 1265 012c 0028     		cmp	r0, #0
 1266 012e 07D0     		beq	.L82
 252:Src/main.c    ****       HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, RESET);
 1267              		.loc 1 252 0
 1268 0130 9020     		mov	r0, #144
 1269 0132 C005     		lsl	r0, r0, #23
 1270 0134 8021     		mov	r1, #128
 1271 0136 0902     		lsl	r1, r1, #8
 1272 0138 0022     		mov	r2, #0
 1273 013a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1274              	.LVL83:
 1275 013e 06E0     		b	.L62
 1276              	.L82:
 254:Src/main.c    ****       HAL_GPIO_WritePin(LED_POW_GPIO, LED_POW_PIN, SET);
 1277              		.loc 1 254 0
 1278 0140 9020     		mov	r0, #144
 1279 0142 C005     		lsl	r0, r0, #23
 1280 0144 8021     		mov	r1, #128
 1281 0146 0902     		lsl	r1, r1, #8
 1282 0148 0122     		mov	r2, #1
 1283 014a FFF7FEFF 		bl	HAL_GPIO_WritePin
 1284              	.LVL84:
 1285              	.L62:
 257:Src/main.c    **** 		curTone0 = 0;
 1286              		.loc 1 257 0
 1287 014e 0023     		mov	r3, #0
 1288 0150 964A     		ldr	r2, .L83+76
 1289 0152 1380     		strh	r3, [r2]
 258:Src/main.c    **** 		curTone1 = 0;
 1290              		.loc 1 258 0
 1291 0154 964A     		ldr	r2, .L83+80
 1292 0156 1380     		strh	r3, [r2]
 1293              	.LVL85:
 1294              	.LBB32:
 261:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 1295              		.loc 1 261 0
 1296 0158 964C     		ldr	r4, .L83+84
 1297 015a 9448     		ldr	r0, .L83+76
ARM GAS  /tmp/ccv6GvnB.s 			page 59


 265:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 1298              		.loc 1 265 0
 1299 015c 151C     		mov	r5, r2
 262:Src/main.c    **** 	          curTone1 = curTone0;
 1300              		.loc 1 262 0
 1301 015e 171C     		mov	r7, r2
 263:Src/main.c    **** 	          curTone0 = freqs[i];
 1302              		.loc 1 263 0
 1303 0160 061C     		mov	r6, r0
 260:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1304              		.loc 1 260 0
 1305 0162 0DE0     		b	.L63
 1306              	.LVL86:
 1307              	.L66:
 261:Src/main.c    **** 	      if( freqs[i] > curTone0 ) {
 1308              		.loc 1 261 0
 1309 0164 5A00     		lsl	r2, r3, #1
 1310 0166 125B     		ldrh	r2, [r2, r4]
 1311 0168 0188     		ldrh	r1, [r0]
 1312 016a 8A42     		cmp	r2, r1
 1313 016c 02D9     		bls	.L64
 262:Src/main.c    **** 	          curTone1 = curTone0;
 1314              		.loc 1 262 0
 1315 016e 3980     		strh	r1, [r7]
 263:Src/main.c    **** 	          curTone0 = freqs[i];
 1316              		.loc 1 263 0
 1317 0170 3280     		strh	r2, [r6]
 1318 0172 04E0     		b	.L65
 1319              	.L64:
 265:Src/main.c    **** 	      else if( freqs[i] > curTone1 ) {
 1320              		.loc 1 265 0
 1321 0174 2988     		ldrh	r1, [r5]
 1322 0176 8A42     		cmp	r2, r1
 1323 0178 01D9     		bls	.L65
 266:Src/main.c    **** 	          curTone1 = freqs[i];
 1324              		.loc 1 266 0
 1325 017a 8D49     		ldr	r1, .L83+80
 1326 017c 0A80     		strh	r2, [r1]
 1327              	.L65:
 260:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1328              		.loc 1 260 0
 1329 017e 0133     		add	r3, r3, #1
 1330              	.LVL87:
 1331              	.L63:
 260:Src/main.c    **** 	  for( int i = 0; i < 16; i++ ) { // find max pitch from all channels
 1332              		.loc 1 260 0 is_stmt 0 discriminator 1
 1333 0180 0F2B     		cmp	r3, #15
 1334 0182 EFDD     		ble	.L66
 1335              	.LBE32:
 270:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
 1336              		.loc 1 270 0 is_stmt 1
 1337 0184 894B     		ldr	r3, .L83+76
 1338              	.LVL88:
 1339 0186 1988     		ldrh	r1, [r3]
 1340 0188 1429     		cmp	r1, #20
 1341 018a 20D9     		bls	.L67
 270:Src/main.c    **** 		if (curTone0 > 20 && curTone0 != lastTone0) { // play one tone using TIM14
ARM GAS  /tmp/ccv6GvnB.s 			page 60


 1342              		.loc 1 270 0 is_stmt 0 discriminator 1
 1343 018c 8A4B     		ldr	r3, .L83+88
 1344 018e 1B88     		ldrh	r3, [r3]
 1345 0190 9942     		cmp	r1, r3
 1346 0192 1CD0     		beq	.L67
 271:Src/main.c    **** 			curPeriode0 = (uint32_t)1000000 / (uint32_t)(curTone0);
 1347              		.loc 1 271 0 is_stmt 1
 1348 0194 4046     		mov	r0, r8
 1349 0196 FFF7FEFF 		bl	__aeabi_uidiv
 1350              	.LVL89:
 1351 019a 884B     		ldr	r3, .L83+92
 1352 019c 1860     		str	r0, [r3]
 272:Src/main.c    **** 			TIM14->CNT = 0;
 1353              		.loc 1 272 0
 1354 019e 784B     		ldr	r3, .L83+32
 1355 01a0 0022     		mov	r2, #0
 1356 01a2 5A62     		str	r2, [r3, #36]
 273:Src/main.c    **** 			TIM14->ARR = curPeriode0;
 1357              		.loc 1 273 0
 1358 01a4 D862     		str	r0, [r3, #44]
 274:Src/main.c    **** 			TIM14->CR1 = TIM14->CR1 | 1;
 1359              		.loc 1 274 0
 1360 01a6 1968     		ldr	r1, [r3]
 1361 01a8 0122     		mov	r2, #1
 1362 01aa 0A43     		orr	r2, r1
 1363 01ac 1A60     		str	r2, [r3]
 275:Src/main.c    **** 			lastTone0 = curTone0;
 1364              		.loc 1 275 0
 1365 01ae 7F4B     		ldr	r3, .L83+76
 1366 01b0 1A88     		ldrh	r2, [r3]
 1367 01b2 814B     		ldr	r3, .L83+88
 1368 01b4 1A80     		strh	r2, [r3]
 276:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 1369              		.loc 1 276 0
 1370 01b6 FFF7FEFF 		bl	HAL_GetTick
 1371              	.LVL90:
 1372 01ba 814B     		ldr	r3, .L83+96
 1373 01bc 1860     		str	r0, [r3]
 278:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, SET);
 1374              		.loc 1 278 0
 1375 01be 9020     		mov	r0, #144
 1376 01c0 C005     		lsl	r0, r0, #23
 1377 01c2 8021     		mov	r1, #128
 1378 01c4 C900     		lsl	r1, r1, #3
 1379 01c6 0122     		mov	r2, #1
 1380 01c8 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1381              	.LVL91:
 1382 01cc 13E0     		b	.L68
 1383              	.L67:
 279:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 1384              		.loc 1 279 0
 1385 01ce 1329     		cmp	r1, #19
 1386 01d0 11D8     		bhi	.L68
 279:Src/main.c    **** 		} else if (curTone0 < 20 && curTone0 != lastTone0) {
 1387              		.loc 1 279 0 is_stmt 0 discriminator 1
 1388 01d2 794B     		ldr	r3, .L83+88
 1389 01d4 1B88     		ldrh	r3, [r3]
ARM GAS  /tmp/ccv6GvnB.s 			page 61


 1390 01d6 9942     		cmp	r1, r3
 1391 01d8 0DD0     		beq	.L68
 280:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 1392              		.loc 1 280 0 is_stmt 1
 1393 01da 694B     		ldr	r3, .L83+32
 1394 01dc 1A68     		ldr	r2, [r3]
 1395 01de 0121     		mov	r1, #1
 1396 01e0 8A43     		bic	r2, r1
 1397 01e2 1A60     		str	r2, [r3]
 281:Src/main.c    ****       curPeriode0 = 0;
 1398              		.loc 1 281 0
 1399 01e4 0022     		mov	r2, #0
 1400 01e6 754B     		ldr	r3, .L83+92
 1401 01e8 1A60     		str	r2, [r3]
 283:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1402              		.loc 1 283 0
 1403 01ea 9020     		mov	r0, #144
 1404 01ec C005     		lsl	r0, r0, #23
 1405 01ee 8021     		mov	r1, #128
 1406 01f0 C900     		lsl	r1, r1, #3
 1407 01f2 FFF7FEFF 		bl	HAL_GPIO_WritePin
 1408              	.LVL92:
 1409              	.L68:
 286:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 1410              		.loc 1 286 0
 1411 01f6 6E4B     		ldr	r3, .L83+80
 1412 01f8 1988     		ldrh	r1, [r3]
 1413 01fa 1429     		cmp	r1, #20
 1414 01fc 19D9     		bls	.L69
 286:Src/main.c    **** 		if (curTone1 > 20 && curTone1 != lastTone1) { // play other polyphonic tone ussing TIM15
 1415              		.loc 1 286 0 is_stmt 0 discriminator 1
 1416 01fe 714B     		ldr	r3, .L83+100
 1417 0200 1B88     		ldrh	r3, [r3]
 1418 0202 9942     		cmp	r1, r3
 1419 0204 15D0     		beq	.L69
 287:Src/main.c    **** 			curPeriode1 = (uint32_t)1000000 / (uint32_t)(curTone1);
 1420              		.loc 1 287 0 is_stmt 1
 1421 0206 4046     		mov	r0, r8
 1422 0208 FFF7FEFF 		bl	__aeabi_uidiv
 1423              	.LVL93:
 1424 020c 6E4B     		ldr	r3, .L83+104
 1425 020e 1860     		str	r0, [r3]
 288:Src/main.c    **** 			TIM15->CNT = 0;
 1426              		.loc 1 288 0
 1427 0210 5D4B     		ldr	r3, .L83+40
 1428 0212 0022     		mov	r2, #0
 1429 0214 5A62     		str	r2, [r3, #36]
 289:Src/main.c    **** 			TIM15->ARR = curPeriode1;
 1430              		.loc 1 289 0
 1431 0216 D862     		str	r0, [r3, #44]
 290:Src/main.c    **** 			TIM15->CR1 = TIM15->CR1 | 1;
 1432              		.loc 1 290 0
 1433 0218 1968     		ldr	r1, [r3]
 1434 021a 0122     		mov	r2, #1
 1435 021c 0A43     		orr	r2, r1
 1436 021e 1A60     		str	r2, [r3]
 291:Src/main.c    **** 			lastTone1 = curTone1;
ARM GAS  /tmp/ccv6GvnB.s 			page 62


 1437              		.loc 1 291 0
 1438 0220 634B     		ldr	r3, .L83+80
 1439 0222 1A88     		ldrh	r2, [r3]
 1440 0224 674B     		ldr	r3, .L83+100
 1441 0226 1A80     		strh	r2, [r3]
 292:Src/main.c    **** 			noteTimeout = HAL_GetTick();
 1442              		.loc 1 292 0
 1443 0228 FFF7FEFF 		bl	HAL_GetTick
 1444              	.LVL94:
 1445 022c 644B     		ldr	r3, .L83+96
 1446 022e 1860     		str	r0, [r3]
 1447 0230 0DE0     		b	.L70
 1448              	.L69:
 293:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 1449              		.loc 1 293 0
 1450 0232 1329     		cmp	r1, #19
 1451 0234 0BD8     		bhi	.L70
 293:Src/main.c    **** 		} else if (curTone1 < 20 && curTone1 != lastTone1) {
 1452              		.loc 1 293 0 is_stmt 0 discriminator 1
 1453 0236 634B     		ldr	r3, .L83+100
 1454 0238 1B88     		ldrh	r3, [r3]
 1455 023a 9942     		cmp	r1, r3
 1456 023c 07D0     		beq	.L70
 294:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 1457              		.loc 1 294 0 is_stmt 1
 1458 023e 524B     		ldr	r3, .L83+40
 1459 0240 1A68     		ldr	r2, [r3]
 1460 0242 0121     		mov	r1, #1
 1461 0244 8A43     		bic	r2, r1
 1462 0246 1A60     		str	r2, [r3]
 295:Src/main.c    ****       curPeriode1 = 0;
 1463              		.loc 1 295 0
 1464 0248 0022     		mov	r2, #0
 1465 024a 5F4B     		ldr	r3, .L83+104
 1466 024c 1A60     		str	r2, [r3]
 1467              	.L70:
 298:Src/main.c    **** 		if ((HAL_GetTick() - noteTimeout) > 1000) {
 1468              		.loc 1 298 0
 1469 024e FFF7FEFF 		bl	HAL_GetTick
 1470              	.LVL95:
 1471 0252 5B4B     		ldr	r3, .L83+96
 1472 0254 1B68     		ldr	r3, [r3]
 1473 0256 C01A     		sub	r0, r0, r3
 1474 0258 FA23     		mov	r3, #250
 1475 025a 9B00     		lsl	r3, r3, #2
 1476 025c 9842     		cmp	r0, r3
 1477 025e 18D9     		bls	.L71
 299:Src/main.c    **** 			TIM14->CR1 &= ~(1UL);
 1478              		.loc 1 299 0
 1479 0260 474B     		ldr	r3, .L83+32
 1480 0262 1968     		ldr	r1, [r3]
 1481 0264 0122     		mov	r2, #1
 1482 0266 9143     		bic	r1, r2
 1483 0268 1960     		str	r1, [r3]
 300:Src/main.c    **** 			TIM15->CR1 &= ~(1UL);
 1484              		.loc 1 300 0
 1485 026a 474B     		ldr	r3, .L83+40
ARM GAS  /tmp/ccv6GvnB.s 			page 63


 1486 026c 1968     		ldr	r1, [r3]
 1487 026e 9143     		bic	r1, r2
 1488 0270 1960     		str	r1, [r3]
 1489              	.LVL96:
 1490              	.LBB33:
 301:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1491              		.loc 1 301 0
 1492 0272 0023     		mov	r3, #0
 302:Src/main.c    **** 				freqs[i] = 0;
 1493              		.loc 1 302 0
 1494 0274 4F48     		ldr	r0, .L83+84
 1495 0276 0021     		mov	r1, #0
 301:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1496              		.loc 1 301 0
 1497 0278 02E0     		b	.L72
 1498              	.LVL97:
 1499              	.L73:
 302:Src/main.c    **** 				freqs[i] = 0;
 1500              		.loc 1 302 0 discriminator 2
 1501 027a 5A00     		lsl	r2, r3, #1
 1502 027c 1152     		strh	r1, [r2, r0]
 301:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1503              		.loc 1 301 0 discriminator 2
 1504 027e 0133     		add	r3, r3, #1
 1505              	.LVL98:
 1506              	.L72:
 301:Src/main.c    **** 			for (int i = 0; i < 16; i++) {
 1507              		.loc 1 301 0 is_stmt 0 discriminator 1
 1508 0280 0F2B     		cmp	r3, #15
 1509 0282 FADD     		ble	.L73
 1510              	.LBE33:
 305:Src/main.c    **** 			HAL_GPIO_WritePin(LED_FAULT_GPIO, LED_FAULT_PIN, RESET);
 1511              		.loc 1 305 0 is_stmt 1
 1512 0284 9020     		mov	r0, #144
 1513 0286 C005     		lsl	r0, r0, #23
 1514 0288 8021     		mov	r1, #128
 1515 028a C900     		lsl	r1, r1, #3
 1516 028c 0022     		mov	r2, #0
 1517 028e FFF7FEFF 		bl	HAL_GPIO_WritePin
 1518              	.LVL99:
 1519              	.L71:
 311:Src/main.c    **** 		if( FUNC_SUCCESS == midiGetFromUsbRx(0, &uart_tx_dat)){
 1520              		.loc 1 311 0
 1521 0292 0020     		mov	r0, #0
 1522 0294 4D49     		ldr	r1, .L83+108
 1523 0296 FFF7FEFF 		bl	midiGetFromUsbRx
 1524              	.LVL100:
 1525 029a 0128     		cmp	r0, #1
 1526 029c 00D0     		beq	.LCB1290
 1527 029e 2FE7     		b	.L79	@long jump
 1528              	.LCB1290:
 312:Src/main.c    **** 			if (uart_tx_dat >> 7 == 1) {
 1529              		.loc 1 312 0
 1530 02a0 4A4B     		ldr	r3, .L83+108
 1531 02a2 1B78     		ldrb	r3, [r3]
 1532 02a4 DA09     		lsr	r2, r3, #7
 1533 02a6 012A     		cmp	r2, #1
ARM GAS  /tmp/ccv6GvnB.s 			page 64


 1534 02a8 08D1     		bne	.L75
 313:Src/main.c    **** 				midiBuffer[0] = uart_tx_dat;
 1535              		.loc 1 313 0
 1536 02aa 494A     		ldr	r2, .L83+112
 1537 02ac 1370     		strb	r3, [r2]
 314:Src/main.c    **** 				midiBuffer[1] = 0;
 1538              		.loc 1 314 0
 1539 02ae 0023     		mov	r3, #0
 1540 02b0 5370     		strb	r3, [r2, #1]
 315:Src/main.c    **** 				midiBuffer[2] = 0;
 1541              		.loc 1 315 0
 1542 02b2 9370     		strb	r3, [r2, #2]
 316:Src/main.c    **** 				midiState = 1;
 1543              		.loc 1 316 0
 1544 02b4 0122     		mov	r2, #1
 1545 02b6 474B     		ldr	r3, .L83+116
 1546 02b8 1A70     		strb	r2, [r3]
 1547 02ba 21E7     		b	.L79
 1548              	.L75:
 317:Src/main.c    **** 			} else if (midiState == 1) {
 1549              		.loc 1 317 0
 1550 02bc 454A     		ldr	r2, .L83+116
 1551 02be 1278     		ldrb	r2, [r2]
 1552 02c0 012A     		cmp	r2, #1
 1553 02c2 05D1     		bne	.L76
 318:Src/main.c    **** 				midiBuffer[1] = uart_tx_dat;
 1554              		.loc 1 318 0
 1555 02c4 424A     		ldr	r2, .L83+112
 1556 02c6 5370     		strb	r3, [r2, #1]
 319:Src/main.c    **** 				midiState = 2;
 1557              		.loc 1 319 0
 1558 02c8 0222     		mov	r2, #2
 1559 02ca 424B     		ldr	r3, .L83+116
 1560 02cc 1A70     		strb	r2, [r3]
 1561 02ce 17E7     		b	.L79
 1562              	.L76:
 320:Src/main.c    **** 			} else if (midiState == 2) {
 1563              		.loc 1 320 0
 1564 02d0 022A     		cmp	r2, #2
 1565 02d2 00D0     		beq	.LCB1323
 1566 02d4 14E7     		b	.L79	@long jump
 1567              	.LCB1323:
 321:Src/main.c    **** 				midiBuffer[2] = uart_tx_dat;
 1568              		.loc 1 321 0
 1569 02d6 3E4A     		ldr	r2, .L83+112
 1570 02d8 9370     		strb	r3, [r2, #2]
 322:Src/main.c    **** 				midiState = 3;
 1571              		.loc 1 322 0
 1572 02da 0321     		mov	r1, #3
 1573 02dc 3D4B     		ldr	r3, .L83+116
 1574 02de 1970     		strb	r1, [r3]
 324:Src/main.c    **** 				if ((midiBuffer[0] & 0xF0) == 0x90) { // Note on, 2 data bytes
 1575              		.loc 1 324 0
 1576 02e0 1378     		ldrb	r3, [r2]
 1577 02e2 0F22     		mov	r2, #15
 1578 02e4 9343     		bic	r3, r2
 1579 02e6 902B     		cmp	r3, #144
ARM GAS  /tmp/ccv6GvnB.s 			page 65


 1580 02e8 1CD1     		bne	.L77
 1581              	.LBB34:
 325:Src/main.c    **** 					char key = midiBuffer[1];
 1582              		.loc 1 325 0
 1583 02ea 394C     		ldr	r4, .L83+112
 1584 02ec 6078     		ldrb	r0, [r4, #1]
 1585              	.LVL101:
 328:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1586              		.loc 1 328 0
 1587 02ee 4538     		sub	r0, r0, #69
 1588 02f0 FFF7FEFF 		bl	__aeabi_i2d
 1589              	.LVL102:
 1590 02f4 1B4B     		ldr	r3, .L83+4
 1591 02f6 1A4A     		ldr	r2, .L83
 1592 02f8 FFF7FEFF 		bl	__aeabi_ddiv
 1593              	.LVL103:
 1594 02fc 021C     		mov	r2, r0
 1595 02fe 0B1C     		mov	r3, r1
 1596 0300 1948     		ldr	r0, .L83+8
 1597 0302 1A49     		ldr	r1, .L83+12
 1598 0304 FFF7FEFF 		bl	pow
 1599              	.LVL104:
 1600 0308 194A     		ldr	r2, .L83+16
 1601 030a 1A4B     		ldr	r3, .L83+20
 1602 030c FFF7FEFF 		bl	__aeabi_dmul
 1603              	.LVL105:
 1604 0310 FFF7FEFF 		bl	__aeabi_d2uiz
 1605              	.LVL106:
 329:Src/main.c    **** 					curChannel = midiBuffer[0] & 0xF;
 1606              		.loc 1 329 0
 1607 0314 2278     		ldrb	r2, [r4]
 1608 0316 0F23     		mov	r3, #15
 1609 0318 1340     		and	r3, r2
 1610 031a 2F4A     		ldr	r2, .L83+120
 1611 031c 1380     		strh	r3, [r2]
 330:Src/main.c    **** 					freqs[curChannel] = freq;
 1612              		.loc 1 330 0
 1613 031e 5B00     		lsl	r3, r3, #1
 1614 0320 244A     		ldr	r2, .L83+84
 1615 0322 D052     		strh	r0, [r2, r3]
 1616              	.LVL107:
 1617              	.L77:
 1618              	.LBE34:
 333:Src/main.c    **** 				} if ((midiBuffer[0] &0xF0) == 0x80) { // Note off, 2 data bytes
 1619              		.loc 1 333 0
 1620 0324 2A4B     		ldr	r3, .L83+112
 1621 0326 1B78     		ldrb	r3, [r3]
 1622 0328 0F22     		mov	r2, #15
 1623 032a 9343     		bic	r3, r2
 1624 032c 802B     		cmp	r3, #128
 1625 032e 00D0     		beq	.LCB1382
 1626 0330 E6E6     		b	.L79	@long jump
 1627              	.LCB1382:
 1628              	.LBB35:
 334:Src/main.c    **** 					char key = midiBuffer[1];
 1629              		.loc 1 334 0
 1630 0332 274C     		ldr	r4, .L83+112
ARM GAS  /tmp/ccv6GvnB.s 			page 66


 1631 0334 6078     		ldrb	r0, [r4, #1]
 1632              	.LVL108:
 337:Src/main.c    **** 					uint16_t freq = pow(2,(key-0x45)/12.0)*440.0;
 1633              		.loc 1 337 0
 1634 0336 4538     		sub	r0, r0, #69
 1635 0338 FFF7FEFF 		bl	__aeabi_i2d
 1636              	.LVL109:
 1637 033c 094B     		ldr	r3, .L83+4
 1638 033e 084A     		ldr	r2, .L83
 1639 0340 FFF7FEFF 		bl	__aeabi_ddiv
 1640              	.LVL110:
 1641 0344 021C     		mov	r2, r0
 1642 0346 0B1C     		mov	r3, r1
 1643 0348 0748     		ldr	r0, .L83+8
 1644 034a 0849     		ldr	r1, .L83+12
 1645 034c FFF7FEFF 		bl	pow
 1646              	.LVL111:
 340:Src/main.c    **** 					freqs[midiBuffer[0] & 0xF] = 0;
 1647              		.loc 1 340 0
 1648 0350 2278     		ldrb	r2, [r4]
 1649 0352 0F23     		mov	r3, #15
 1650 0354 1A40     		and	r2, r3
 1651 0356 5200     		lsl	r2, r2, #1
 1652 0358 0021     		mov	r1, #0
 1653 035a 164B     		ldr	r3, .L83+84
 1654 035c D152     		strh	r1, [r2, r3]
 1655 035e CFE6     		b	.L79
 1656              	.L84:
 1657              		.align	3
 1658              	.L83:
 1659 0360 00000000 		.word	0
 1660 0364 00002840 		.word	1076363264
 1661 0368 00000000 		.word	0
 1662 036c 00000040 		.word	1073741824
 1663 0370 00000000 		.word	0
 1664 0374 00807B40 		.word	1081835520
 1665 0378 00000000 		.word	hdac
 1666 037c 00000000 		.word	htim14
 1667 0380 00200040 		.word	1073750016
 1668 0384 00000000 		.word	htim15
 1669 0388 00400140 		.word	1073823744
 1670 038c 00000000 		.word	htim1
 1671 0390 00000000 		.word	htim2
 1672 0394 00000000 		.word	hadc
 1673 0398 00000000 		.word	adcBuffer
 1674 039c 00000000 		.word	hUsbDeviceFS
 1675 03a0 00008842 		.word	1116209152
 1676 03a4 40420F00 		.word	1000000
 1677 03a8 0000A041 		.word	1101004800
 1678 03ac 00000000 		.word	.LANCHOR2
 1679 03b0 00000000 		.word	.LANCHOR3
 1680 03b4 00000000 		.word	.LANCHOR4
 1681 03b8 00000000 		.word	.LANCHOR5
 1682 03bc 00000000 		.word	.LANCHOR0
 1683 03c0 00000000 		.word	.LANCHOR6
 1684 03c4 00000000 		.word	.LANCHOR7
 1685 03c8 00000000 		.word	.LANCHOR1
ARM GAS  /tmp/ccv6GvnB.s 			page 67


 1686 03cc 00000000 		.word	uart_tx_dat
 1687 03d0 00000000 		.word	midiBuffer
 1688 03d4 00000000 		.word	.LANCHOR8
 1689 03d8 00000000 		.word	.LANCHOR9
 1690              	.LBE35:
 1691              	.LBE36:
 1692              		.cfi_endproc
 1693              	.LFE36:
 1695              		.global	freqs
 1696              		.global	noteTimeout
 1697              		.global	lastTone1
 1698              		.global	lastTone0
 1699              		.global	curChannel
 1700              		.global	curTone1
 1701              		.global	curTone0
 1702              		.global	midiState
 1703              		.comm	midiBuffer,4,4
 1704              		.global	curPeriode1
 1705              		.global	curPeriode0
 1706              		.comm	uart_tx_dat,1,1
 1707              		.comm	adcBuffer,6,4
 1708              		.comm	hdma_adc,68,4
 1709              		.comm	hadc,76,4
 1710              		.comm	hdac,20,4
 1711              		.comm	htim1,64,4
 1712              		.comm	htim2,64,4
 1713              		.comm	htim15,64,4
 1714              		.comm	htim14,64,4
 1715 03dc C046C046 		.section	.bss.lastTone0,"aw",%nobits
 1716              		.align	1
 1717              		.set	.LANCHOR5,. + 0
 1720              	lastTone0:
 1721 0000 0000     		.space	2
 1722              		.section	.bss.lastTone1,"aw",%nobits
 1723              		.align	1
 1724              		.set	.LANCHOR7,. + 0
 1727              	lastTone1:
 1728 0000 0000     		.space	2
 1729              		.section	.bss.curTone0,"aw",%nobits
 1730              		.align	1
 1731              		.set	.LANCHOR2,. + 0
 1734              	curTone0:
 1735 0000 0000     		.space	2
 1736              		.section	.bss.curTone1,"aw",%nobits
 1737              		.align	1
 1738              		.set	.LANCHOR3,. + 0
 1741              	curTone1:
 1742 0000 0000     		.space	2
 1743              		.section	.bss.curPeriode0,"aw",%nobits
 1744              		.align	2
 1745              		.set	.LANCHOR0,. + 0
 1748              	curPeriode0:
 1749 0000 00000000 		.space	4
 1750              		.section	.bss.curPeriode1,"aw",%nobits
 1751              		.align	2
 1752              		.set	.LANCHOR1,. + 0
 1755              	curPeriode1:
ARM GAS  /tmp/ccv6GvnB.s 			page 68


 1756 0000 00000000 		.space	4
 1757              		.section	.bss.noteTimeout,"aw",%nobits
 1758              		.align	2
 1759              		.set	.LANCHOR6,. + 0
 1762              	noteTimeout:
 1763 0000 00000000 		.space	4
 1764              		.section	.bss.freqs,"aw",%nobits
 1765              		.align	2
 1766              		.set	.LANCHOR4,. + 0
 1769              	freqs:
 1770 0000 00000000 		.space	32
 1770      00000000 
 1770      00000000 
 1770      00000000 
 1770      00000000 
 1771              		.section	.rodata.str1.4,"aMS",%progbits,1
 1772              		.align	2
 1773              	.LC4:
 1774 0000 5372632F 		.ascii	"Src/main.c\000"
 1774      6D61696E 
 1774      2E6300
 1775 000b 00       		.section	.bss.curChannel,"aw",%nobits
 1776              		.align	1
 1777              		.set	.LANCHOR9,. + 0
 1780              	curChannel:
 1781 0000 0000     		.space	2
 1782              		.section	.bss.midiState,"aw",%nobits
 1783              		.set	.LANCHOR8,. + 0
 1786              	midiState:
 1787 0000 00       		.space	1
 1788              		.text
 1789              	.Letext0:
 1790              		.file 4 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
 1791              		.file 5 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/machine/_defaul
 1792              		.file 6 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/stdint.h"
 1793              		.file 7 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f0xx.h"
 1794              		.file 8 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_def.h"
 1795              		.file 9 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc.h"
 1796              		.file 10 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_rcc_ex.h"
 1797              		.file 11 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_gpio.h"
 1798              		.file 12 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dma.h"
 1799              		.file 13 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_adc.h"
 1800              		.file 14 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_dac.h"
 1801              		.file 15 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim.h"
 1802              		.file 16 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_tim_ex.h"
 1803              		.file 17 "Middlewares/ST/STM32_USB_Device_Library/Core/Inc/usbd_def.h"
 1804              		.file 18 "Inc/curelib_inc/curemisc.h"
 1805              		.file 19 "Inc/usb_device.h"
 1806              		.file 20 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal_cortex.h"
 1807              		.file 21 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h"
 1808              		.file 22 "Inc/usbd_midi_if.h"
 1809              		.file 23 "/home/niklas/Downloads/gcc-arm-none-eabi-4_8-2014q3/arm-none-eabi/include/math.h"
ARM GAS  /tmp/ccv6GvnB.s 			page 69


DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccv6GvnB.s:18     .text.MX_GPIO_Init:00000000 $t
     /tmp/ccv6GvnB.s:22     .text.MX_GPIO_Init:00000000 MX_GPIO_Init
     /tmp/ccv6GvnB.s:105    .text.MX_GPIO_Init:00000068 $d
     /tmp/ccv6GvnB.s:110    .text.USER_TIM2_Init:00000000 $t
     /tmp/ccv6GvnB.s:114    .text.USER_TIM2_Init:00000000 USER_TIM2_Init
     /tmp/ccv6GvnB.s:203    .text.USER_TIM2_Init:0000006c $d
                            *COM*:00000040 htim2
     /tmp/ccv6GvnB.s:209    .text.MX_DMA_Init:00000000 $t
     /tmp/ccv6GvnB.s:213    .text.MX_DMA_Init:00000000 MX_DMA_Init
     /tmp/ccv6GvnB.s:253    .text.MX_DMA_Init:0000002c $d
     /tmp/ccv6GvnB.s:258    .text.dfu_otter_bootloader:00000000 $t
     /tmp/ccv6GvnB.s:263    .text.dfu_otter_bootloader:00000000 dfu_otter_bootloader
     /tmp/ccv6GvnB.s:309    .text.dfu_otter_bootloader:00000018 $d
     /tmp/ccv6GvnB.s:322    .text.HAL_TIM_PeriodElapsedCallback:00000000 $t
     /tmp/ccv6GvnB.s:327    .text.HAL_TIM_PeriodElapsedCallback:00000000 HAL_TIM_PeriodElapsedCallback
     /tmp/ccv6GvnB.s:398    .text.HAL_TIM_PeriodElapsedCallback:0000005c $d
     /tmp/ccv6GvnB.s:406    .text._Error_Handler:00000000 $t
     /tmp/ccv6GvnB.s:411    .text._Error_Handler:00000000 _Error_Handler
     /tmp/ccv6GvnB.s:422    .text.MX_DAC_Init:00000000 $t
     /tmp/ccv6GvnB.s:426    .text.MX_DAC_Init:00000000 MX_DAC_Init
     /tmp/ccv6GvnB.s:480    .text.MX_DAC_Init:0000003c $d
                            *COM*:00000014 hdac
     /tmp/ccv6GvnB.s:488    .text.MX_TIM14_Init:00000000 $t
     /tmp/ccv6GvnB.s:492    .text.MX_TIM14_Init:00000000 MX_TIM14_Init
     /tmp/ccv6GvnB.s:541    .text.MX_TIM14_Init:00000034 $d
                            *COM*:00000040 htim14
     /tmp/ccv6GvnB.s:548    .text.MX_TIM15_Init:00000000 $t
     /tmp/ccv6GvnB.s:552    .text.MX_TIM15_Init:00000000 MX_TIM15_Init
     /tmp/ccv6GvnB.s:601    .text.MX_TIM15_Init:00000034 $d
                            *COM*:00000040 htim15
     /tmp/ccv6GvnB.s:608    .text.USER_TIM1_Init:00000000 $t
     /tmp/ccv6GvnB.s:612    .text.USER_TIM1_Init:00000000 USER_TIM1_Init
     /tmp/ccv6GvnB.s:757    .text.USER_TIM1_Init:000000b8 $d
                            *COM*:00000040 htim1
     /tmp/ccv6GvnB.s:769    .text.MX_ADC_Init:00000000 $t
     /tmp/ccv6GvnB.s:773    .text.MX_ADC_Init:00000000 MX_ADC_Init
     /tmp/ccv6GvnB.s:909    .text.MX_ADC_Init:000000b0 $d
                            *COM*:0000004c hadc
     /tmp/ccv6GvnB.s:917    .text.SystemClock_Config:00000000 $t
     /tmp/ccv6GvnB.s:922    .text.SystemClock_Config:00000000 SystemClock_Config
     /tmp/ccv6GvnB.s:1032   .text.SystemClock_Config:00000094 $d
     /tmp/ccv6GvnB.s:1044   .text.main:00000000 $t
     /tmp/ccv6GvnB.s:1049   .text.main:00000000 main
     /tmp/ccv6GvnB.s:1659   .text.main:00000360 $d
                            *COM*:00000006 adcBuffer
                            *COM*:00000001 uart_tx_dat
                            *COM*:00000004 midiBuffer
     /tmp/ccv6GvnB.s:1769   .bss.freqs:00000000 freqs
     /tmp/ccv6GvnB.s:1762   .bss.noteTimeout:00000000 noteTimeout
     /tmp/ccv6GvnB.s:1727   .bss.lastTone1:00000000 lastTone1
     /tmp/ccv6GvnB.s:1720   .bss.lastTone0:00000000 lastTone0
     /tmp/ccv6GvnB.s:1780   .bss.curChannel:00000000 curChannel
     /tmp/ccv6GvnB.s:1741   .bss.curTone1:00000000 curTone1
     /tmp/ccv6GvnB.s:1734   .bss.curTone0:00000000 curTone0
     /tmp/ccv6GvnB.s:1786   .bss.midiState:00000000 midiState
ARM GAS  /tmp/ccv6GvnB.s 			page 70


     /tmp/ccv6GvnB.s:1755   .bss.curPeriode1:00000000 curPeriode1
     /tmp/ccv6GvnB.s:1748   .bss.curPeriode0:00000000 curPeriode0
                            *COM*:00000044 hdma_adc
     /tmp/ccv6GvnB.s:1716   .bss.lastTone0:00000000 $d
     /tmp/ccv6GvnB.s:1723   .bss.lastTone1:00000000 $d
     /tmp/ccv6GvnB.s:1730   .bss.curTone0:00000000 $d
     /tmp/ccv6GvnB.s:1737   .bss.curTone1:00000000 $d
     /tmp/ccv6GvnB.s:1744   .bss.curPeriode0:00000000 $d
     /tmp/ccv6GvnB.s:1751   .bss.curPeriode1:00000000 $d
     /tmp/ccv6GvnB.s:1758   .bss.noteTimeout:00000000 $d
     /tmp/ccv6GvnB.s:1765   .bss.freqs:00000000 $d
     /tmp/ccv6GvnB.s:1772   .rodata.str1.4:00000000 $d
     /tmp/ccv6GvnB.s:1776   .bss.curChannel:00000000 $d
     /tmp/ccv6GvnB.s:1787   .bss.midiState:00000000 $d
                     .debug_frame:00000010 $d
     /tmp/ccv6GvnB.s:1715   .text.main:000003dc $t

UNDEFINED SYMBOLS
HAL_GPIO_WritePin
HAL_GPIO_Init
HAL_TIM_Base_Init
HAL_TIMEx_MasterConfigSynchronization
HAL_TIM_PWM_ConfigChannel
HAL_TIM_OnePulse_Init
HAL_TIM_MspPostInit
HAL_NVIC_SetPriority
HAL_NVIC_EnableIRQ
__aeabi_uidiv
HAL_DAC_Init
HAL_DAC_ConfigChannel
HAL_TIM_PWM_Init
HAL_TIMEx_ConfigBreakDeadTime
HAL_ADC_Init
HAL_ADC_ConfigChannel
HAL_RCC_OscConfig
HAL_RCC_ClockConfig
HAL_RCCEx_PeriphCLKConfig
HAL_RCC_GetHCLKFreq
HAL_SYSTICK_Config
HAL_SYSTICK_CLKSourceConfig
__aeabi_ui2f
__aeabi_fmul
__aeabi_fcmpgt
__aeabi_i2d
__aeabi_ddiv
__aeabi_dmul
__aeabi_d2uiz
HAL_Init
HAL_DAC_Start
HAL_DAC_SetValue
HAL_TIM_Base_Start_IT
HAL_TIM_PWM_Start
HAL_TIM_Base_Start
HAL_TIM_OnePulse_Start
HAL_ADC_Start_DMA
MX_USB_MIDI_INIT
midiInit
ARM GAS  /tmp/ccv6GvnB.s 			page 71


HAL_Delay
HAL_GPIO_ReadPin
HAL_GetTick
midiGetFromUsbRx
pow
hUsbDeviceFS
