ARM GAS  /tmp/ccWk3vHh.s 			page 1


   1              		.cpu cortex-m0
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"curebuffer.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.cureRingBufferU8Free,"ax",%progbits
  16              		.align	1
  17              		.global	cureRingBufferU8Free
  18              		.arch armv6s-m
  19              		.syntax unified
  20              		.code	16
  21              		.thumb_func
  22              		.fpu softvfp
  24              	cureRingBufferU8Free:
  25              	.LVL0:
  26              	.LFB1:
  27              		.file 1 "Src/curelib_src/curebuffer.c"
   1:Src/curelib_src/curebuffer.c **** /*
   2:Src/curelib_src/curebuffer.c ****  *******************************************************************************
   3:Src/curelib_src/curebuffer.c ****  *  [curebuffer.c]
   4:Src/curelib_src/curebuffer.c ****  *  This module is for FIFO buffer.
   5:Src/curelib_src/curebuffer.c ****  *
   6:Src/curelib_src/curebuffer.c ****  *  This program is under the terms of the GPLv3.
   7:Src/curelib_src/curebuffer.c ****  *  https://www.gnu.org/licenses/gpl-3.0.html
   8:Src/curelib_src/curebuffer.c ****  *
   9:Src/curelib_src/curebuffer.c ****  *  Copyright(c) 2017 Keshikan (www.keshikan.net)
  10:Src/curelib_src/curebuffer.c ****  *******************************************************************************
  11:Src/curelib_src/curebuffer.c ****  */
  12:Src/curelib_src/curebuffer.c **** 
  13:Src/curelib_src/curebuffer.c **** #include "curebuffer.h"
  14:Src/curelib_src/curebuffer.c **** #include <stdint.h>
  15:Src/curelib_src/curebuffer.c **** #include <stdlib.h>
  16:Src/curelib_src/curebuffer.c **** 
  17:Src/curelib_src/curebuffer.c **** 
  18:Src/curelib_src/curebuffer.c **** /////////////////////////////
  19:Src/curelib_src/curebuffer.c **** //methods for uint8_t FIFO.
  20:Src/curelib_src/curebuffer.c **** /////////////////////////////
  21:Src/curelib_src/curebuffer.c **** 
  22:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU8Init(RingBufferU8 *rbuf, uint16_t buflen)
  23:Src/curelib_src/curebuffer.c **** {
  24:Src/curelib_src/curebuffer.c **** 
  25:Src/curelib_src/curebuffer.c **** 	uint32_t i;
  26:Src/curelib_src/curebuffer.c **** 
  27:Src/curelib_src/curebuffer.c **** 	cureRingBufferU8Free(rbuf);
  28:Src/curelib_src/curebuffer.c **** 
  29:Src/curelib_src/curebuffer.c **** 		rbuf->buffer = (uint8_t *)malloc( buflen * sizeof(uint8_t) );
  30:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
  31:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
ARM GAS  /tmp/ccWk3vHh.s 			page 2


  32:Src/curelib_src/curebuffer.c **** 		}
  33:Src/curelib_src/curebuffer.c **** 		for(i=0; i<buflen; i++){
  34:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
  35:Src/curelib_src/curebuffer.c **** 		}
  36:Src/curelib_src/curebuffer.c **** 
  37:Src/curelib_src/curebuffer.c **** 	rbuf->length = buflen;
  38:Src/curelib_src/curebuffer.c **** 
  39:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
  40:Src/curelib_src/curebuffer.c **** }
  41:Src/curelib_src/curebuffer.c **** 
  42:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU8Free(RingBufferU8 *rbuf)
  43:Src/curelib_src/curebuffer.c **** {
  28              		.loc 1 43 1 view -0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              		.loc 1 43 1 is_stmt 0 view .LVU1
  33 0000 10B5     		push	{r4, lr}
  34              	.LCFI0:
  35              		.cfi_def_cfa_offset 8
  36              		.cfi_offset 4, -8
  37              		.cfi_offset 14, -4
  38 0002 0400     		movs	r4, r0
  44:Src/curelib_src/curebuffer.c **** 	if(NULL != rbuf->buffer){
  39              		.loc 1 44 2 is_stmt 1 view .LVU2
  40              		.loc 1 44 17 is_stmt 0 view .LVU3
  41 0004 8068     		ldr	r0, [r0, #8]
  42              	.LVL1:
  43              		.loc 1 44 4 view .LVU4
  44 0006 0028     		cmp	r0, #0
  45 0008 01D0     		beq	.L2
  45:Src/curelib_src/curebuffer.c **** 		free(rbuf->buffer);
  46              		.loc 1 45 3 is_stmt 1 view .LVU5
  47 000a FFF7FEFF 		bl	free
  48              	.LVL2:
  49              	.L2:
  46:Src/curelib_src/curebuffer.c **** 	}
  47:Src/curelib_src/curebuffer.c **** 
  48:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front = rbuf->idx_rear = 0;
  50              		.loc 1 48 2 view .LVU6
  51              		.loc 1 48 35 is_stmt 0 view .LVU7
  52 000e 0023     		movs	r3, #0
  53 0010 6380     		strh	r3, [r4, #2]
  54              		.loc 1 48 18 view .LVU8
  55 0012 2380     		strh	r3, [r4]
  49:Src/curelib_src/curebuffer.c **** 	rbuf->length = 0;
  56              		.loc 1 49 2 is_stmt 1 view .LVU9
  57              		.loc 1 49 15 is_stmt 0 view .LVU10
  58 0014 A380     		strh	r3, [r4, #4]
  50:Src/curelib_src/curebuffer.c **** 
  51:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
  59              		.loc 1 51 2 is_stmt 1 view .LVU11
  52:Src/curelib_src/curebuffer.c **** }
  60              		.loc 1 52 1 is_stmt 0 view .LVU12
  61 0016 0120     		movs	r0, #1
  62              		@ sp needed
  63              	.LVL3:
ARM GAS  /tmp/ccWk3vHh.s 			page 3


  64              		.loc 1 52 1 view .LVU13
  65 0018 10BD     		pop	{r4, pc}
  66              		.cfi_endproc
  67              	.LFE1:
  69              		.section	.text.cureRingBufferU8Init,"ax",%progbits
  70              		.align	1
  71              		.global	cureRingBufferU8Init
  72              		.syntax unified
  73              		.code	16
  74              		.thumb_func
  75              		.fpu softvfp
  77              	cureRingBufferU8Init:
  78              	.LVL4:
  79              	.LFB0:
  23:Src/curelib_src/curebuffer.c **** 
  80              		.loc 1 23 1 is_stmt 1 view -0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  23:Src/curelib_src/curebuffer.c **** 
  84              		.loc 1 23 1 is_stmt 0 view .LVU15
  85 0000 70B5     		push	{r4, r5, r6, lr}
  86              	.LCFI1:
  87              		.cfi_def_cfa_offset 16
  88              		.cfi_offset 4, -16
  89              		.cfi_offset 5, -12
  90              		.cfi_offset 6, -8
  91              		.cfi_offset 14, -4
  92 0002 0500     		movs	r5, r0
  93 0004 0C00     		movs	r4, r1
  25:Src/curelib_src/curebuffer.c **** 
  94              		.loc 1 25 2 is_stmt 1 view .LVU16
  27:Src/curelib_src/curebuffer.c **** 
  95              		.loc 1 27 2 view .LVU17
  96 0006 FFF7FEFF 		bl	cureRingBufferU8Free
  97              	.LVL5:
  29:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
  98              		.loc 1 29 3 view .LVU18
  29:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
  99              		.loc 1 29 29 is_stmt 0 view .LVU19
 100 000a 2600     		movs	r6, r4
 101 000c 2000     		movs	r0, r4
 102 000e FFF7FEFF 		bl	malloc
 103              	.LVL6:
  29:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 104              		.loc 1 29 16 view .LVU20
 105 0012 A860     		str	r0, [r5, #8]
  30:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 106              		.loc 1 30 3 is_stmt 1 view .LVU21
  30:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 107              		.loc 1 30 5 is_stmt 0 view .LVU22
 108 0014 0028     		cmp	r0, #0
 109 0016 0BD0     		beq	.L7
  33:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 110              		.loc 1 33 8 view .LVU23
 111 0018 0023     		movs	r3, #0
 112              	.L5:
ARM GAS  /tmp/ccWk3vHh.s 			page 4


 113              	.LVL7:
  33:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 114              		.loc 1 33 3 discriminator 1 view .LVU24
 115 001a 9E42     		cmp	r6, r3
 116 001c 05D9     		bls	.L8
  34:Src/curelib_src/curebuffer.c **** 		}
 117              		.loc 1 34 4 is_stmt 1 discriminator 3 view .LVU25
  34:Src/curelib_src/curebuffer.c **** 		}
 118              		.loc 1 34 16 is_stmt 0 discriminator 3 view .LVU26
 119 001e AA68     		ldr	r2, [r5, #8]
 120 0020 D218     		adds	r2, r2, r3
  34:Src/curelib_src/curebuffer.c **** 		}
 121              		.loc 1 34 20 discriminator 3 view .LVU27
 122 0022 0021     		movs	r1, #0
 123 0024 1170     		strb	r1, [r2]
  33:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 124              		.loc 1 33 23 discriminator 3 view .LVU28
 125 0026 0133     		adds	r3, r3, #1
 126              	.LVL8:
  33:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 127              		.loc 1 33 23 discriminator 3 view .LVU29
 128 0028 F7E7     		b	.L5
 129              	.L8:
  37:Src/curelib_src/curebuffer.c **** 
 130              		.loc 1 37 2 is_stmt 1 view .LVU30
  37:Src/curelib_src/curebuffer.c **** 
 131              		.loc 1 37 15 is_stmt 0 view .LVU31
 132 002a AC80     		strh	r4, [r5, #4]
  39:Src/curelib_src/curebuffer.c **** }
 133              		.loc 1 39 2 is_stmt 1 view .LVU32
  39:Src/curelib_src/curebuffer.c **** }
 134              		.loc 1 39 9 is_stmt 0 view .LVU33
 135 002c 0120     		movs	r0, #1
 136              	.LVL9:
 137              	.L4:
  40:Src/curelib_src/curebuffer.c **** 
 138              		.loc 1 40 1 view .LVU34
 139              		@ sp needed
 140              	.LVL10:
  40:Src/curelib_src/curebuffer.c **** 
 141              		.loc 1 40 1 view .LVU35
 142 002e 70BD     		pop	{r4, r5, r6, pc}
 143              	.LVL11:
 144              	.L7:
  31:Src/curelib_src/curebuffer.c **** 		}
 145              		.loc 1 31 11 view .LVU36
 146 0030 0020     		movs	r0, #0
 147 0032 FCE7     		b	.L4
 148              		.cfi_endproc
 149              	.LFE0:
 151              		.section	.text.cureRingBufferU8Enqueue,"ax",%progbits
 152              		.align	1
 153              		.global	cureRingBufferU8Enqueue
 154              		.syntax unified
 155              		.code	16
 156              		.thumb_func
 157              		.fpu softvfp
ARM GAS  /tmp/ccWk3vHh.s 			page 5


 159              	cureRingBufferU8Enqueue:
 160              	.LVL12:
 161              	.LFB2:
  53:Src/curelib_src/curebuffer.c **** 
  54:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU8Enqueue(RingBufferU8 *rbuf, uint8_t *inputc)
  55:Src/curelib_src/curebuffer.c **** {
 162              		.loc 1 55 1 is_stmt 1 view -0
 163              		.cfi_startproc
 164              		@ args = 0, pretend = 0, frame = 0
 165              		@ frame_needed = 0, uses_anonymous_args = 0
 166              		.loc 1 55 1 is_stmt 0 view .LVU38
 167 0000 10B5     		push	{r4, lr}
 168              	.LCFI2:
 169              		.cfi_def_cfa_offset 8
 170              		.cfi_offset 4, -8
 171              		.cfi_offset 14, -4
  56:Src/curelib_src/curebuffer.c **** 	if( ((rbuf->idx_front +1)&(rbuf->length -1)) == rbuf->idx_rear ){//buffer overrun error occurs.
 172              		.loc 1 56 2 is_stmt 1 view .LVU39
 173              		.loc 1 56 12 is_stmt 0 view .LVU40
 174 0002 0288     		ldrh	r2, [r0]
 175              		.loc 1 56 24 view .LVU41
 176 0004 541C     		adds	r4, r2, #1
 177              		.loc 1 56 33 view .LVU42
 178 0006 8388     		ldrh	r3, [r0, #4]
 179              		.loc 1 56 42 view .LVU43
 180 0008 013B     		subs	r3, r3, #1
 181              		.loc 1 56 27 view .LVU44
 182 000a 2340     		ands	r3, r4
 183              		.loc 1 56 54 view .LVU45
 184 000c 4488     		ldrh	r4, [r0, #2]
 185              		.loc 1 56 4 view .LVU46
 186 000e A342     		cmp	r3, r4
 187 0010 0CD0     		beq	.L11
  57:Src/curelib_src/curebuffer.c **** 		return BUFFER_FAILURE;
  58:Src/curelib_src/curebuffer.c **** 	}else{
  59:Src/curelib_src/curebuffer.c **** 
  60:Src/curelib_src/curebuffer.c **** 		rbuf->buffer[rbuf->idx_front]=  *inputc;
 188              		.loc 1 60 3 is_stmt 1 view .LVU47
 189              		.loc 1 60 35 is_stmt 0 view .LVU48
 190 0012 0B78     		ldrb	r3, [r1]
 191              		.loc 1 60 32 view .LVU49
 192 0014 8168     		ldr	r1, [r0, #8]
 193              	.LVL13:
 194              		.loc 1 60 32 view .LVU50
 195 0016 8B54     		strb	r3, [r1, r2]
  61:Src/curelib_src/curebuffer.c **** 		rbuf->idx_front++;
 196              		.loc 1 61 3 is_stmt 1 view .LVU51
 197              		.loc 1 61 7 is_stmt 0 view .LVU52
 198 0018 0388     		ldrh	r3, [r0]
 199              		.loc 1 61 18 view .LVU53
 200 001a 0133     		adds	r3, r3, #1
 201 001c 9BB2     		uxth	r3, r3
  62:Src/curelib_src/curebuffer.c **** 		rbuf->idx_front &= (rbuf->length -1);
 202              		.loc 1 62 3 is_stmt 1 view .LVU54
 203              		.loc 1 62 27 is_stmt 0 view .LVU55
 204 001e 8288     		ldrh	r2, [r0, #4]
 205              		.loc 1 62 36 view .LVU56
ARM GAS  /tmp/ccWk3vHh.s 			page 6


 206 0020 013A     		subs	r2, r2, #1
 207 0022 12B2     		sxth	r2, r2
 208              		.loc 1 62 19 view .LVU57
 209 0024 1340     		ands	r3, r2
 210 0026 0380     		strh	r3, [r0]
  63:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 211              		.loc 1 63 3 is_stmt 1 view .LVU58
 212              		.loc 1 63 10 is_stmt 0 view .LVU59
 213 0028 0120     		movs	r0, #1
 214              	.LVL14:
 215              	.L10:
  64:Src/curelib_src/curebuffer.c **** 	}
  65:Src/curelib_src/curebuffer.c **** }
 216              		.loc 1 65 1 view .LVU60
 217              		@ sp needed
 218 002a 10BD     		pop	{r4, pc}
 219              	.LVL15:
 220              	.L11:
  57:Src/curelib_src/curebuffer.c **** 	}else{
 221              		.loc 1 57 10 view .LVU61
 222 002c 0020     		movs	r0, #0
 223              	.LVL16:
  57:Src/curelib_src/curebuffer.c **** 	}else{
 224              		.loc 1 57 10 view .LVU62
 225 002e FCE7     		b	.L10
 226              		.cfi_endproc
 227              	.LFE2:
 229              		.section	.text.cureRingBufferU8Dequeue,"ax",%progbits
 230              		.align	1
 231              		.global	cureRingBufferU8Dequeue
 232              		.syntax unified
 233              		.code	16
 234              		.thumb_func
 235              		.fpu softvfp
 237              	cureRingBufferU8Dequeue:
 238              	.LVL17:
 239              	.LFB3:
  66:Src/curelib_src/curebuffer.c **** 
  67:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU8Dequeue(RingBufferU8 *rbuf, uint8_t *ret)
  68:Src/curelib_src/curebuffer.c **** {
 240              		.loc 1 68 1 is_stmt 1 view -0
 241              		.cfi_startproc
 242              		@ args = 0, pretend = 0, frame = 0
 243              		@ frame_needed = 0, uses_anonymous_args = 0
 244              		@ link register save eliminated.
  69:Src/curelib_src/curebuffer.c **** 	if(rbuf->idx_front == rbuf->idx_rear){//if buffer underrun error occurs.
 245              		.loc 1 69 2 view .LVU64
 246              		.loc 1 69 9 is_stmt 0 view .LVU65
 247 0000 0288     		ldrh	r2, [r0]
 248              		.loc 1 69 28 view .LVU66
 249 0002 4388     		ldrh	r3, [r0, #2]
 250              		.loc 1 69 4 view .LVU67
 251 0004 9A42     		cmp	r2, r3
 252 0006 0CD0     		beq	.L14
  70:Src/curelib_src/curebuffer.c **** 		return BUFFER_FAILURE;
  71:Src/curelib_src/curebuffer.c **** 	}else{
  72:Src/curelib_src/curebuffer.c **** 
ARM GAS  /tmp/ccWk3vHh.s 			page 7


  73:Src/curelib_src/curebuffer.c **** 		*ret = (rbuf->buffer[rbuf->idx_rear]);
 253              		.loc 1 73 3 is_stmt 1 view .LVU68
 254              		.loc 1 73 23 is_stmt 0 view .LVU69
 255 0008 8268     		ldr	r2, [r0, #8]
 256 000a D35C     		ldrb	r3, [r2, r3]
 257              		.loc 1 73 8 view .LVU70
 258 000c 0B70     		strb	r3, [r1]
  74:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear++;
 259              		.loc 1 74 3 is_stmt 1 view .LVU71
 260              		.loc 1 74 7 is_stmt 0 view .LVU72
 261 000e 4388     		ldrh	r3, [r0, #2]
 262              		.loc 1 74 17 view .LVU73
 263 0010 0133     		adds	r3, r3, #1
 264 0012 9BB2     		uxth	r3, r3
  75:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear &= (rbuf->length -1);
 265              		.loc 1 75 3 is_stmt 1 view .LVU74
 266              		.loc 1 75 26 is_stmt 0 view .LVU75
 267 0014 8288     		ldrh	r2, [r0, #4]
 268              		.loc 1 75 35 view .LVU76
 269 0016 013A     		subs	r2, r2, #1
 270 0018 12B2     		sxth	r2, r2
 271              		.loc 1 75 18 view .LVU77
 272 001a 1340     		ands	r3, r2
 273 001c 4380     		strh	r3, [r0, #2]
  76:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 274              		.loc 1 76 3 is_stmt 1 view .LVU78
 275              		.loc 1 76 10 is_stmt 0 view .LVU79
 276 001e 0120     		movs	r0, #1
 277              	.LVL18:
 278              	.L13:
  77:Src/curelib_src/curebuffer.c **** 	}
  78:Src/curelib_src/curebuffer.c **** }
 279              		.loc 1 78 1 view .LVU80
 280              		@ sp needed
 281 0020 7047     		bx	lr
 282              	.LVL19:
 283              	.L14:
  70:Src/curelib_src/curebuffer.c **** 	}else{
 284              		.loc 1 70 10 view .LVU81
 285 0022 0020     		movs	r0, #0
 286              	.LVL20:
  70:Src/curelib_src/curebuffer.c **** 	}else{
 287              		.loc 1 70 10 view .LVU82
 288 0024 FCE7     		b	.L13
 289              		.cfi_endproc
 290              	.LFE3:
 292              		.section	.text._cureRingBufferU8GetUsedSize,"ax",%progbits
 293              		.align	1
 294              		.global	_cureRingBufferU8GetUsedSize
 295              		.syntax unified
 296              		.code	16
 297              		.thumb_func
 298              		.fpu softvfp
 300              	_cureRingBufferU8GetUsedSize:
 301              	.LVL21:
 302              	.LFB4:
  79:Src/curelib_src/curebuffer.c **** 
ARM GAS  /tmp/ccWk3vHh.s 			page 8


  80:Src/curelib_src/curebuffer.c **** //debug
  81:Src/curelib_src/curebuffer.c **** uint16_t _cureRingBufferU8GetUsedSize(RingBufferU8 *rbuf)
  82:Src/curelib_src/curebuffer.c **** {
 303              		.loc 1 82 1 is_stmt 1 view -0
 304              		.cfi_startproc
 305              		@ args = 0, pretend = 0, frame = 0
 306              		@ frame_needed = 0, uses_anonymous_args = 0
 307              		@ link register save eliminated.
  83:Src/curelib_src/curebuffer.c **** 	if(rbuf->idx_front >= rbuf->idx_rear){
 308              		.loc 1 83 2 view .LVU84
 309              		.loc 1 83 9 is_stmt 0 view .LVU85
 310 0000 0388     		ldrh	r3, [r0]
 311              		.loc 1 83 28 view .LVU86
 312 0002 4288     		ldrh	r2, [r0, #2]
 313              		.loc 1 83 4 view .LVU87
 314 0004 9342     		cmp	r3, r2
 315 0006 02D3     		bcc	.L16
  84:Src/curelib_src/curebuffer.c **** 		return rbuf->idx_front - rbuf->idx_rear;
 316              		.loc 1 84 3 is_stmt 1 view .LVU88
 317              		.loc 1 84 26 is_stmt 0 view .LVU89
 318 0008 981A     		subs	r0, r3, r2
 319              	.LVL22:
 320              		.loc 1 84 26 view .LVU90
 321 000a 80B2     		uxth	r0, r0
 322              	.L17:
  85:Src/curelib_src/curebuffer.c **** 	}else{
  86:Src/curelib_src/curebuffer.c **** 		return rbuf->idx_front + rbuf->length - rbuf->idx_rear;
  87:Src/curelib_src/curebuffer.c **** 	}
  88:Src/curelib_src/curebuffer.c **** 
  89:Src/curelib_src/curebuffer.c **** }
 323              		.loc 1 89 1 view .LVU91
 324              		@ sp needed
 325 000c 7047     		bx	lr
 326              	.LVL23:
 327              	.L16:
  86:Src/curelib_src/curebuffer.c **** 	}
 328              		.loc 1 86 3 is_stmt 1 view .LVU92
  86:Src/curelib_src/curebuffer.c **** 	}
 329              		.loc 1 86 32 is_stmt 0 view .LVU93
 330 000e 8088     		ldrh	r0, [r0, #4]
 331              	.LVL24:
  86:Src/curelib_src/curebuffer.c **** 	}
 332              		.loc 1 86 26 view .LVU94
 333 0010 1818     		adds	r0, r3, r0
 334 0012 80B2     		uxth	r0, r0
  86:Src/curelib_src/curebuffer.c **** 	}
 335              		.loc 1 86 41 view .LVU95
 336 0014 801A     		subs	r0, r0, r2
 337 0016 80B2     		uxth	r0, r0
 338 0018 F8E7     		b	.L17
 339              		.cfi_endproc
 340              	.LFE4:
 342              		.section	.text.cureRingBuffer16Free,"ax",%progbits
 343              		.align	1
 344              		.global	cureRingBuffer16Free
 345              		.syntax unified
 346              		.code	16
ARM GAS  /tmp/ccWk3vHh.s 			page 9


 347              		.thumb_func
 348              		.fpu softvfp
 350              	cureRingBuffer16Free:
 351              	.LVL25:
 352              	.LFB6:
  90:Src/curelib_src/curebuffer.c **** 
  91:Src/curelib_src/curebuffer.c **** /////////////////////////////
  92:Src/curelib_src/curebuffer.c **** //methods for int16_t FIFO.
  93:Src/curelib_src/curebuffer.c **** /////////////////////////////
  94:Src/curelib_src/curebuffer.c **** 
  95:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBuffer16Init(RingBuffer16 *rbuf, uint16_t buflen)
  96:Src/curelib_src/curebuffer.c **** {
  97:Src/curelib_src/curebuffer.c **** 
  98:Src/curelib_src/curebuffer.c **** 	uint32_t i;
  99:Src/curelib_src/curebuffer.c **** 
 100:Src/curelib_src/curebuffer.c **** 	cureRingBuffer16Free(rbuf);
 101:Src/curelib_src/curebuffer.c **** 
 102:Src/curelib_src/curebuffer.c **** 		rbuf->buffer = (int16_t *)malloc( buflen * sizeof(int16_t) );
 103:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 104:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 105:Src/curelib_src/curebuffer.c **** 		}
 106:Src/curelib_src/curebuffer.c **** 		for(i=0; i<buflen; i++){
 107:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 108:Src/curelib_src/curebuffer.c **** 		}
 109:Src/curelib_src/curebuffer.c **** 	rbuf->length = buflen;
 110:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 111:Src/curelib_src/curebuffer.c **** }
 112:Src/curelib_src/curebuffer.c **** 
 113:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBuffer16Free(RingBuffer16 *rbuf)
 114:Src/curelib_src/curebuffer.c **** {
 353              		.loc 1 114 1 is_stmt 1 view -0
 354              		.cfi_startproc
 355              		@ args = 0, pretend = 0, frame = 0
 356              		@ frame_needed = 0, uses_anonymous_args = 0
 357              		.loc 1 114 1 is_stmt 0 view .LVU97
 358 0000 10B5     		push	{r4, lr}
 359              	.LCFI3:
 360              		.cfi_def_cfa_offset 8
 361              		.cfi_offset 4, -8
 362              		.cfi_offset 14, -4
 363 0002 0400     		movs	r4, r0
 115:Src/curelib_src/curebuffer.c **** 	if(NULL != rbuf->buffer){
 364              		.loc 1 115 2 is_stmt 1 view .LVU98
 365              		.loc 1 115 17 is_stmt 0 view .LVU99
 366 0004 8068     		ldr	r0, [r0, #8]
 367              	.LVL26:
 368              		.loc 1 115 4 view .LVU100
 369 0006 0028     		cmp	r0, #0
 370 0008 01D0     		beq	.L19
 116:Src/curelib_src/curebuffer.c **** 		free(rbuf->buffer);
 371              		.loc 1 116 3 is_stmt 1 view .LVU101
 372 000a FFF7FEFF 		bl	free
 373              	.LVL27:
 374              	.L19:
 117:Src/curelib_src/curebuffer.c **** 	}
 118:Src/curelib_src/curebuffer.c **** 
 119:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front = rbuf->idx_rear = 0;
ARM GAS  /tmp/ccWk3vHh.s 			page 10


 375              		.loc 1 119 2 view .LVU102
 376              		.loc 1 119 35 is_stmt 0 view .LVU103
 377 000e 0023     		movs	r3, #0
 378 0010 6380     		strh	r3, [r4, #2]
 379              		.loc 1 119 18 view .LVU104
 380 0012 2380     		strh	r3, [r4]
 120:Src/curelib_src/curebuffer.c **** 	rbuf->length = 0;
 381              		.loc 1 120 2 is_stmt 1 view .LVU105
 382              		.loc 1 120 15 is_stmt 0 view .LVU106
 383 0014 A380     		strh	r3, [r4, #4]
 121:Src/curelib_src/curebuffer.c **** 
 122:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 384              		.loc 1 122 2 is_stmt 1 view .LVU107
 123:Src/curelib_src/curebuffer.c **** }
 385              		.loc 1 123 1 is_stmt 0 view .LVU108
 386 0016 0120     		movs	r0, #1
 387              		@ sp needed
 388              	.LVL28:
 389              		.loc 1 123 1 view .LVU109
 390 0018 10BD     		pop	{r4, pc}
 391              		.cfi_endproc
 392              	.LFE6:
 394              		.section	.text.cureRingBuffer16Init,"ax",%progbits
 395              		.align	1
 396              		.global	cureRingBuffer16Init
 397              		.syntax unified
 398              		.code	16
 399              		.thumb_func
 400              		.fpu softvfp
 402              	cureRingBuffer16Init:
 403              	.LVL29:
 404              	.LFB5:
  96:Src/curelib_src/curebuffer.c **** 
 405              		.loc 1 96 1 is_stmt 1 view -0
 406              		.cfi_startproc
 407              		@ args = 0, pretend = 0, frame = 0
 408              		@ frame_needed = 0, uses_anonymous_args = 0
  96:Src/curelib_src/curebuffer.c **** 
 409              		.loc 1 96 1 is_stmt 0 view .LVU111
 410 0000 70B5     		push	{r4, r5, r6, lr}
 411              	.LCFI4:
 412              		.cfi_def_cfa_offset 16
 413              		.cfi_offset 4, -16
 414              		.cfi_offset 5, -12
 415              		.cfi_offset 6, -8
 416              		.cfi_offset 14, -4
 417 0002 0400     		movs	r4, r0
 418 0004 0E00     		movs	r6, r1
  98:Src/curelib_src/curebuffer.c **** 
 419              		.loc 1 98 2 is_stmt 1 view .LVU112
 100:Src/curelib_src/curebuffer.c **** 
 420              		.loc 1 100 2 view .LVU113
 421 0006 FFF7FEFF 		bl	cureRingBuffer16Free
 422              	.LVL30:
 102:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 423              		.loc 1 102 3 view .LVU114
 102:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
ARM GAS  /tmp/ccWk3vHh.s 			page 11


 424              		.loc 1 102 29 is_stmt 0 view .LVU115
 425 000a 3500     		movs	r5, r6
 426 000c 7000     		lsls	r0, r6, #1
 427 000e FFF7FEFF 		bl	malloc
 428              	.LVL31:
 102:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 429              		.loc 1 102 16 view .LVU116
 430 0012 A060     		str	r0, [r4, #8]
 103:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 431              		.loc 1 103 3 is_stmt 1 view .LVU117
 103:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 432              		.loc 1 103 5 is_stmt 0 view .LVU118
 433 0014 0028     		cmp	r0, #0
 434 0016 0DD0     		beq	.L24
 106:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 435              		.loc 1 106 8 view .LVU119
 436 0018 0023     		movs	r3, #0
 437              	.L22:
 438              	.LVL32:
 106:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 439              		.loc 1 106 3 discriminator 1 view .LVU120
 440 001a 9D42     		cmp	r5, r3
 441 001c 07D9     		bls	.L25
 107:Src/curelib_src/curebuffer.c **** 		}
 442              		.loc 1 107 4 is_stmt 1 discriminator 3 view .LVU121
 107:Src/curelib_src/curebuffer.c **** 		}
 443              		.loc 1 107 16 is_stmt 0 discriminator 3 view .LVU122
 444 001e 5A00     		lsls	r2, r3, #1
 445 0020 A168     		ldr	r1, [r4, #8]
 446 0022 8C46     		mov	ip, r1
 447 0024 6244     		add	r2, r2, ip
 107:Src/curelib_src/curebuffer.c **** 		}
 448              		.loc 1 107 20 discriminator 3 view .LVU123
 449 0026 0021     		movs	r1, #0
 450 0028 1180     		strh	r1, [r2]
 106:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 451              		.loc 1 106 23 discriminator 3 view .LVU124
 452 002a 0133     		adds	r3, r3, #1
 453              	.LVL33:
 106:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 454              		.loc 1 106 23 discriminator 3 view .LVU125
 455 002c F5E7     		b	.L22
 456              	.L25:
 109:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 457              		.loc 1 109 2 is_stmt 1 view .LVU126
 109:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 458              		.loc 1 109 15 is_stmt 0 view .LVU127
 459 002e A680     		strh	r6, [r4, #4]
 110:Src/curelib_src/curebuffer.c **** }
 460              		.loc 1 110 2 is_stmt 1 view .LVU128
 110:Src/curelib_src/curebuffer.c **** }
 461              		.loc 1 110 9 is_stmt 0 view .LVU129
 462 0030 0120     		movs	r0, #1
 463              	.LVL34:
 464              	.L21:
 111:Src/curelib_src/curebuffer.c **** 
 465              		.loc 1 111 1 view .LVU130
ARM GAS  /tmp/ccWk3vHh.s 			page 12


 466              		@ sp needed
 467              	.LVL35:
 111:Src/curelib_src/curebuffer.c **** 
 468              		.loc 1 111 1 view .LVU131
 469 0032 70BD     		pop	{r4, r5, r6, pc}
 470              	.LVL36:
 471              	.L24:
 104:Src/curelib_src/curebuffer.c **** 		}
 472              		.loc 1 104 11 view .LVU132
 473 0034 0020     		movs	r0, #0
 474 0036 FCE7     		b	.L21
 475              		.cfi_endproc
 476              	.LFE5:
 478              		.section	.text.cureRingBuffer16Enqueue,"ax",%progbits
 479              		.align	1
 480              		.global	cureRingBuffer16Enqueue
 481              		.syntax unified
 482              		.code	16
 483              		.thumb_func
 484              		.fpu softvfp
 486              	cureRingBuffer16Enqueue:
 487              	.LVL37:
 488              	.LFB7:
 124:Src/curelib_src/curebuffer.c **** 
 125:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBuffer16Enqueue(RingBuffer16 *rbuf, int16_t *inputc)
 126:Src/curelib_src/curebuffer.c **** {
 489              		.loc 1 126 1 is_stmt 1 view -0
 490              		.cfi_startproc
 491              		@ args = 0, pretend = 0, frame = 0
 492              		@ frame_needed = 0, uses_anonymous_args = 0
 493              		.loc 1 126 1 is_stmt 0 view .LVU134
 494 0000 10B5     		push	{r4, lr}
 495              	.LCFI5:
 496              		.cfi_def_cfa_offset 8
 497              		.cfi_offset 4, -8
 498              		.cfi_offset 14, -4
 127:Src/curelib_src/curebuffer.c **** 	if( ((rbuf->idx_front +1)&(rbuf->length -1)) == rbuf->idx_rear ){//buffer overrun error occurs.
 499              		.loc 1 127 2 is_stmt 1 view .LVU135
 500              		.loc 1 127 12 is_stmt 0 view .LVU136
 501 0002 0288     		ldrh	r2, [r0]
 502              		.loc 1 127 24 view .LVU137
 503 0004 541C     		adds	r4, r2, #1
 504              		.loc 1 127 33 view .LVU138
 505 0006 8388     		ldrh	r3, [r0, #4]
 506              		.loc 1 127 42 view .LVU139
 507 0008 013B     		subs	r3, r3, #1
 508              		.loc 1 127 27 view .LVU140
 509 000a 2340     		ands	r3, r4
 510              		.loc 1 127 54 view .LVU141
 511 000c 4488     		ldrh	r4, [r0, #2]
 512              		.loc 1 127 4 view .LVU142
 513 000e A342     		cmp	r3, r4
 514 0010 0ED0     		beq	.L28
 128:Src/curelib_src/curebuffer.c **** 		return BUFFER_FAILURE;
 129:Src/curelib_src/curebuffer.c **** 	}else{
 130:Src/curelib_src/curebuffer.c **** 		rbuf->buffer[rbuf->idx_front]=  *inputc;
 515              		.loc 1 130 3 is_stmt 1 view .LVU143
ARM GAS  /tmp/ccWk3vHh.s 			page 13


 516              		.loc 1 130 15 is_stmt 0 view .LVU144
 517 0012 5200     		lsls	r2, r2, #1
 518              		.loc 1 130 35 view .LVU145
 519 0014 0023     		movs	r3, #0
 520 0016 CB5E     		ldrsh	r3, [r1, r3]
 521              	.LVL38:
 522              		.loc 1 130 32 view .LVU146
 523 0018 8168     		ldr	r1, [r0, #8]
 524 001a 8B52     		strh	r3, [r1, r2]
 131:Src/curelib_src/curebuffer.c **** 		rbuf->idx_front++;
 525              		.loc 1 131 3 is_stmt 1 view .LVU147
 526              		.loc 1 131 7 is_stmt 0 view .LVU148
 527 001c 0388     		ldrh	r3, [r0]
 528              		.loc 1 131 18 view .LVU149
 529 001e 0133     		adds	r3, r3, #1
 530 0020 9BB2     		uxth	r3, r3
 132:Src/curelib_src/curebuffer.c **** 		rbuf->idx_front &= (rbuf->length -1);
 531              		.loc 1 132 3 is_stmt 1 view .LVU150
 532              		.loc 1 132 27 is_stmt 0 view .LVU151
 533 0022 8288     		ldrh	r2, [r0, #4]
 534              		.loc 1 132 36 view .LVU152
 535 0024 013A     		subs	r2, r2, #1
 536 0026 12B2     		sxth	r2, r2
 537              		.loc 1 132 19 view .LVU153
 538 0028 1340     		ands	r3, r2
 539 002a 0380     		strh	r3, [r0]
 133:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 540              		.loc 1 133 3 is_stmt 1 view .LVU154
 541              		.loc 1 133 10 is_stmt 0 view .LVU155
 542 002c 0120     		movs	r0, #1
 543              	.LVL39:
 544              	.L27:
 134:Src/curelib_src/curebuffer.c **** 	}
 135:Src/curelib_src/curebuffer.c **** }
 545              		.loc 1 135 1 view .LVU156
 546              		@ sp needed
 547 002e 10BD     		pop	{r4, pc}
 548              	.LVL40:
 549              	.L28:
 128:Src/curelib_src/curebuffer.c **** 	}else{
 550              		.loc 1 128 10 view .LVU157
 551 0030 0020     		movs	r0, #0
 552              	.LVL41:
 128:Src/curelib_src/curebuffer.c **** 	}else{
 553              		.loc 1 128 10 view .LVU158
 554 0032 FCE7     		b	.L27
 555              		.cfi_endproc
 556              	.LFE7:
 558              		.section	.text.cureRingBuffer16EnqueueIgnoreErr,"ax",%progbits
 559              		.align	1
 560              		.global	cureRingBuffer16EnqueueIgnoreErr
 561              		.syntax unified
 562              		.code	16
 563              		.thumb_func
 564              		.fpu softvfp
 566              	cureRingBuffer16EnqueueIgnoreErr:
 567              	.LVL42:
ARM GAS  /tmp/ccWk3vHh.s 			page 14


 568              	.LFB8:
 136:Src/curelib_src/curebuffer.c **** 
 137:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBuffer16EnqueueIgnoreErr(RingBuffer16 *rbuf, int16_t *inputc)
 138:Src/curelib_src/curebuffer.c **** {
 569              		.loc 1 138 1 is_stmt 1 view -0
 570              		.cfi_startproc
 571              		@ args = 0, pretend = 0, frame = 0
 572              		@ frame_needed = 0, uses_anonymous_args = 0
 573              		@ link register save eliminated.
 139:Src/curelib_src/curebuffer.c **** 
 140:Src/curelib_src/curebuffer.c **** 	rbuf->buffer[rbuf->idx_front]= *inputc;
 574              		.loc 1 140 2 view .LVU160
 575              		.loc 1 140 19 is_stmt 0 view .LVU161
 576 0000 0388     		ldrh	r3, [r0]
 577              		.loc 1 140 14 view .LVU162
 578 0002 5B00     		lsls	r3, r3, #1
 579              		.loc 1 140 33 view .LVU163
 580 0004 0022     		movs	r2, #0
 581 0006 8A5E     		ldrsh	r2, [r1, r2]
 582              	.LVL43:
 583              		.loc 1 140 31 view .LVU164
 584 0008 8168     		ldr	r1, [r0, #8]
 585 000a CA52     		strh	r2, [r1, r3]
 141:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front++;
 586              		.loc 1 141 2 is_stmt 1 view .LVU165
 587              		.loc 1 141 6 is_stmt 0 view .LVU166
 588 000c 0388     		ldrh	r3, [r0]
 589              		.loc 1 141 17 view .LVU167
 590 000e 0133     		adds	r3, r3, #1
 591 0010 9BB2     		uxth	r3, r3
 142:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front &= (rbuf->length -1);
 592              		.loc 1 142 2 is_stmt 1 view .LVU168
 593              		.loc 1 142 26 is_stmt 0 view .LVU169
 594 0012 8288     		ldrh	r2, [r0, #4]
 595              		.loc 1 142 35 view .LVU170
 596 0014 013A     		subs	r2, r2, #1
 597 0016 12B2     		sxth	r2, r2
 598              		.loc 1 142 18 view .LVU171
 599 0018 1340     		ands	r3, r2
 600 001a 0380     		strh	r3, [r0]
 143:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 601              		.loc 1 143 2 is_stmt 1 view .LVU172
 144:Src/curelib_src/curebuffer.c **** 
 145:Src/curelib_src/curebuffer.c **** }
 602              		.loc 1 145 1 is_stmt 0 view .LVU173
 603 001c 0120     		movs	r0, #1
 604              	.LVL44:
 605              		.loc 1 145 1 view .LVU174
 606              		@ sp needed
 607 001e 7047     		bx	lr
 608              		.cfi_endproc
 609              	.LFE8:
 611              		.section	.text.cureRingBuffer16Dequeue,"ax",%progbits
 612              		.align	1
 613              		.global	cureRingBuffer16Dequeue
 614              		.syntax unified
 615              		.code	16
ARM GAS  /tmp/ccWk3vHh.s 			page 15


 616              		.thumb_func
 617              		.fpu softvfp
 619              	cureRingBuffer16Dequeue:
 620              	.LVL45:
 621              	.LFB9:
 146:Src/curelib_src/curebuffer.c **** 
 147:Src/curelib_src/curebuffer.c **** 
 148:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBuffer16Dequeue(RingBuffer16 *rbuf, int16_t *ret)
 149:Src/curelib_src/curebuffer.c **** {
 622              		.loc 1 149 1 is_stmt 1 view -0
 623              		.cfi_startproc
 624              		@ args = 0, pretend = 0, frame = 0
 625              		@ frame_needed = 0, uses_anonymous_args = 0
 626              		@ link register save eliminated.
 150:Src/curelib_src/curebuffer.c **** 	if(rbuf->idx_front == rbuf->idx_rear){//if buffer underrun error occurs.
 627              		.loc 1 150 2 view .LVU176
 628              		.loc 1 150 9 is_stmt 0 view .LVU177
 629 0000 0288     		ldrh	r2, [r0]
 630              		.loc 1 150 28 view .LVU178
 631 0002 4388     		ldrh	r3, [r0, #2]
 632              		.loc 1 150 4 view .LVU179
 633 0004 9A42     		cmp	r2, r3
 634 0006 0DD0     		beq	.L32
 151:Src/curelib_src/curebuffer.c **** 		return BUFFER_FAILURE;
 152:Src/curelib_src/curebuffer.c **** 	}else{
 153:Src/curelib_src/curebuffer.c **** 		*ret = (rbuf->buffer[rbuf->idx_rear]);
 635              		.loc 1 153 3 is_stmt 1 view .LVU180
 636              		.loc 1 153 23 is_stmt 0 view .LVU181
 637 0008 5B00     		lsls	r3, r3, #1
 638 000a 8268     		ldr	r2, [r0, #8]
 639 000c 9B5E     		ldrsh	r3, [r3, r2]
 640              		.loc 1 153 8 view .LVU182
 641 000e 0B80     		strh	r3, [r1]
 154:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear++;
 642              		.loc 1 154 3 is_stmt 1 view .LVU183
 643              		.loc 1 154 7 is_stmt 0 view .LVU184
 644 0010 4388     		ldrh	r3, [r0, #2]
 645              		.loc 1 154 17 view .LVU185
 646 0012 0133     		adds	r3, r3, #1
 647 0014 9BB2     		uxth	r3, r3
 155:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear &= (rbuf->length -1);
 648              		.loc 1 155 3 is_stmt 1 view .LVU186
 649              		.loc 1 155 26 is_stmt 0 view .LVU187
 650 0016 8288     		ldrh	r2, [r0, #4]
 651              		.loc 1 155 35 view .LVU188
 652 0018 013A     		subs	r2, r2, #1
 653 001a 12B2     		sxth	r2, r2
 654              		.loc 1 155 18 view .LVU189
 655 001c 1340     		ands	r3, r2
 656 001e 4380     		strh	r3, [r0, #2]
 156:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 657              		.loc 1 156 3 is_stmt 1 view .LVU190
 658              		.loc 1 156 10 is_stmt 0 view .LVU191
 659 0020 0120     		movs	r0, #1
 660              	.LVL46:
 661              	.L31:
 157:Src/curelib_src/curebuffer.c **** 	}
ARM GAS  /tmp/ccWk3vHh.s 			page 16


 158:Src/curelib_src/curebuffer.c **** }
 662              		.loc 1 158 1 view .LVU192
 663              		@ sp needed
 664 0022 7047     		bx	lr
 665              	.LVL47:
 666              	.L32:
 151:Src/curelib_src/curebuffer.c **** 	}else{
 667              		.loc 1 151 10 view .LVU193
 668 0024 0020     		movs	r0, #0
 669              	.LVL48:
 151:Src/curelib_src/curebuffer.c **** 	}else{
 670              		.loc 1 151 10 view .LVU194
 671 0026 FCE7     		b	.L31
 672              		.cfi_endproc
 673              	.LFE9:
 675              		.section	.text.cureRingBuffer16GetElement,"ax",%progbits
 676              		.align	1
 677              		.global	cureRingBuffer16GetElement
 678              		.syntax unified
 679              		.code	16
 680              		.thumb_func
 681              		.fpu softvfp
 683              	cureRingBuffer16GetElement:
 684              	.LVL49:
 685              	.LFB10:
 159:Src/curelib_src/curebuffer.c **** 
 160:Src/curelib_src/curebuffer.c **** 
 161:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBuffer16GetElement(RingBuffer16 *rbuf, int16_t *ret, uint16_t delaynum, uint1
 162:Src/curelib_src/curebuffer.c **** {
 686              		.loc 1 162 1 is_stmt 1 view -0
 687              		.cfi_startproc
 688              		@ args = 0, pretend = 0, frame = 0
 689              		@ frame_needed = 0, uses_anonymous_args = 0
 690              		.loc 1 162 1 is_stmt 0 view .LVU196
 691 0000 10B5     		push	{r4, lr}
 692              	.LCFI6:
 693              		.cfi_def_cfa_offset 8
 694              		.cfi_offset 4, -8
 695              		.cfi_offset 14, -4
 163:Src/curelib_src/curebuffer.c **** 
 164:Src/curelib_src/curebuffer.c **** 	if(rbuf->idx_front >= delaynum){
 696              		.loc 1 164 2 is_stmt 1 view .LVU197
 697              		.loc 1 164 9 is_stmt 0 view .LVU198
 698 0002 0488     		ldrh	r4, [r0]
 699              		.loc 1 164 4 view .LVU199
 700 0004 9442     		cmp	r4, r2
 701 0006 08D3     		bcc	.L34
 165:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear = rbuf->idx_front - delaynum;
 702              		.loc 1 165 3 is_stmt 1 view .LVU200
 703              		.loc 1 165 36 is_stmt 0 view .LVU201
 704 0008 A41A     		subs	r4, r4, r2
 705              		.loc 1 165 18 view .LVU202
 706 000a 4480     		strh	r4, [r0, #2]
 707              	.L35:
 166:Src/curelib_src/curebuffer.c **** 	}else{
 167:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear = delay_buffer_length - (delaynum - rbuf->idx_front);
 168:Src/curelib_src/curebuffer.c **** 	}
ARM GAS  /tmp/ccWk3vHh.s 			page 17


 169:Src/curelib_src/curebuffer.c **** 		*ret = (rbuf->buffer[rbuf->idx_rear]);
 708              		.loc 1 169 3 is_stmt 1 view .LVU203
 709              		.loc 1 169 15 is_stmt 0 view .LVU204
 710 000c 8268     		ldr	r2, [r0, #8]
 711              	.LVL50:
 712              		.loc 1 169 28 view .LVU205
 713 000e 4388     		ldrh	r3, [r0, #2]
 714              	.LVL51:
 715              		.loc 1 169 23 view .LVU206
 716 0010 5B00     		lsls	r3, r3, #1
 717 0012 9B5E     		ldrsh	r3, [r3, r2]
 718              		.loc 1 169 8 view .LVU207
 719 0014 0B80     		strh	r3, [r1]
 170:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 720              		.loc 1 170 3 is_stmt 1 view .LVU208
 171:Src/curelib_src/curebuffer.c **** 
 172:Src/curelib_src/curebuffer.c **** }
 721              		.loc 1 172 1 is_stmt 0 view .LVU209
 722 0016 0120     		movs	r0, #1
 723              	.LVL52:
 724              		.loc 1 172 1 view .LVU210
 725              		@ sp needed
 726 0018 10BD     		pop	{r4, pc}
 727              	.LVL53:
 728              	.L34:
 167:Src/curelib_src/curebuffer.c **** 	}
 729              		.loc 1 167 3 is_stmt 1 view .LVU211
 167:Src/curelib_src/curebuffer.c **** 	}
 730              		.loc 1 167 40 is_stmt 0 view .LVU212
 731 001a A41A     		subs	r4, r4, r2
 732 001c 1C19     		adds	r4, r3, r4
 167:Src/curelib_src/curebuffer.c **** 	}
 733              		.loc 1 167 18 view .LVU213
 734 001e 4480     		strh	r4, [r0, #2]
 735 0020 F4E7     		b	.L35
 736              		.cfi_endproc
 737              	.LFE10:
 739              		.section	.text.cureRingBufferU32Free,"ax",%progbits
 740              		.align	1
 741              		.global	cureRingBufferU32Free
 742              		.syntax unified
 743              		.code	16
 744              		.thumb_func
 745              		.fpu softvfp
 747              	cureRingBufferU32Free:
 748              	.LVL54:
 749              	.LFB12:
 173:Src/curelib_src/curebuffer.c **** 
 174:Src/curelib_src/curebuffer.c **** /////////////////////////////
 175:Src/curelib_src/curebuffer.c **** //methods for uint32_t FIFO.
 176:Src/curelib_src/curebuffer.c **** /////////////////////////////
 177:Src/curelib_src/curebuffer.c **** 
 178:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU32Init(RingBuffer32 *rbuf, uint16_t buflen)
 179:Src/curelib_src/curebuffer.c **** {
 180:Src/curelib_src/curebuffer.c **** 
 181:Src/curelib_src/curebuffer.c **** 	uint32_t i;
 182:Src/curelib_src/curebuffer.c **** 
ARM GAS  /tmp/ccWk3vHh.s 			page 18


 183:Src/curelib_src/curebuffer.c **** 	cureRingBufferU32Free(rbuf);
 184:Src/curelib_src/curebuffer.c **** 
 185:Src/curelib_src/curebuffer.c **** 		rbuf->buffer = (uint32_t *)malloc( buflen * sizeof(uint32_t) );
 186:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 187:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 188:Src/curelib_src/curebuffer.c **** 		}
 189:Src/curelib_src/curebuffer.c **** 		for(i=0; i<buflen; i++){
 190:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 191:Src/curelib_src/curebuffer.c **** 		}
 192:Src/curelib_src/curebuffer.c **** 	rbuf->length = buflen;
 193:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 194:Src/curelib_src/curebuffer.c **** }
 195:Src/curelib_src/curebuffer.c **** 
 196:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU32Free(RingBuffer32 *rbuf)
 197:Src/curelib_src/curebuffer.c **** {
 750              		.loc 1 197 1 is_stmt 1 view -0
 751              		.cfi_startproc
 752              		@ args = 0, pretend = 0, frame = 0
 753              		@ frame_needed = 0, uses_anonymous_args = 0
 754              		.loc 1 197 1 is_stmt 0 view .LVU215
 755 0000 10B5     		push	{r4, lr}
 756              	.LCFI7:
 757              		.cfi_def_cfa_offset 8
 758              		.cfi_offset 4, -8
 759              		.cfi_offset 14, -4
 760 0002 0400     		movs	r4, r0
 198:Src/curelib_src/curebuffer.c **** 	if(NULL != rbuf->buffer){
 761              		.loc 1 198 2 is_stmt 1 view .LVU216
 762              		.loc 1 198 17 is_stmt 0 view .LVU217
 763 0004 8068     		ldr	r0, [r0, #8]
 764              	.LVL55:
 765              		.loc 1 198 4 view .LVU218
 766 0006 0028     		cmp	r0, #0
 767 0008 01D0     		beq	.L37
 199:Src/curelib_src/curebuffer.c **** 		free(rbuf->buffer);
 768              		.loc 1 199 3 is_stmt 1 view .LVU219
 769 000a FFF7FEFF 		bl	free
 770              	.LVL56:
 771              	.L37:
 200:Src/curelib_src/curebuffer.c **** 	}
 201:Src/curelib_src/curebuffer.c **** 
 202:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front = rbuf->idx_rear = 0;
 772              		.loc 1 202 2 view .LVU220
 773              		.loc 1 202 35 is_stmt 0 view .LVU221
 774 000e 0023     		movs	r3, #0
 775 0010 6380     		strh	r3, [r4, #2]
 776              		.loc 1 202 18 view .LVU222
 777 0012 2380     		strh	r3, [r4]
 203:Src/curelib_src/curebuffer.c **** 	rbuf->length = 0;
 778              		.loc 1 203 2 is_stmt 1 view .LVU223
 779              		.loc 1 203 15 is_stmt 0 view .LVU224
 780 0014 A380     		strh	r3, [r4, #4]
 204:Src/curelib_src/curebuffer.c **** 
 205:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 781              		.loc 1 205 2 is_stmt 1 view .LVU225
 206:Src/curelib_src/curebuffer.c **** }
 782              		.loc 1 206 1 is_stmt 0 view .LVU226
ARM GAS  /tmp/ccWk3vHh.s 			page 19


 783 0016 0120     		movs	r0, #1
 784              		@ sp needed
 785              	.LVL57:
 786              		.loc 1 206 1 view .LVU227
 787 0018 10BD     		pop	{r4, pc}
 788              		.cfi_endproc
 789              	.LFE12:
 791              		.section	.text.cureRingBufferU32Init,"ax",%progbits
 792              		.align	1
 793              		.global	cureRingBufferU32Init
 794              		.syntax unified
 795              		.code	16
 796              		.thumb_func
 797              		.fpu softvfp
 799              	cureRingBufferU32Init:
 800              	.LVL58:
 801              	.LFB11:
 179:Src/curelib_src/curebuffer.c **** 
 802              		.loc 1 179 1 is_stmt 1 view -0
 803              		.cfi_startproc
 804              		@ args = 0, pretend = 0, frame = 0
 805              		@ frame_needed = 0, uses_anonymous_args = 0
 179:Src/curelib_src/curebuffer.c **** 
 806              		.loc 1 179 1 is_stmt 0 view .LVU229
 807 0000 70B5     		push	{r4, r5, r6, lr}
 808              	.LCFI8:
 809              		.cfi_def_cfa_offset 16
 810              		.cfi_offset 4, -16
 811              		.cfi_offset 5, -12
 812              		.cfi_offset 6, -8
 813              		.cfi_offset 14, -4
 814 0002 0400     		movs	r4, r0
 815 0004 0E00     		movs	r6, r1
 181:Src/curelib_src/curebuffer.c **** 
 816              		.loc 1 181 2 is_stmt 1 view .LVU230
 183:Src/curelib_src/curebuffer.c **** 
 817              		.loc 1 183 2 view .LVU231
 818 0006 FFF7FEFF 		bl	cureRingBufferU32Free
 819              	.LVL59:
 185:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 820              		.loc 1 185 3 view .LVU232
 185:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 821              		.loc 1 185 30 is_stmt 0 view .LVU233
 822 000a 3500     		movs	r5, r6
 823 000c B000     		lsls	r0, r6, #2
 824 000e FFF7FEFF 		bl	malloc
 825              	.LVL60:
 185:Src/curelib_src/curebuffer.c **** 		if(NULL == rbuf->buffer){
 826              		.loc 1 185 16 view .LVU234
 827 0012 A060     		str	r0, [r4, #8]
 186:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 828              		.loc 1 186 3 is_stmt 1 view .LVU235
 186:Src/curelib_src/curebuffer.c **** 			return BUFFER_FAILURE;
 829              		.loc 1 186 5 is_stmt 0 view .LVU236
 830 0014 0028     		cmp	r0, #0
 831 0016 0DD0     		beq	.L42
 189:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
ARM GAS  /tmp/ccWk3vHh.s 			page 20


 832              		.loc 1 189 8 view .LVU237
 833 0018 0023     		movs	r3, #0
 834              	.L40:
 835              	.LVL61:
 189:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 836              		.loc 1 189 3 discriminator 1 view .LVU238
 837 001a 9D42     		cmp	r5, r3
 838 001c 07D9     		bls	.L43
 190:Src/curelib_src/curebuffer.c **** 		}
 839              		.loc 1 190 4 is_stmt 1 discriminator 3 view .LVU239
 190:Src/curelib_src/curebuffer.c **** 		}
 840              		.loc 1 190 16 is_stmt 0 discriminator 3 view .LVU240
 841 001e 9A00     		lsls	r2, r3, #2
 842 0020 A168     		ldr	r1, [r4, #8]
 843 0022 8C46     		mov	ip, r1
 844 0024 6244     		add	r2, r2, ip
 190:Src/curelib_src/curebuffer.c **** 		}
 845              		.loc 1 190 20 discriminator 3 view .LVU241
 846 0026 0021     		movs	r1, #0
 847 0028 1160     		str	r1, [r2]
 189:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 848              		.loc 1 189 23 discriminator 3 view .LVU242
 849 002a 0133     		adds	r3, r3, #1
 850              	.LVL62:
 189:Src/curelib_src/curebuffer.c **** 			rbuf->buffer[i] = 0;
 851              		.loc 1 189 23 discriminator 3 view .LVU243
 852 002c F5E7     		b	.L40
 853              	.L43:
 192:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 854              		.loc 1 192 2 is_stmt 1 view .LVU244
 192:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 855              		.loc 1 192 15 is_stmt 0 view .LVU245
 856 002e A680     		strh	r6, [r4, #4]
 193:Src/curelib_src/curebuffer.c **** }
 857              		.loc 1 193 2 is_stmt 1 view .LVU246
 193:Src/curelib_src/curebuffer.c **** }
 858              		.loc 1 193 9 is_stmt 0 view .LVU247
 859 0030 0120     		movs	r0, #1
 860              	.LVL63:
 861              	.L39:
 194:Src/curelib_src/curebuffer.c **** 
 862              		.loc 1 194 1 view .LVU248
 863              		@ sp needed
 864              	.LVL64:
 194:Src/curelib_src/curebuffer.c **** 
 865              		.loc 1 194 1 view .LVU249
 866 0032 70BD     		pop	{r4, r5, r6, pc}
 867              	.LVL65:
 868              	.L42:
 187:Src/curelib_src/curebuffer.c **** 		}
 869              		.loc 1 187 11 view .LVU250
 870 0034 0020     		movs	r0, #0
 871 0036 FCE7     		b	.L39
 872              		.cfi_endproc
 873              	.LFE11:
 875              		.section	.text.cureRingBufferU32Enqueue,"ax",%progbits
 876              		.align	1
ARM GAS  /tmp/ccWk3vHh.s 			page 21


 877              		.global	cureRingBufferU32Enqueue
 878              		.syntax unified
 879              		.code	16
 880              		.thumb_func
 881              		.fpu softvfp
 883              	cureRingBufferU32Enqueue:
 884              	.LVL66:
 885              	.LFB13:
 207:Src/curelib_src/curebuffer.c **** 
 208:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU32Enqueue(RingBuffer32 *rbuf, uint32_t *inputc)
 209:Src/curelib_src/curebuffer.c **** {
 886              		.loc 1 209 1 is_stmt 1 view -0
 887              		.cfi_startproc
 888              		@ args = 0, pretend = 0, frame = 0
 889              		@ frame_needed = 0, uses_anonymous_args = 0
 890              		.loc 1 209 1 is_stmt 0 view .LVU252
 891 0000 10B5     		push	{r4, lr}
 892              	.LCFI9:
 893              		.cfi_def_cfa_offset 8
 894              		.cfi_offset 4, -8
 895              		.cfi_offset 14, -4
 210:Src/curelib_src/curebuffer.c **** 	if( ((rbuf->idx_front +1)&(rbuf->length -1)) == rbuf->idx_rear ){//buffer overrun error occurs.
 896              		.loc 1 210 2 is_stmt 1 view .LVU253
 897              		.loc 1 210 12 is_stmt 0 view .LVU254
 898 0002 0288     		ldrh	r2, [r0]
 899              		.loc 1 210 24 view .LVU255
 900 0004 541C     		adds	r4, r2, #1
 901              		.loc 1 210 33 view .LVU256
 902 0006 8388     		ldrh	r3, [r0, #4]
 903              		.loc 1 210 42 view .LVU257
 904 0008 013B     		subs	r3, r3, #1
 905              		.loc 1 210 27 view .LVU258
 906 000a 2340     		ands	r3, r4
 907              		.loc 1 210 54 view .LVU259
 908 000c 4488     		ldrh	r4, [r0, #2]
 909              		.loc 1 210 4 view .LVU260
 910 000e A342     		cmp	r3, r4
 911 0010 0DD0     		beq	.L46
 211:Src/curelib_src/curebuffer.c **** 		return BUFFER_FAILURE;
 212:Src/curelib_src/curebuffer.c **** 	}else{
 213:Src/curelib_src/curebuffer.c **** 		rbuf->buffer[rbuf->idx_front]=  *inputc;
 912              		.loc 1 213 3 is_stmt 1 view .LVU261
 913              		.loc 1 213 15 is_stmt 0 view .LVU262
 914 0012 9200     		lsls	r2, r2, #2
 915              		.loc 1 213 35 view .LVU263
 916 0014 0B68     		ldr	r3, [r1]
 917              		.loc 1 213 32 view .LVU264
 918 0016 8168     		ldr	r1, [r0, #8]
 919              	.LVL67:
 920              		.loc 1 213 32 view .LVU265
 921 0018 8B50     		str	r3, [r1, r2]
 214:Src/curelib_src/curebuffer.c **** 		rbuf->idx_front++;
 922              		.loc 1 214 3 is_stmt 1 view .LVU266
 923              		.loc 1 214 7 is_stmt 0 view .LVU267
 924 001a 0388     		ldrh	r3, [r0]
 925              		.loc 1 214 18 view .LVU268
 926 001c 0133     		adds	r3, r3, #1
ARM GAS  /tmp/ccWk3vHh.s 			page 22


 927 001e 9BB2     		uxth	r3, r3
 215:Src/curelib_src/curebuffer.c **** 		rbuf->idx_front &= (rbuf->length -1);
 928              		.loc 1 215 3 is_stmt 1 view .LVU269
 929              		.loc 1 215 27 is_stmt 0 view .LVU270
 930 0020 8288     		ldrh	r2, [r0, #4]
 931              		.loc 1 215 36 view .LVU271
 932 0022 013A     		subs	r2, r2, #1
 933 0024 12B2     		sxth	r2, r2
 934              		.loc 1 215 19 view .LVU272
 935 0026 1340     		ands	r3, r2
 936 0028 0380     		strh	r3, [r0]
 216:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 937              		.loc 1 216 3 is_stmt 1 view .LVU273
 938              		.loc 1 216 10 is_stmt 0 view .LVU274
 939 002a 0120     		movs	r0, #1
 940              	.LVL68:
 941              	.L45:
 217:Src/curelib_src/curebuffer.c **** 	}
 218:Src/curelib_src/curebuffer.c **** }
 942              		.loc 1 218 1 view .LVU275
 943              		@ sp needed
 944 002c 10BD     		pop	{r4, pc}
 945              	.LVL69:
 946              	.L46:
 211:Src/curelib_src/curebuffer.c **** 	}else{
 947              		.loc 1 211 10 view .LVU276
 948 002e 0020     		movs	r0, #0
 949              	.LVL70:
 211:Src/curelib_src/curebuffer.c **** 	}else{
 950              		.loc 1 211 10 view .LVU277
 951 0030 FCE7     		b	.L45
 952              		.cfi_endproc
 953              	.LFE13:
 955              		.section	.text.cureRingBufferU32EnqueueIgnoreErr,"ax",%progbits
 956              		.align	1
 957              		.global	cureRingBufferU32EnqueueIgnoreErr
 958              		.syntax unified
 959              		.code	16
 960              		.thumb_func
 961              		.fpu softvfp
 963              	cureRingBufferU32EnqueueIgnoreErr:
 964              	.LVL71:
 965              	.LFB14:
 219:Src/curelib_src/curebuffer.c **** 
 220:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU32EnqueueIgnoreErr(RingBuffer32 *rbuf, uint32_t *inputc)
 221:Src/curelib_src/curebuffer.c **** {
 966              		.loc 1 221 1 is_stmt 1 view -0
 967              		.cfi_startproc
 968              		@ args = 0, pretend = 0, frame = 0
 969              		@ frame_needed = 0, uses_anonymous_args = 0
 970              		@ link register save eliminated.
 222:Src/curelib_src/curebuffer.c **** 
 223:Src/curelib_src/curebuffer.c **** 	rbuf->buffer[rbuf->idx_front]= *inputc;
 971              		.loc 1 223 2 view .LVU279
 972              		.loc 1 223 19 is_stmt 0 view .LVU280
 973 0000 0388     		ldrh	r3, [r0]
 974              		.loc 1 223 14 view .LVU281
ARM GAS  /tmp/ccWk3vHh.s 			page 23


 975 0002 9B00     		lsls	r3, r3, #2
 976              		.loc 1 223 33 view .LVU282
 977 0004 0A68     		ldr	r2, [r1]
 978              		.loc 1 223 31 view .LVU283
 979 0006 8168     		ldr	r1, [r0, #8]
 980              	.LVL72:
 981              		.loc 1 223 31 view .LVU284
 982 0008 CA50     		str	r2, [r1, r3]
 224:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front++;
 983              		.loc 1 224 2 is_stmt 1 view .LVU285
 984              		.loc 1 224 6 is_stmt 0 view .LVU286
 985 000a 0388     		ldrh	r3, [r0]
 986              		.loc 1 224 17 view .LVU287
 987 000c 0133     		adds	r3, r3, #1
 988 000e 9BB2     		uxth	r3, r3
 225:Src/curelib_src/curebuffer.c **** 	rbuf->idx_front &= (rbuf->length -1);
 989              		.loc 1 225 2 is_stmt 1 view .LVU288
 990              		.loc 1 225 26 is_stmt 0 view .LVU289
 991 0010 8288     		ldrh	r2, [r0, #4]
 992              		.loc 1 225 35 view .LVU290
 993 0012 013A     		subs	r2, r2, #1
 994 0014 12B2     		sxth	r2, r2
 995              		.loc 1 225 18 view .LVU291
 996 0016 1340     		ands	r3, r2
 997 0018 0380     		strh	r3, [r0]
 226:Src/curelib_src/curebuffer.c **** 	return BUFFER_SUCCESS;
 998              		.loc 1 226 2 is_stmt 1 view .LVU292
 227:Src/curelib_src/curebuffer.c **** 
 228:Src/curelib_src/curebuffer.c **** }
 999              		.loc 1 228 1 is_stmt 0 view .LVU293
 1000 001a 0120     		movs	r0, #1
 1001              	.LVL73:
 1002              		.loc 1 228 1 view .LVU294
 1003              		@ sp needed
 1004 001c 7047     		bx	lr
 1005              		.cfi_endproc
 1006              	.LFE14:
 1008              		.section	.text.cureRingBufferU32Dequeue,"ax",%progbits
 1009              		.align	1
 1010              		.global	cureRingBufferU32Dequeue
 1011              		.syntax unified
 1012              		.code	16
 1013              		.thumb_func
 1014              		.fpu softvfp
 1016              	cureRingBufferU32Dequeue:
 1017              	.LVL74:
 1018              	.LFB15:
 229:Src/curelib_src/curebuffer.c **** 
 230:Src/curelib_src/curebuffer.c **** 
 231:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU32Dequeue(RingBuffer32 *rbuf, uint32_t *ret)
 232:Src/curelib_src/curebuffer.c **** {
 1019              		.loc 1 232 1 is_stmt 1 view -0
 1020              		.cfi_startproc
 1021              		@ args = 0, pretend = 0, frame = 0
 1022              		@ frame_needed = 0, uses_anonymous_args = 0
 1023              		@ link register save eliminated.
 233:Src/curelib_src/curebuffer.c **** 	if(rbuf->idx_front == rbuf->idx_rear){//if buffer underrun error occurs.
ARM GAS  /tmp/ccWk3vHh.s 			page 24


 1024              		.loc 1 233 2 view .LVU296
 1025              		.loc 1 233 9 is_stmt 0 view .LVU297
 1026 0000 0288     		ldrh	r2, [r0]
 1027              		.loc 1 233 28 view .LVU298
 1028 0002 4388     		ldrh	r3, [r0, #2]
 1029              		.loc 1 233 4 view .LVU299
 1030 0004 9A42     		cmp	r2, r3
 1031 0006 0DD0     		beq	.L50
 234:Src/curelib_src/curebuffer.c **** 		return BUFFER_FAILURE;
 235:Src/curelib_src/curebuffer.c **** 	}else{
 236:Src/curelib_src/curebuffer.c **** 		*ret = (rbuf->buffer[rbuf->idx_rear]);
 1032              		.loc 1 236 3 is_stmt 1 view .LVU300
 1033              		.loc 1 236 15 is_stmt 0 view .LVU301
 1034 0008 8268     		ldr	r2, [r0, #8]
 1035              		.loc 1 236 23 view .LVU302
 1036 000a 9B00     		lsls	r3, r3, #2
 1037 000c 9B58     		ldr	r3, [r3, r2]
 1038 000e 0B60     		str	r3, [r1]
 237:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear++;
 1039              		.loc 1 237 3 is_stmt 1 view .LVU303
 1040              		.loc 1 237 7 is_stmt 0 view .LVU304
 1041 0010 4388     		ldrh	r3, [r0, #2]
 1042              		.loc 1 237 17 view .LVU305
 1043 0012 0133     		adds	r3, r3, #1
 1044 0014 9BB2     		uxth	r3, r3
 238:Src/curelib_src/curebuffer.c **** 		rbuf->idx_rear &= (rbuf->length -1);
 1045              		.loc 1 238 3 is_stmt 1 view .LVU306
 1046              		.loc 1 238 26 is_stmt 0 view .LVU307
 1047 0016 8288     		ldrh	r2, [r0, #4]
 1048              		.loc 1 238 35 view .LVU308
 1049 0018 013A     		subs	r2, r2, #1
 1050 001a 12B2     		sxth	r2, r2
 1051              		.loc 1 238 18 view .LVU309
 1052 001c 1340     		ands	r3, r2
 1053 001e 4380     		strh	r3, [r0, #2]
 239:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
 1054              		.loc 1 239 3 is_stmt 1 view .LVU310
 1055              		.loc 1 239 10 is_stmt 0 view .LVU311
 1056 0020 0120     		movs	r0, #1
 1057              	.LVL75:
 1058              	.L49:
 240:Src/curelib_src/curebuffer.c **** 	}
 241:Src/curelib_src/curebuffer.c **** }
 1059              		.loc 1 241 1 view .LVU312
 1060              		@ sp needed
 1061 0022 7047     		bx	lr
 1062              	.LVL76:
 1063              	.L50:
 234:Src/curelib_src/curebuffer.c **** 	}else{
 1064              		.loc 1 234 10 view .LVU313
 1065 0024 0020     		movs	r0, #0
 1066              	.LVL77:
 234:Src/curelib_src/curebuffer.c **** 	}else{
 1067              		.loc 1 234 10 view .LVU314
 1068 0026 FCE7     		b	.L49
 1069              		.cfi_endproc
 1070              	.LFE15:
ARM GAS  /tmp/ccWk3vHh.s 			page 25


 1072              		.section	.text.cureRingBufferU32GetElement,"ax",%progbits
 1073              		.align	1
 1074              		.global	cureRingBufferU32GetElement
 1075              		.syntax unified
 1076              		.code	16
 1077              		.thumb_func
 1078              		.fpu softvfp
 1080              	cureRingBufferU32GetElement:
 1081              	.LVL78:
 1082              	.LFB16:
 242:Src/curelib_src/curebuffer.c **** 
 243:Src/curelib_src/curebuffer.c **** 
 244:Src/curelib_src/curebuffer.c **** BUFFER_STATUS cureRingBufferU32GetElement(RingBuffer32 *rbuf, uint32_t *ret, uint16_t delaynum, uin
 245:Src/curelib_src/curebuffer.c **** {
 1083              		.loc 1 245 1 is_stmt 1 view -0
 1084              		.cfi_startproc
 1085              		@ args = 0, pretend = 0, frame = 0
 1086              		@ frame_needed = 0, uses_anonymous_args = 0
 1087              		.loc 1 245 1 is_stmt 0 view .LVU316
 1088 0000 10B5     		push	{r4, lr}
 1089              	.LCFI10:
 1090              		.cfi_def_cfa_offset 8
 1091              		.cfi_offset 4, -8
 1092              		.cfi_offset 14, -4
 246:Src/curelib_src/curebuffer.c **** 	uint16_t buf;
 1093              		.loc 1 246 2 is_stmt 1 view .LVU317
 247:Src/curelib_src/curebuffer.c **** 
 248:Src/curelib_src/curebuffer.c **** 
 249:Src/curelib_src/curebuffer.c **** 	if(rbuf->idx_front >= delaynum){
 1094              		.loc 1 249 2 view .LVU318
 1095              		.loc 1 249 9 is_stmt 0 view .LVU319
 1096 0002 0488     		ldrh	r4, [r0]
 1097              		.loc 1 249 4 view .LVU320
 1098 0004 9442     		cmp	r4, r2
 1099 0006 07D3     		bcc	.L52
 250:Src/curelib_src/curebuffer.c **** 		buf = rbuf->idx_front - delaynum;
 1100              		.loc 1 250 3 is_stmt 1 view .LVU321
 1101              		.loc 1 250 7 is_stmt 0 view .LVU322
 1102 0008 A41A     		subs	r4, r4, r2
 1103 000a A3B2     		uxth	r3, r4
 1104              	.LVL79:
 1105              	.L53:
 251:Src/curelib_src/curebuffer.c **** 	}else{
 252:Src/curelib_src/curebuffer.c **** 		buf = delay_buffer_length - (delaynum - rbuf->idx_front);
 253:Src/curelib_src/curebuffer.c **** 	}
 254:Src/curelib_src/curebuffer.c **** 		*ret = (rbuf->buffer[buf]);
 1106              		.loc 1 254 3 is_stmt 1 view .LVU323
 1107              		.loc 1 254 15 is_stmt 0 view .LVU324
 1108 000c 8268     		ldr	r2, [r0, #8]
 1109              	.LVL80:
 1110              		.loc 1 254 23 view .LVU325
 1111 000e 9B00     		lsls	r3, r3, #2
 1112              	.LVL81:
 1113              		.loc 1 254 23 view .LVU326
 1114 0010 9B58     		ldr	r3, [r3, r2]
 1115 0012 0B60     		str	r3, [r1]
 255:Src/curelib_src/curebuffer.c **** 		return BUFFER_SUCCESS;
ARM GAS  /tmp/ccWk3vHh.s 			page 26


 1116              		.loc 1 255 3 is_stmt 1 view .LVU327
 256:Src/curelib_src/curebuffer.c **** 
 257:Src/curelib_src/curebuffer.c **** }
 1117              		.loc 1 257 1 is_stmt 0 view .LVU328
 1118 0014 0120     		movs	r0, #1
 1119              	.LVL82:
 1120              		.loc 1 257 1 view .LVU329
 1121              		@ sp needed
 1122 0016 10BD     		pop	{r4, pc}
 1123              	.LVL83:
 1124              	.L52:
 252:Src/curelib_src/curebuffer.c **** 	}
 1125              		.loc 1 252 3 is_stmt 1 view .LVU330
 252:Src/curelib_src/curebuffer.c **** 	}
 1126              		.loc 1 252 29 is_stmt 0 view .LVU331
 1127 0018 A41A     		subs	r4, r4, r2
 1128 001a A4B2     		uxth	r4, r4
 252:Src/curelib_src/curebuffer.c **** 	}
 1129              		.loc 1 252 7 view .LVU332
 1130 001c E318     		adds	r3, r4, r3
 1131              	.LVL84:
 252:Src/curelib_src/curebuffer.c **** 	}
 1132              		.loc 1 252 7 view .LVU333
 1133 001e 9BB2     		uxth	r3, r3
 1134              	.LVL85:
 252:Src/curelib_src/curebuffer.c **** 	}
 1135              		.loc 1 252 7 view .LVU334
 1136 0020 F4E7     		b	.L53
 1137              		.cfi_endproc
 1138              	.LFE16:
 1140              		.text
 1141              	.Letext0:
 1142              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1143              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1144              		.file 4 "Inc/curelib_inc/curebuffer.h"
 1145              		.file 5 "/usr/arm-none-eabi/include/sys/lock.h"
 1146              		.file 6 "/usr/arm-none-eabi/include/sys/_types.h"
 1147              		.file 7 "/usr/lib/gcc/arm-none-eabi/8.3.0/include/stddef.h"
 1148              		.file 8 "/usr/arm-none-eabi/include/sys/reent.h"
 1149              		.file 9 "/usr/arm-none-eabi/include/stdlib.h"
ARM GAS  /tmp/ccWk3vHh.s 			page 27


DEFINED SYMBOLS
                            *ABS*:0000000000000000 curebuffer.c
     /tmp/ccWk3vHh.s:16     .text.cureRingBufferU8Free:0000000000000000 $t
     /tmp/ccWk3vHh.s:24     .text.cureRingBufferU8Free:0000000000000000 cureRingBufferU8Free
     /tmp/ccWk3vHh.s:70     .text.cureRingBufferU8Init:0000000000000000 $t
     /tmp/ccWk3vHh.s:77     .text.cureRingBufferU8Init:0000000000000000 cureRingBufferU8Init
     /tmp/ccWk3vHh.s:152    .text.cureRingBufferU8Enqueue:0000000000000000 $t
     /tmp/ccWk3vHh.s:159    .text.cureRingBufferU8Enqueue:0000000000000000 cureRingBufferU8Enqueue
     /tmp/ccWk3vHh.s:230    .text.cureRingBufferU8Dequeue:0000000000000000 $t
     /tmp/ccWk3vHh.s:237    .text.cureRingBufferU8Dequeue:0000000000000000 cureRingBufferU8Dequeue
     /tmp/ccWk3vHh.s:293    .text._cureRingBufferU8GetUsedSize:0000000000000000 $t
     /tmp/ccWk3vHh.s:300    .text._cureRingBufferU8GetUsedSize:0000000000000000 _cureRingBufferU8GetUsedSize
     /tmp/ccWk3vHh.s:343    .text.cureRingBuffer16Free:0000000000000000 $t
     /tmp/ccWk3vHh.s:350    .text.cureRingBuffer16Free:0000000000000000 cureRingBuffer16Free
     /tmp/ccWk3vHh.s:395    .text.cureRingBuffer16Init:0000000000000000 $t
     /tmp/ccWk3vHh.s:402    .text.cureRingBuffer16Init:0000000000000000 cureRingBuffer16Init
     /tmp/ccWk3vHh.s:479    .text.cureRingBuffer16Enqueue:0000000000000000 $t
     /tmp/ccWk3vHh.s:486    .text.cureRingBuffer16Enqueue:0000000000000000 cureRingBuffer16Enqueue
     /tmp/ccWk3vHh.s:559    .text.cureRingBuffer16EnqueueIgnoreErr:0000000000000000 $t
     /tmp/ccWk3vHh.s:566    .text.cureRingBuffer16EnqueueIgnoreErr:0000000000000000 cureRingBuffer16EnqueueIgnoreErr
     /tmp/ccWk3vHh.s:612    .text.cureRingBuffer16Dequeue:0000000000000000 $t
     /tmp/ccWk3vHh.s:619    .text.cureRingBuffer16Dequeue:0000000000000000 cureRingBuffer16Dequeue
     /tmp/ccWk3vHh.s:676    .text.cureRingBuffer16GetElement:0000000000000000 $t
     /tmp/ccWk3vHh.s:683    .text.cureRingBuffer16GetElement:0000000000000000 cureRingBuffer16GetElement
     /tmp/ccWk3vHh.s:740    .text.cureRingBufferU32Free:0000000000000000 $t
     /tmp/ccWk3vHh.s:747    .text.cureRingBufferU32Free:0000000000000000 cureRingBufferU32Free
     /tmp/ccWk3vHh.s:792    .text.cureRingBufferU32Init:0000000000000000 $t
     /tmp/ccWk3vHh.s:799    .text.cureRingBufferU32Init:0000000000000000 cureRingBufferU32Init
     /tmp/ccWk3vHh.s:876    .text.cureRingBufferU32Enqueue:0000000000000000 $t
     /tmp/ccWk3vHh.s:883    .text.cureRingBufferU32Enqueue:0000000000000000 cureRingBufferU32Enqueue
     /tmp/ccWk3vHh.s:956    .text.cureRingBufferU32EnqueueIgnoreErr:0000000000000000 $t
     /tmp/ccWk3vHh.s:963    .text.cureRingBufferU32EnqueueIgnoreErr:0000000000000000 cureRingBufferU32EnqueueIgnoreErr
     /tmp/ccWk3vHh.s:1009   .text.cureRingBufferU32Dequeue:0000000000000000 $t
     /tmp/ccWk3vHh.s:1016   .text.cureRingBufferU32Dequeue:0000000000000000 cureRingBufferU32Dequeue
     /tmp/ccWk3vHh.s:1073   .text.cureRingBufferU32GetElement:0000000000000000 $t
     /tmp/ccWk3vHh.s:1080   .text.cureRingBufferU32GetElement:0000000000000000 cureRingBufferU32GetElement

UNDEFINED SYMBOLS
free
malloc
